<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Don&#39;t Panic!</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://farseer.cn/"/>
  <updated>2017-09-16T14:50:51.321Z</updated>
  <id>http://farseer.cn/</id>
  
  <author>
    <name>Farseer He</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Commutators</title>
    <link href="http://farseer.cn/2017/09/16/Commutators/"/>
    <id>http://farseer.cn/2017/09/16/Commutators/</id>
    <published>2017-09-16T09:25:12.000Z</published>
    <updated>2017-09-16T14:50:51.321Z</updated>
    
    <content type="html">&lt;p&gt;In quantum mechanics we assume the following: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Each observable is associated with an &lt;a href=&quot;https://en.wikipedia.org/wiki/Hermitian_operator&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hermitian operator&lt;/a&gt; of a Hilbert space H. Its eigenvalues must be real and the eigenstates are orthogonal to each other, thus form a set of basis of H.&lt;/li&gt;
&lt;li&gt;Upon observation, one of the eigenvalues will be the quantity and the wave function will collapse onto one of the corresponding eigenstates.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here I don’t want to discuss the deep insights, which I have no idea of. That’s why I take &lt;a href=&quot;https://en.wikipedia.org/wiki/Copenhagen_interpretation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Copenhagen interpretation&lt;/a&gt;, so shut up and compute!&lt;/p&gt;
&lt;p&gt;This article is written as a note of my understanding of physical and mathematical meaning of commutators, mainly the answer to the question: “why do commute operators have a common set of eigenstates ?”&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Definition&quot;&gt;&lt;a href=&quot;#Definition&quot; class=&quot;headerlink&quot; title=&quot;Definition&quot;&gt;&lt;/a&gt;Definition&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Suppose $\hat{A}, \hat{B}$ are operators of $H \to H$&lt;/li&gt;
&lt;li&gt;Then the commutator of them are defined as $[\hat{A}, \hat{B}] \equiv \hat{A}\hat{B} - \hat{B}\hat{A}$ is also an operator of $H \to H$&lt;/li&gt;
&lt;li&gt;We are particularly interested in observables, so without further specification, we assume the operators mentioned below are Hermitian.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Uncertainty-Principle&quot;&gt;&lt;a href=&quot;#Uncertainty-Principle&quot; class=&quot;headerlink&quot; title=&quot;Uncertainty Principle&quot;&gt;&lt;/a&gt;Uncertainty Principle&lt;/h2&gt;&lt;p&gt;The most famous pair of operators might be position op $\hat{x}$ and momentum op $\hat{p} = -i\hbar\partial_x$ (1-d case), we can easily compute their commutator $[\hat{x} , \hat{p}] = i\hbar$. It’s a constant operator. The physical interpretation of this is “position and momentum of the same direction can’t be observed simultaneously”:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Position x is observed iff the wave function collapses onto an eigenstate of $\hat{x}$&lt;/li&gt;
&lt;li&gt;Suppose both quantities are measured, then there must be a shared eigenstate $\Phi_{x,p}(x)$ for the collapsed wave function to reside in. We denote its eigenvalues as $x_0, p_0$.&lt;/li&gt;
&lt;li&gt;Contradiction occurs&lt;br&gt;$$&lt;br&gt;i \hbar \Phi_{x,p} = [\hat{x}, \hat{p}] \Phi_{x,p} = x_0 p_0 \Phi_{x,p} - x_0 p_0 \Phi_{x,p} = 0&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;No such none zero wave function to hold the equation, hypotheses objected.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Mathematically, we can apply the Cauchy-Schwarz inequality to &lt;a href=&quot;https://en.wikipedia.org/wiki/Uncertainty_principle#Robertson.E2.80.93Schr.C3.B6dinger_uncertainty_relations&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;prove&lt;/a&gt; the Robertson uncertainty relation:&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;{\displaystyle \sigma_{A}\sigma_{B}\geq \left|{\frac {1}{2i}}\langle [{\hat {A}},{\hat {B}}]\rangle \right|={\frac {1}{2}}\left|\langle [{\hat {A}},{\hat {B}}]\rangle \right|}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;When it comes to the case of position and momentum, we get the very “uncertainty principle” written on high-school physics textbook.&lt;/p&gt;
&lt;h2 id=&quot;Commute-Operators&quot;&gt;&lt;a href=&quot;#Commute-Operators&quot; class=&quot;headerlink&quot; title=&quot;Commute Operators&quot;&gt;&lt;/a&gt;Commute Operators&lt;/h2&gt;&lt;p&gt;The real problem is, what happens when two operators always commute ? i.e. $[\hat{A}, \hat{B}] = 0$. By definition we can easily derive:&lt;/p&gt;
&lt;p&gt;Prop 1. $\forall \Phi_a(x) s.t. \hat{A}\Phi_a(x) = a \Phi_a(x), \hat{A}(\hat{B}\Phi_a(x)) = a \hat{B}\Phi_a(x)$, $\hat{B}$ act on any eigenstate of $\hat{A}$ yields another (might be the same) eigenstate of A, with the same eigenvalue.&lt;br&gt;Prop 2. Vice versa.&lt;br&gt;Prop 3. If a is an none-degenerate eigenvalue of $\hat{A}$, i.e. only one normalized eigenstate $\Phi_a(x)$. According to Prop 1, $\hat{B} \Phi_a(x)$ must be proportional to $\Phi_a(x)$, i.e. $\Phi_a(x)$ is also an eigenstate of $\hat{B}$.&lt;/p&gt;
&lt;p&gt;We have shown that any none-degenerate eigenstate of $\hat{A}$ is a shared eigenstate. In order to prove the assertion “commute operators have a common set of eigenstates”, by symmetry, we only need to show that “for any degenerate eigenvalue a of $\hat{A}$, there are shared eigenstates, the span of which covers all the eigenstates of a”.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Both operations are Hermitian, thus linear. All eigenstates of a forms a linear subspace (here for simplicity, consider only finite-dimensional case) $H_a$ of $H$.&lt;/li&gt;
&lt;li&gt;For any eigenstate $\Phi_b(x)$ of $\hat{B}$, project it onto both $H_a$ and its orthogonal complement $H_c$: $\Phi_b(x) = \beta_a + \beta_c$.&lt;/li&gt;
&lt;li&gt;$b\beta_a + b\beta_c = b\Phi_b(x) = \hat{B}\Phi_b(x) = \hat{B}\beta_a + \hat{B}\beta_c$, since Prop 1, $\hat{B}\beta_a$ lies in $H_a$ and $\hat{B}\beta_c$ in $H_c$ which is perpendicular to $H_a$.&lt;/li&gt;
&lt;li&gt;Hence $b\beta_a = \hat{B}\beta_a, b\beta_c = \hat{B}\beta_c$, both components are eigenstates of $\hat{B}$ with eigenvalue of b. $\beta_a$ is also a shared eigenstate since it lies in $H_a$.&lt;/li&gt;
&lt;li&gt;Consider a certain set of basis $S_B$ of $H$ constituted by eigenstates of $\hat{B}$, their $\beta_a$ components are orthogonal, and none-zero parts of them should form a complete set of basis of $H_a$. Otherwise their span won’t cover the whole space.&lt;/li&gt;
&lt;li&gt;Choose the none-zero $\beta_a$ parts, and for the rest, change the eigenstates to their $\beta_c$ components. A new set of basis with shared eigenstates across $H_a$ is formed.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So far, we have not only proved the assertion but also come up with a way to actually construct the common basis. Happy ending!&lt;/p&gt;
&lt;h2 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.eng.famu.fsu.edu/~dommelen/quantum/style_a/nt_diag.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.eng.famu.fsu.edu/~dommelen/quantum/style_a/nt_diag.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Wave_function&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wave function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Wave_function#Wave_functions_and_function_spaces&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wave function space&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;In quantum mechanics we assume the following: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Each observable is associated with an &lt;a href=&quot;https://en.wikipedia.org/wiki/Hermitian_operator&quot;&gt;Hermitian operator&lt;/a&gt; of a Hilbert space H. Its eigenvalues must be real and the eigenstates are orthogonal to each other, thus form a set of basis of H.&lt;/li&gt;
&lt;li&gt;Upon observation, one of the eigenvalues will be the quantity and the wave function will collapse onto one of the corresponding eigenstates.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here I don’t want to discuss the deep insights, which I have no idea of. That’s why I take &lt;a href=&quot;https://en.wikipedia.org/wiki/Copenhagen_interpretation&quot;&gt;Copenhagen interpretation&lt;/a&gt;, so shut up and compute!&lt;/p&gt;
&lt;p&gt;This article is written as a note of my understanding of physical and mathematical meaning of commutators, mainly the answer to the question: “why do commute operators have a common set of eigenstates ?”&lt;/p&gt;
    
    </summary>
    
    
      <category term="physics" scheme="http://farseer.cn/tags/physics/"/>
    
  </entry>
  
  <entry>
    <title>Practical Theology</title>
    <link href="http://farseer.cn/2017/04/14/Practical-Theology/"/>
    <id>http://farseer.cn/2017/04/14/Practical-Theology/</id>
    <published>2017-04-14T01:11:39.000Z</published>
    <updated>2017-04-15T03:26:51.703Z</updated>
    
    <content type="html">&lt;p&gt;Those who know me in person may already know that I’ve become religious. The foundation of my belief comes from Christianity, Calvinist branch of Protestantism, to be specific. It was a spectacular psychological journey in which I did much philosophical and sci-fi pondering, and my basic understanding of &lt;strong&gt;life, universe and everything&lt;/strong&gt; has altered a lot. Of course the faith didn’t come out from nowhere. I’ve repeatedly experienced certain kinds of revelation (facts that hard to reasoning via atheists’ perspective), as the lyric goes: “how precious did that grace appear, the hour I first believed …” &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;However, with my study of Bible and catechumens course, gradually I found the doctrines overly-sophisticated with too many justifications that are hard to testify, falsify or even sense. It makes the so-called &lt;strong&gt;truth&lt;/strong&gt; inelegant to me. Meanwhile, I paid attention to historical critical interpretation of the Bible and those literal contradictions taunted by arrogant atheists. Crises emerged in my spirit.&lt;/p&gt;
&lt;p&gt;The wikipedia entry of the word “theology” states: “theology is the &lt;strong&gt;critical&lt;/strong&gt; study of the nature of the divine.” Just like science, theology also needs critical thinking and evolution, otherwise &lt;a href=&quot;https://en.wikipedia.org/wiki/Reformation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Reformation&lt;/a&gt; wouldn’t have happened. So I think it’s okay for me to tune my understanding of religion a little bit to be compatible with modern common sense. Science and religion shall share a same basic cognitive style and together form a integral of knowledge of man kind. I call this version practical theology (the name is already &lt;a href=&quot;https://en.wikipedia.org/wiki/Practical_theology&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;taken&lt;/a&gt;, but I don’t want to waste my nerves on such difficult tasks like naming). Pious protestants might think it heretical, while my intention is primarily self-convincing. Maybe, as a side effect, it makes things more acceptable to paranoid but open-minded atheists.&lt;/p&gt;
&lt;h2 id=&quot;Agnosticism&quot;&gt;&lt;a href=&quot;#Agnosticism&quot; class=&quot;headerlink&quot; title=&quot;Agnosticism&quot;&gt;&lt;/a&gt;Agnosticism&lt;/h2&gt;&lt;p&gt;Materialists believe that the universe could be understood by human beings. If the nature is chaotic, our brains should have infinitely many neurons to accomplish the goal. Because our brains themselves are included in the universe. The whole can be covered by a part, only if both of them have infinite complexity, analogous to &lt;a href=&quot;https://en.wikipedia.org/wiki/Fractal&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fractal&lt;/a&gt;. It’s hard to believe so, as a result, I suppose that most materialists tend to believe that the essence of our world can be compressed into elegant rules - law of nature - that can be understood using limited neurons.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/agnosticism.jpg&quot; alt=&quot;complexity&quot;&gt;&lt;/p&gt;
&lt;p&gt;The trick is how to treat randomness. Modern statistics doesn’t try to explain the nature of uncertainty. On the other hand, it’s a study of the macroscopic effects of randomness. Despite of its successful applications in other research fields, building “law of nature” on uncertain blocks doesn’t mean understanding to me because too much useful information being neglected. Something more fundamental should be revealed. However, with my very limited knowledge of quantum mechanics, it seems very unlikely for human to discover the very power that makes wave functions collapse.&lt;/p&gt;
&lt;p&gt;In other words, we may peek at a corner of “law of nature”, but it’s hard or even impossible to get an entire overview of it. Karl Marx’s view of science overestimates human intelligence. Maybe we are “frogs of the well” who don’t even have the possibility to escape from our narrow space of sensation. Or, at least we should agree that beyond the boundary of our &lt;strong&gt;current&lt;/strong&gt; scientific exploration activities, there are existences of certain kinds of rules or forces that have strong causal relations with our observations. We can take them as a set and give it a name, “super-natural power” perhaps :-). Obviously, it’s a dynamic set which shrinks over time and the discrepancy comes from whether it will become empty eventually. No matter which side you pick, nothing diminishes our curiosity of it.&lt;/p&gt;
&lt;h2 id=&quot;Cognitive-Style&quot;&gt;&lt;a href=&quot;#Cognitive-Style&quot; class=&quot;headerlink&quot; title=&quot;Cognitive Style&quot;&gt;&lt;/a&gt;Cognitive Style&lt;/h2&gt;&lt;p&gt;Can not understand doesn’t mean can not guess. We can think of theology as the hypothesis of “super-natural power” while other scientific hypotheses like string theory and evolution focus on specific subsets of it. Then we can follow typical statistical methods to verify all of them in progress. So theology, as I mentioned earlier, should also be a dynamically evolving study. As our scientific understanding grows vast and more concrete, theology goes the opposite direction, more concise and abstract. (The phrasing here makes the relationship look like a dualism, but it is actually a continuous model in my mind.)&lt;/p&gt;
&lt;p&gt;Atheists around me, those educated with scientific socialism, often mingle the concepts of religion, superstition and cult. In their eyes, religious people pick authoritative ways of knowing and certainly lack the ability to suspect, which makes them easy to fool around. Actually it’s not the case, people of true faith build their faith on suspicion. They hardily make claims like “100% certain of the existence of God”. Instead, adverbs meaning uncertainty appear a lot when they express their believes, like “maybe, likely …” in this article. This illustrates that modern science and religion is congruence in their basic cognitive style, i.e. &lt;strong&gt;statistical inference and logic&lt;/strong&gt;. The procedure of spiritual formation can be viewed as a simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Statistical_hypothesis_testing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;statistical hypothesis testing&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Bayesian_inference&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bayesian inference&lt;/a&gt; process. Using our observations (physical &amp;amp; mental experiences) to update the prior belief of our theology hypothesis.&lt;/p&gt;
&lt;h2 id=&quot;Occam’s-Razor&quot;&gt;&lt;a href=&quot;#Occam’s-Razor&quot; class=&quot;headerlink&quot; title=&quot;Occam’s Razor&quot;&gt;&lt;/a&gt;Occam’s Razor&lt;/h2&gt;&lt;p&gt;Occam’s Razor is a very useful philosophical thinking principle which is widely accepted by scientists. Yet many people may not know that its originator &lt;a href=&quot;https://en.wikipedia.org/wiki/William_of_Ockham&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;William of Ockham&lt;/a&gt; was a theologian, and it was firstly brought up to deal with theological problems. Unfortunately, theologians after him didn’t carry on the good tradition which leads to the disintegration of Christianity. Nowadays only the branches of Protestantism form a massive forest.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Protestant_branches.svg&quot; alt=&quot;prot&quot;&gt;&lt;/p&gt;
&lt;p&gt;The reason is that we have made up &lt;strong&gt;too complex&lt;/strong&gt; hypotheses. Some branches go “astray” when encountered with trivial questions, the answers to which might be by-all-means unreachable to us human. Actually, the unanswerable questions themselves are often pedantic and irrelevant. For example, which method of baptism is correct, immersion, affusion or aspersion?&lt;/p&gt;
&lt;p&gt;Equipped with both science and religion though, we still have to admit that there are questions can’t be answered, especially silly questions. That is to say, we don’t need to provide completeness besides consistence to our system, and historical attempts resulted in vain.&lt;/p&gt;
&lt;p&gt;Thus within practical theology, I put those insensible doctrines aside. A more brutal way to phase it is “cut them by the razor”.&lt;/p&gt;
&lt;p&gt;Some atheists might argue that the existence of divine beings is insensible, thus could be cut out by Occam’s razor. Well, the revelations appeared to me make this very unlikely to be true. I tried to explain the divergence using the experience of my own reconstruction, and I found that the labeling processes of our observations might be highly biased by our prior assumptions. It seems to be a intrinsic flaw of our brains. An effective way to mitigate the bias is simply to intentionally modify our priors and see how the labels change under that assumption. The mathematical model of this phenomenon actually can be formalized by computer languages, such as &lt;a href=&quot;http://webppl.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WebPPL&lt;/a&gt;, but I’d like to use a more sentimental way to put it: please give religion a chance to alter your hard mind.&lt;/p&gt;
&lt;h2 id=&quot;The-Bible&quot;&gt;&lt;a href=&quot;#The-Bible&quot; class=&quot;headerlink&quot; title=&quot;The Bible&quot;&gt;&lt;/a&gt;The Bible&lt;/h2&gt;&lt;p&gt;Perhaps the most heretical part of my theology is the attitudes towards the Bible. Note that I omit the word “holy” here. The reason comes from the principles mentioned above. The claim of “xx being holy” has little prior probability in my cognition system even if the existence of God is generally accepted. It’s pretty reasonable since claims implying so much information have large amounts of &lt;a href=&quot;https://en.wikipedia.org/wiki/Self-information&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;self-information&lt;/a&gt;, indicating small probabilities. My data is simply not enough to support the claim, so I remain skeptical about the holiness of the Bible.&lt;/p&gt;
&lt;p&gt;In practical theology, The Bible is to theology as “Mathematical Principles of Natural Philosophy” is to science. The evolution of theology urges critical thinking of the literal meaning of the Bible. Just recall how Jesus criticized &lt;a href=&quot;https://en.wikipedia.org/wiki/Pharisees&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pharisees&lt;/a&gt; in the gospels. The words and information of the canon have their historical restrictions. It just saves us lots of effort to admit it and stops us from making up delicate stories.&lt;/p&gt;
&lt;p&gt;However the theology conveyed by the Bible still needs to be studied carefully, for the purpose of a more advanced theology though, which is analogous to the built of quantum mechanics and theory of relativity on top of Newtonian mechanics.&lt;/p&gt;
&lt;h2 id=&quot;Disclaimer&quot;&gt;&lt;a href=&quot;#Disclaimer&quot; class=&quot;headerlink&quot; title=&quot;Disclaimer&quot;&gt;&lt;/a&gt;Disclaimer&lt;/h2&gt;&lt;p&gt;This essay tries to avoid the mention of a single concrete creed or dogma while focuses mainly on ontology and methodology. Neither does personal testimony involve in detail. It shouldn’t be regarded as any kind of preaching content. Here I just want to share my current state of philosophical and theological thoughts, and I don’t suppose it to convince anybody. Yet it would be very nice to have someone happens to share similar understandings.&lt;/p&gt;
&lt;p&gt;Those serious Christians who regard my spiritual conditions as poor or dangerous, please help the hell out of me, amen!&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Those who know me in person may already know that I’ve become religious. The foundation of my belief comes from Christianity, Calvinist branch of Protestantism, to be specific. It was a spectacular psychological journey in which I did much philosophical and sci-fi pondering, and my basic understanding of &lt;strong&gt;life, universe and everything&lt;/strong&gt; has altered a lot. Of course the faith didn’t come out from nowhere. I’ve repeatedly experienced certain kinds of revelation (facts that hard to reasoning via atheists’ perspective), as the lyric goes: “how precious did that grace appear, the hour I first believed …” &lt;/p&gt;
    
    </summary>
    
    
      <category term="theology" scheme="http://farseer.cn/tags/theology/"/>
    
      <category term="philosophy" scheme="http://farseer.cn/tags/philosophy/"/>
    
  </entry>
  
  <entry>
    <title>Shannon–Hartley theorem</title>
    <link href="http://farseer.cn/2016/03/02/Shannon-Hartley-theorem/"/>
    <id>http://farseer.cn/2016/03/02/Shannon-Hartley-theorem/</id>
    <published>2016-03-02T07:07:47.000Z</published>
    <updated>2016-03-10T01:55:08.710Z</updated>
    
    <content type="html">&lt;p&gt;有噪信道编码定理只适用于离散的数字信道，若要将其应用于真实的物理信道还需要费一番功夫。当然其结果就是著名的香农极限。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于某个物理信道，若：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;其带宽为 $W$.&lt;/li&gt;
&lt;li&gt;其噪声为&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectral_density#Power_spectral_density&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;功率谱密度&lt;/a&gt;为 $N_0$ 的高斯&lt;a href=&quot;https://en.wikipedia.org/wiki/White_noise&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;白噪声&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;信号的平均功率为 $P$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;则该信道的容量为 $C = W\log(1+\frac{P}{N_0W})$ 比特每秒。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Convert-to-AWGN&quot;&gt;&lt;a href=&quot;#Convert-to-AWGN&quot; class=&quot;headerlink&quot; title=&quot;Convert to AWGN&quot;&gt;&lt;/a&gt;Convert to AWGN&lt;/h2&gt;&lt;p&gt;物理信道与之前的数学模型中的信道主要有两点差别，1，信源为连续时间上的函数；2，信源为模拟信号，即取值连续。这里我们先消除第1点差别，将其转换为一个离散时间，模拟信号的信道（&lt;a href=&quot;https://en.wikipedia.org/wiki/Additive_white_Gaussian_noise&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AWGN&lt;/a&gt;），即进行采样。&lt;/p&gt;
&lt;p&gt;根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist–Shannon_sampling_theorem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;采样定理&lt;/a&gt;，如果不存在噪声干扰，我们以 $2W$ 的频率对信源 $x(t)$ 进行采样，得到 $\left\{x_k\right\}$ ，信宿只需后者便能将前者完整地还原。现在我们希望在每个 $x_k$ 上叠加一个高斯噪声 $n_k \sim \mathcal{N}(0, \delta)$ 来模拟之前的高斯白噪声 $n(t)$ 所带来的干扰，在信源功率保持不变（$\int_0^T x^2(t) dt = \sum_{i=0}^{2WT} x_k^2$）的情况下，若要使前后的噪声等效，则噪声的功率也需要保持不变，即：&lt;br&gt;$$&lt;br&gt;\delta^2 = \frac{N_0 \cdot W \cdot T}{2WT} = \frac{N_0}{2}\tag{1}\label{eq1}&lt;br&gt;$$.&lt;br&gt;上述分析符合直觉，且其定量分析结果也正确，但要更严格地证明两者的等效性，不如换个方式思考。这次我们通过“离散-模拟信道”传递的是频域的采样而不再是时域的采样。由于时域与频域的对称性，有采样定理的如下推论：对于一个时长不超过 $T$ 的信号，可以在其频谱上每隔 $1/T$（或更短）的频率进行一次采样，便能完整地还原信号，对于带宽为 $W$ 的信号，其频谱区域为 $[-W, W]$，因此总采样次数为 $2WT$，与前面保持一致。&lt;/p&gt;
&lt;p&gt;换句话说，通过“离散-模拟”信道传递 $y(t) = x(t) + n(t)$ 的&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_series&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;傅里叶级数&lt;/a&gt; $\left\{x_k + n_k\right\}, k \in [0, WT)$, 其中 $n_k = \frac1T \int_0^T n(t) e^{-i\frac{2\pi kt}{T}} dt$ 为信道噪声 , $x_k$ 同理，实部加虚部共 $2WT$ 个模拟量，如果在 $n(t)$ 为高斯白噪声的情况下，$n_k$ 服从同一个高斯分布，则说明我们可以通过 AWGN 来模拟物理信道，定量分析的结果与 $\eqref{eq1}$ 相同。&lt;/p&gt;
&lt;p&gt;令 $n(\tau) \sim \mathcal{N}(0, \delta’)$, 考虑其某个傅里叶系数&lt;br&gt;$$&lt;br&gt;Re(n_k) = \frac1T \int_0^T n(t) cos(2\pi kt/T) dt = \lim\limits_{N \to \infty} \frac{1}{N} \sum\limits_{j = 0}^N n(jT/N) cos(2\pi kj/N)&lt;br&gt;$$&lt;br&gt;即 &lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete-time_Fourier_transform#Inverse_transform&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;inverse DTFT&lt;/a&gt; 是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_Fourier_transform&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DFT&lt;/a&gt; 的极限形式，若后者得到的系数服从高斯分布，则前者亦然。令&lt;br&gt;$$&lt;br&gt;z_j^k \equiv n(jT/N) cos(2\pi kj/N) \sim \mathcal{N}(0, \delta’cos(2\pi kj/N))&lt;br&gt;$$&lt;br&gt;则只需证明 $\sum_j z_j^k$ 服从某个与 $k$ 无关的高斯分布即可。为了标记方便，将 $\mathcal{N}(0, \delta)$ 的概率分布函数记作 $G_\delta$, 并将 $cos(2\pi kj/N)$ 记作 $c_{j, k}$ . 由于两个随机变量之和的分布为两个分布函数的卷积，于是&lt;br&gt;$$&lt;br&gt;P(\sum_j z_j^k = z) \propto (G_{\delta’c_{0, k}} \otimes \cdots \otimes G_{\delta’c_{N, k}})(z)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;又由于傅里叶变换满足性质 $\mathcal{F}(f \otimes g) = \mathcal{F}(f) \cdot \mathcal{F}(g)$. 且方差为 $\delta$ 高斯函数的傅里叶变换为方差 $1/\delta$ 的高斯函数&lt;a href=&quot;http://code.ucsd.edu/zeger/45/Gaussian.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;「1」&lt;/a&gt;。 于是&lt;br&gt;$$&lt;br&gt;\begin{align*}&lt;br&gt;G_{\delta’c_{0, k}} \otimes \cdots \otimes G_{\delta’c_{N, k}} &amp;amp;= \mathcal{F}^{-1}(\prod\limits_j \mathcal{F}(G_{\delta’c_{j, k}})) \\&lt;br&gt;&amp;amp;= \mathcal{F}^{-1}(\prod\limits_j G_{1/(\delta’c_{j, k})}) \propto \mathcal{F}^{-1}(G_{1/\sqrt{\sum_j (\delta’c_{j, k})^2}}) \\&lt;br&gt;&amp;amp;= G_{\sqrt{\delta’^2 \sum_j cos^2(2\pi kj/N)}} = G_{\sqrt{\delta’^2 N/2}}&lt;br&gt;\end{align*}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;即 $n(t)$ 的傅里叶级数确实服从同一个高斯分布&lt;a href=&quot;http://dsp.stackexchange.com/questions/24170/what-is-the-statistics-of-the-discrete-fourier-transform-of-white-gaussian-noise&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;「2」&lt;/a&gt;。因此，信道的等效成立。总结起来就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于上边定义的物理信道，每使用时间 $T$，等效于 $2WT$ 次使用某 AWGN，其信源的平均能量为 $P/2W$，高斯噪声服从 $\mathcal{N}(0, N_0/2)$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Channel-Capacity-of-AWGN&quot;&gt;&lt;a href=&quot;#Channel-Capacity-of-AWGN&quot; class=&quot;headerlink&quot; title=&quot;Channel Capacity of AWGN&quot;&gt;&lt;/a&gt;Channel Capacity of AWGN&lt;/h2&gt;&lt;p&gt;接下来我们希望通过计算 AWGN 的信道容量来给出香农极限。那么每次使用 AWGN 到底能够传递多少比特的信息呢？&lt;/p&gt;
&lt;h3 id=&quot;Differential-Entropy&quot;&gt;&lt;a href=&quot;#Differential-Entropy&quot; class=&quot;headerlink&quot; title=&quot;Differential Entropy&quot;&gt;&lt;/a&gt;Differential Entropy&lt;/h3&gt;&lt;p&gt;为了回答上面的问题，我们首先需要将信息熵和互信息量的定义扩展到连续的模拟量上。直观的做法就是将原来的求和改为积分，也就是说，对于服从概率分布 $P(x)$ 的连续随机变量 $X$, 定义它的信息熵为 $H(X) = - \int P(x) \log P(x)$. 这个积分可能是发散的，但当 $X$ 的方差（也就是信源的平均能量）不超过 $P$ 时，$H(X)$ 的最大值为 $\frac12 \log{(2\pi e P)}$, 当且仅当 $X \sim \mathcal{N}(\mu, \sqrt{P})$ 时取到。&lt;/p&gt;
&lt;p&gt;令 $g = G_{\sigma}$, $f$ 为任意方差不超过 $\sigma^2$ 的概率分布函数，由于平移并不改变信息熵的大小，不妨设两个分布的均值均为 0，计算两者的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Kullback–Leibler_divergence&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;K-L divergence&lt;/a&gt;, 有：&lt;br&gt;$$&lt;br&gt;\begin{align*}&lt;br&gt;0 \leq D_{KL}(f || g) &amp;amp;= \int_{-\infty}^\infty f(x) \log \left( \frac{f(x)}{g(x)} \right) dx = -H(f) - \int_{-\infty}^\infty f(x)\log(g(x)) dx \\&lt;br&gt;&amp;amp;= -H(f) - \int_{-\infty}^\infty f(x)\log\left( \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{x^2}{2\sigma^2}}\right) dx \\&lt;br&gt;&amp;amp;= -H(f) - \int_{-\infty}^\infty f(x) \log\frac{1}{\sqrt{2\pi\sigma^2}} dx - \log(e)\int_{-\infty}^\infty f(x)\left( -\frac{x^2}{2\sigma^2}\right) dx \\&lt;br&gt;&amp;amp;\leq -H(f) + \tfrac{1}{2}\log(2\pi\sigma^2) + \log(e)\frac{\sigma^2}{2\sigma^2} \\&lt;br&gt;&amp;amp;= -H(f) +\tfrac{1}{2}\left(\log(2\pi\sigma^2) + \log(e)\right) \\&lt;br&gt;&amp;amp;= -H(f) +\tfrac{1}{2}\log(2\pi e \sigma^2) = -H(f)+H(g)&lt;br&gt;\end{align*}&lt;br&gt;$$&lt;br&gt;上式中等号当且仅当 $f = g$ 时成立。&lt;/p&gt;
&lt;p&gt;像之前一样定义互信息量 $I(X; Y) = H(Y) - H(Y|X)$, 由于 $Y = X + N$, 于是&lt;br&gt;$$&lt;br&gt;I(X; Y) = H(Y) - H(X + N|X) = H(Y) - H(N) = H(Y) - \frac12 \log(\pi eN_0)&lt;br&gt;$$&lt;br&gt;当 $X$ 的平均能量不超过 $P/2W$ 时，$Y$ 的平均能量不超过 $P/2W + N_0/2$, 于是信道容量&lt;br&gt;$$&lt;br&gt;C = \frac12 \log(\pi e (P/W + N_0)) - \frac12 \log(\pi e (N_0)) = \frac12 \log(1 + \frac{P}{N_0W})&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;算上单位时间内的 AWGN 使用次数便得到了香农极限。&lt;/p&gt;
&lt;h2 id=&quot;Sphere-Packing&quot;&gt;&lt;a href=&quot;#Sphere-Packing&quot; class=&quot;headerlink&quot; title=&quot;Sphere Packing&quot;&gt;&lt;/a&gt;Sphere Packing&lt;/h2&gt;&lt;p&gt;分析到此，我们是将取值连续的随机变量看成是无穷多级的离散随机变量处理，已经足够自圆其说。然而我们可以通过如下方式更加直观地考察其正确性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;求信道容量就是求使用信道 $N \to \infty$ 次，接收端根据 $N$ 维向量最多能够准确地还原多少个不同的码字，当这个数量为 $M$ 时，$C = \log_2(M)$.&lt;/li&gt;
&lt;li&gt;对于上述 AWGN, 其码字空间为 $\mathbb{R}^N$, 在某个码字 $\mathbf{x}$ 上叠加一个 $N$ 维的高斯噪声，得到输出向量 $\mathbf{y}$, 输出的分布为以 $\mathbf{x}$ 为中心的N维高斯分布，其置信区间为一个半径为 $\sqrt{N\cdot N_0/2}$ 的球。根据上篇中提到过的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Asymptotic_equipartition_property&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AEP&lt;/a&gt;, $N$ 足够大时，$\mathbf{y}$ 几乎必然落入球中。&lt;/li&gt;
&lt;li&gt;我们希望找到尽可能多的码字，使得对应的输出的置信区间不重叠，如此一来，我们只需要寻找离 $\mathbf{y}$ 最近的码字便能正确地将其译码。&lt;/li&gt;
&lt;li&gt;由于输出的能量不超过 $N(\frac{P}{2W} + \frac{N_0}{2})$, 因此它将几乎必然落入一个半径 $\sqrt{\frac12 N(P/W+N_0)}$ 的球中。&lt;/li&gt;
&lt;li&gt;$\mathbb{R}^N$ 中半径为 $r$ 的球的体积 $\propto r^N$, 因此4中的大球至多包含 $\sqrt{1+\frac{P}{N_0W}}^N$ 个两两不交的代表置信区间的小球。&lt;/li&gt;
&lt;li&gt;$C \leq \frac12 \log(1 + \frac{P}{N_0W})$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至于如何取得等号，需要通过类似有噪信道编码定理的 &lt;strong&gt;JT&lt;/strong&gt; 性质来加以证明&lt;a href=&quot;https://en.wikipedia.org/wiki/Additive_white_Gaussian_noise#Achievability&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;「3」&lt;/a&gt;，此处略去。这样一来便得到了与之前完全一致的结论，happy ending.&lt;/p&gt;
&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://code.ucsd.edu/zeger/45/Gaussian.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fourier transform of Gaussian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dsp.stackexchange.com/questions/24170/what-is-the-statistics-of-the-discrete-fourier-transform-of-white-gaussian-noise&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dft of white Gaussian noise?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Additive_white_Gaussian_noise&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Additive white Gaussian noise - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.inference.phy.cam.ac.uk/mackay/itila/book.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;David MacKay: Information Theory, Inference, and Learning Algorithms: The Book&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;有噪信道编码定理只适用于离散的数字信道，若要将其应用于真实的物理信道还需要费一番功夫。当然其结果就是著名的香农极限。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于某个物理信道，若：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;其带宽为 $W$.&lt;/li&gt;
&lt;li&gt;其噪声为&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectral_density#Power_spectral_density&quot;&gt;功率谱密度&lt;/a&gt;为 $N_0$ 的高斯&lt;a href=&quot;https://en.wikipedia.org/wiki/White_noise&quot;&gt;白噪声&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;信号的平均功率为 $P$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;则该信道的容量为 $C = W\log(1+\frac{P}{N_0W})$ 比特每秒。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="ML" scheme="http://farseer.cn/categories/ML/"/>
    
    
      <category term="Information theory" scheme="http://farseer.cn/tags/Information-theory/"/>
    
  </entry>
  
  <entry>
    <title>The Noisy-Channel Coding Theorem</title>
    <link href="http://farseer.cn/2016/02/24/The-noisy-channel-coding-theorem/"/>
    <id>http://farseer.cn/2016/02/24/The-noisy-channel-coding-theorem/</id>
    <published>2016-02-24T12:10:38.000Z</published>
    <updated>2016-03-10T01:54:56.719Z</updated>
    
    <content type="html">&lt;p&gt;这在信息论中是一个非常重要的定理，之所以会想到回头学习信息论的相关知识，是因为这与概率推理有直接的联系，通信的本质就是根据接收到的信道输Y出来推理信道的输入X的过程。&lt;/p&gt;
&lt;h2 id=&quot;Definitions-amp-Notations&quot;&gt;&lt;a href=&quot;#Definitions-amp-Notations&quot; class=&quot;headerlink&quot; title=&quot;Definitions &amp;amp; Notations&quot;&gt;&lt;/a&gt;Definitions &amp;amp; Notations&lt;/h2&gt;&lt;p&gt;在正文开始之间先介绍一些定义和标识，顺便复习一下一些信息论中的基本结论。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 $X, Y, Z$ 来表示随机变量，$\mathcal{A}_{X}$ 表示变量的取值集合，$X^N$ 则表示将 $N$ 个独立的 $X$ 组成的整体作为一个随机变量&lt;/li&gt;
&lt;li&gt;信息熵： $H(X) = -\sum\limits_{p_i}\log{p_i}$&lt;/li&gt;
&lt;li&gt;条件信息熵： $H(X|Y) = \sum\limits_{y \in \mathcal{A}_Y} P(y) H(X|Y=y) = - \sum\limits_{xy \in \mathcal{A}_X\mathcal{A}_Y} P(x, y) \log{P(x|y)}$，满足:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$H(X, Y) = H(X) + H(Y|X) = H(Y) + H(X|Y)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互信息： $I(X; Y) \equiv H(X) - H(X|Y) = H(Y) - H(Y|X)$，度量了两个随机变量相互蕴含了多少关于对方的信息&lt;/li&gt;
&lt;li&gt;信道容量： $C \equiv \underset{\mathcal{P}_X}{\mathrm{max}}\ I(X;Y)$，表示输出变量 $Y$ 最多能够蕴含多少关于输入 $X$ 的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;关于信息熵和互信息的图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/entropy.png&quot; alt=&quot;info&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Source-Coding-Theorem&quot;&gt;&lt;a href=&quot;#Source-Coding-Theorem&quot; class=&quot;headerlink&quot; title=&quot;Source Coding Theorem&quot;&gt;&lt;/a&gt;Source Coding Theorem&lt;/h2&gt;&lt;p&gt;既然信息熵用于表示某个随机变量包含的信息量的期望值，那么想来应该有办法用 $\lceil H(X) \rceil$ 个 bits 来编码随机事件 $X$ 喽？&lt;br&gt;可是对于单个可能有 $|\mathcal{A}_X|$ 个取值的随机变量，我们至少需要 $\lceil \log_2{\mathcal{A}_X} \rceil$ 个比特来对其所有可能的取值进行编码，才能保证不丢失信息。&lt;br&gt;考虑 $X^N$，同样，若要做到完全不丢失信息，至少需要 $\lceil N\log_2{\mathcal{A}_X} \rceil$ 个比特，但是当 $N$ 足够大时，$X^N$ 的一大部分可能的取值对应了非常小的概率，以至于我们只需要牺牲非常小的信息就能够将这些低概率的取值从我们的编码中排除出去，从而将这个信源压缩到将近 $NH(X)$ 比特。因此，信息熵也表示了对应的压缩极限。&lt;br&gt;回过头来给出信源编码定理的文字描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;N 个 i.i.d. 的随机变量（每个随机变量的信息熵为 H(X)），在 N 足够大时可以被几乎无损地压缩到 NH(X) 个比特；相反地，如果少于上述值，则信息几乎一定会有丢失。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;显然上面的叙述十分地非正式，至于严格的数学定义和证明，由于过于迂腐，就此略去，请参见文末给出的参考书的第四章。但是下面将要提到并证明一个重要的结论，该结论将能够非正式地导出信源编码定理的前半部分，并且能够给出一个具体的编码方案。&lt;/p&gt;
&lt;h3 id=&quot;‘Asymptotic-equipartition’-principle&quot;&gt;&lt;a href=&quot;#‘Asymptotic-equipartition’-principle&quot; class=&quot;headerlink&quot; title=&quot;‘Asymptotic equipartition’ principle&quot;&gt;&lt;/a&gt;‘Asymptotic equipartition’ principle&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对于 $X^N$ 来说，当 $N$ 足够大时，其具体取值 $\mathbf{x} = (x_1, x_2, …, x_N)$ 几乎必然落在 $\mathcal{A}_X^N$ 的一个大小为 $2^{NH(X)}$ 的子集 $T$ 中，并且取其中的任意元素的概率”接近” $2^{-NH(X)}$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;显然如果上述性质成立，则只需对 $T$ 中的元素进行编码，也就意味着压缩极限是可以被无限趋近的。为了证明上面的描述，我们需要给出寻找这样的集合 $T$ 的具体方法，这涉及到一个 &lt;strong&gt;typical set&lt;/strong&gt; 的概念，定义如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;T_{N\beta} \equiv \left\{\mathbf{x} \in \mathcal{A}_X: |\frac1N \log_2{\frac{1}{P(\mathbf{x})}} - H| &amp;lt; \beta\right\}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;也就是找那些信息量最接近信息熵的取值，注意这些取值并不是可能性最高的那部分。为了证明 $T_{N\beta}$ 满足需求，我们通过&lt;a href=&quot;https://en.wikipedia.org/wiki/Chebyshev%27s_inequality#Probabilistic_statement&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;切比雪夫不等式&lt;/a&gt;得到：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;P(\mathbf{x} \in T_{N\beta}) \geq 1 - \frac{Var[\log_2(1/P(X))]}{\beta^2N}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;显然当 $N \to \infty$ 时，$\mathbf{x}$ 几乎必然落入 $T_{N\beta}$ 中。而 $2^{-N(H + \beta)} &amp;lt; P(\mathbf{x}) &amp;lt; 2^{-N(H - \beta)}$，取相对于 $H$ 足够小的 $\beta$，则集合中的各元素的概率“相对近似”。&lt;/p&gt;
&lt;h2 id=&quot;The-Theorem&quot;&gt;&lt;a href=&quot;#The-Theorem&quot; class=&quot;headerlink&quot; title=&quot;The Theorem&quot;&gt;&lt;/a&gt;The Theorem&lt;/h2&gt;&lt;h3 id=&quot;Part-1&quot;&gt;&lt;a href=&quot;#Part-1&quot; class=&quot;headerlink&quot; title=&quot;Part 1&quot;&gt;&lt;/a&gt;Part 1&lt;/h3&gt;&lt;p&gt;有噪信道编码理论描述了对于有噪声无记忆的信道而言，在正确传递信息（不正确的情况稍后讨论）的前提下，平均每次使用信道所能传输的最大信息量。显然，根据信道容量的定义，这个量不会超过 $C$。而这个定理正是说明，这个极限是可以被无限趋近的。&lt;/p&gt;
&lt;p&gt;这个定理也可以这么理解，信道噪声导致每次传输只能获取信源的部分信息量，然而我们可以通过适当的冗余手段（LDPC, turbo code, etc.）使得平均下来，信道传递的有效信息的部分正好是我们希望传递的内容，从而保证正确性，而 $C$ 决定了冗余成分所占比重的下限。&lt;/p&gt;
&lt;h4 id=&quot;Jointly-typical-sequences&quot;&gt;&lt;a href=&quot;#Jointly-typical-sequences&quot; class=&quot;headerlink&quot; title=&quot;Jointly-typical sequences&quot;&gt;&lt;/a&gt;Jointly-typical sequences&lt;/h4&gt;&lt;p&gt;为了寻找合适的编解码方案 $\mathcal{C}$，类似信源编码定理中的 &lt;strong&gt;typical set&lt;/strong&gt;，需要定义 &lt;strong&gt;jointly-typical&lt;/strong&gt; 的概念（后文简称 &lt;strong&gt;JT&lt;/strong&gt;）。如果一对长度为 $N$ 的序列 $\mathbf{x}, \mathbf{y}$ 满足如下属性，就说他们是 &lt;strong&gt;JT&lt;/strong&gt; 的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\mathbf{x}$ 相对 $P(X)$ 是 typical 的，i.e., $|\frac1N\log{1/P(\mathbf{x})} - H(X)| &amp;lt; \beta$, 下同；&lt;/li&gt;
&lt;li&gt;$\mathbf{y}$ 相对 $P(Y)$ 是 typical 的；&lt;/li&gt;
&lt;li&gt;$\mathbf{x, y}$ 相对 $P(X, Y)$ 是 typical 的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类似于 &lt;strong&gt;‘asymptotic equipartition’ principle&lt;/strong&gt;, 有如下的 &lt;strong&gt;JT theorem&lt;/strong&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于从 $(XY)^N$ 的联合概率分布，即 $P(\mathbf{x}, \mathbf{y}) = \prod\limits_{n=1}^N P(x_n, y_n)$ 中随机抽取的序列对 $\mathbf{x}, \mathbf{y}$ 有如下性质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它们是 &lt;strong&gt;JT&lt;/strong&gt; 的概率在 $N \to \infty$ 时趋向于1.&lt;/li&gt;
&lt;li&gt;所有 &lt;strong&gt;JT&lt;/strong&gt; 的序列对的个数在 $N$ 足够大时，约为 $2^{NH(X,Y)}$.&lt;/li&gt;
&lt;li&gt;如果是分别从 $X^N, Y^N$ 的边缘分布中独立地抽取，则它们满足 &lt;strong&gt;JT&lt;/strong&gt; 的概率约为 $2^{-NI(X;Y)}$ ($N \to \infty$).&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;同上边一样，为了不混淆直觉，此处采用了并不严格的描述。前两条性质类似于 &lt;strong&gt;‘asymptotic equipartition’ principle&lt;/strong&gt;，直接利用切比雪夫不等式就能得到，性质3的证明则可以通过先前的结论导出：独立抽取的 $\mathbf{x}$ 几乎必定落入大小为 $2^{NH(X)}$ 的取值集合中，且分布“近似均匀”，$\mathbf{y}$ 同理，于是独立抽取的序列对几乎必定落入大小为 $2^{N(H(X) + H(Y))}$ 的集合中，且分布“近似均匀”；而根据性质2，它们满足 &lt;strong&gt;JT&lt;/strong&gt; 的概率约为 $2^{NH(X, Y)}/2^{N(H(X) + H(Y))} = 2^{-NI(X;Y)}$.&lt;/p&gt;
&lt;h4 id=&quot;Encoding-decoding-system&quot;&gt;&lt;a href=&quot;#Encoding-decoding-system&quot; class=&quot;headerlink&quot; title=&quot;Encoding-decoding system&quot;&gt;&lt;/a&gt;Encoding-decoding system&lt;/h4&gt;&lt;p&gt;首先确定单个信道输入的概率分布 $P(X)$，考虑如下一类编解码方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 $\mathcal{A}_X^N$ 中依概率 $P(\mathbf{x} = \prod\limits_{n=1}^NP(x_n))$ 选取 $S = 2^{NR}$ 个作为码字集合。&lt;/li&gt;
&lt;li&gt;通信双方对所选择的码字达成共识。&lt;/li&gt;
&lt;li&gt;从 1 到 $S$ 中随机选择一个作为消息 $s$, 找到其对应的码字，记作 $\mathbf{x}^{(s)}$，将这个序列依次通过信道，则接收到的序列的分布为 $P(\mathbf{y}|\mathbf{x^{(s)}}) = \prod\limits_{n=1}^N P(y_n|x_n^{(s)})$.&lt;/li&gt;
&lt;li&gt;接收方将接收到的序列 $\mathbf{y}$ 解码为 $\hat{s}$ 当且仅当 $\mathbf{x}^{(s)}$ 是所有码字中唯一能与 $\mathbf{y}$ 组成 &lt;strong&gt;JT&lt;/strong&gt; 序列对的一个。否则提示译码错误。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果步骤4能够保证译码正确，则平均 $N$ 次使用信道便能传输 $NR$ 比特的信息（各码字被等概率选取，单个消息的信息熵），于是所谓的 &lt;strong&gt;Rate&lt;/strong&gt; 为 $R$ bits per channel usage. 我们希望 $R$ 可以尽可能地接近 $C$，为此，我们考察译码错误率与$R$ 之间的关系。&lt;/p&gt;
&lt;p&gt;对于一个特定的编码方案 $\mathcal{C}$, 定义其步骤4发生译码错误的概率为 $p(\mathcal{C}) \equiv P(\hat{s} \neq s|\mathcal{C})$，这个量涉及到具体的编码方案，并不容易处理。因此我们考察这个量在所有上述编码方案下的平均值:&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\langle p \rangle \equiv \sum\limits_{\mathcal{C}} P(\hat{s} \neq s | \mathcal{C})P(\mathcal{C})&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;由于步骤1中各个编码的选择具有轮换对称性，因此在考虑求和后，$s$ 的取值并不影响上式的值。不妨设 $s = 1$.&lt;br&gt;也就是说，我们依概率分布 $P(X^N)$ 选择码字 $P(\mathbf{x}^{(1)})$, 随后将序列 $\mathbf{x}^{(1)}$ 输入信道，依照分布 $P(Y^N|X^N)$ 随机得到一个输出序列 $\mathbf{y}$，显然 $(\mathbf{x}^{(1)}, \mathbf{y})$ 服从分布 $P(X^N, Y^N)$，根据 &lt;strong&gt;JT theorem&lt;/strong&gt; 的性质1，它们几乎必然是 &lt;strong&gt;JT&lt;/strong&gt; 的。于是若要使得步骤4出错，只剩一种可能：剩下的 $S - 1$ 个码字中还至少有一个与 $\mathbf{y}$ &lt;strong&gt;JT&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;从上面的分析可以得到，$\mathbf{y}$ 服从边缘分布 $P(Y^N)$ 根据 &lt;strong&gt;JT theorem&lt;/strong&gt; 的性质3，剩下的某个码字与 $\mathbf{y}$ &lt;strong&gt;JT&lt;/strong&gt; 的概率不超过 $2^{-N(I(X;Y)-\delta)}$，其中 $\delta$ 为一个微小量，用于对应“约”。由于 $1-(1-p)(1-q) \leq p + q$，于是“至少有一个…”的概率:&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;p’ \leq (2^{NR}-1) \cdot 2^{-N(I(X;Y) - \delta)} \leq 2^{-N(I(X;Y) - R - \delta)}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;于是只要 $R &amp;lt; I(X;Y) - \delta$，$p’$ 就可以趋向无穷小，i.e. 平均解码错误率 $\langle p \rangle \to 0$，根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Pigeonhole_principle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;鸽巢原理&lt;/a&gt;，必有一种编码 $\mathcal{C}$ 使得 $p(\mathcal{C})$ 足够小，亦即 $R$ bits per channel usage 的 &lt;strong&gt;Rate&lt;/strong&gt; 是可达的。取 $P(X) = \underset{P(X)}{argmax}\ I(X;Y)$，则 $R$ 可以趋近 $C$. $\Box$&lt;/p&gt;
&lt;p&gt;其实这样的译码手段类似极大似然推理，直观上看我们需要寻找一种编码方案使得不同的码字对应的信道输出的分布尽可能地分离，当这些输出的分布几乎没有重叠时，我们便能准确地进行概率推理，还原出消息了。而 &lt;strong&gt;JT&lt;/strong&gt; 这样的性质给出了很重要的量化方案，帮助完成了定理的证明。&lt;/p&gt;
&lt;p&gt;除此之外，参考书中还通过扔掉一半重叠较多的码字的办法给出了控制“最大译码错误”的办法。&lt;/p&gt;
&lt;h3 id=&quot;Part2&quot;&gt;&lt;a href=&quot;#Part2&quot; class=&quot;headerlink&quot; title=&quot;Part2&quot;&gt;&lt;/a&gt;Part2&lt;/h3&gt;&lt;p&gt;在上面结论的基础上，如果我们允许一定的比特错误率 $p_b$，即译码后的信息 $\hat{s}$ 的某个比特位与真实信息 $s$ 的对应比特位不一致的概率，则 &lt;strong&gt;Rate&lt;/strong&gt; 的上限可达 $R(p_b) = \frac{C}{1 - H(p_b)}$.&lt;/p&gt;
&lt;p&gt;显然这里的 R 就不能理解为“平均单次信道使用传递的信息量”了，因为后者永远不会超过信道容量，这里只能理解为“平均单次信道使用所编码的消息的信息量”。由于允许错误存在，这个量显然可以超过之前的极限，因为最简单的办法就是只将信源的一部分比特进行正确的传递，然后接收方随机地猜剩下的比特。&lt;/p&gt;
&lt;p&gt;问题是我们能否做到更好？显然“随机猜”太盲目了，因为被正确传递的部分可以带有关于剩余分布的信息，将这部分信息最大化的手段其实跟冗余的思想类似。当校验码包含更多关于信源的信息时，信源反过来也包含了更多关于校验码的信息。下面给出具体的做法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;考虑一个概率为 $p_b$ 的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_symmetric_channel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BSC&lt;/a&gt;，这个信道的容量为 $1 - H(p_b)$.&lt;/li&gt;
&lt;li&gt;根据 Part1 的结论，我们可以将 $N(1 - H(p_b))$ 比特的消息编码入 $N$ 比特的信源，从而保证消息在通过这个 BSC 后能被正确还原&lt;/li&gt;
&lt;li&gt;将2中的解码器和编码器反过来，我们用解码器将 $N$ 比特消息压缩成 $N(1 - H(p_b))$ 比特，让压缩后的信源采用 Part1 描述的理想方案通过容量为 $C$ 的信道，然后被正确还原的信息再通过2中的编码器将其扩回 $N$ 比特。则这整个通信过程的输入输出序列均为 $N$ 比特，且恰好就是2中 BSC 两端的序列，它们的比特错误率恰为 $p_b$.&lt;/li&gt;
&lt;li&gt;考虑到3中的压缩率以及信道每次使用能够传递至多 $C$ 比特, 则“平均单次信道使用所编码的消息量”可以达到 $R(p_b)$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果消息 $s$ 在通过信道后被还原为 $\hat{s}$，两者的比特错误率不超过 $p_b$，则当 $s$ 中 0, 1 等概率出现时，$s, \hat{s}$ 对应比特的互信息量为 $1 - H(p_b)$，于是 $R(p_b)$ 就成了 &lt;strong&gt;Rate&lt;/strong&gt; 的上限。而当 $s$ 中 0, 1 非等概率时，信道容量不能够被有效利用，Part1 中的理想值无法达到, &lt;strong&gt;Rate&lt;/strong&gt; 将会更低。$\Box$&lt;/p&gt;
&lt;h2 id=&quot;Conclude&quot;&gt;&lt;a href=&quot;#Conclude&quot; class=&quot;headerlink&quot; title=&quot;Conclude&quot;&gt;&lt;/a&gt;Conclude&lt;/h2&gt;&lt;p&gt;学通信的都知道大名鼎鼎的香农三大定理，信源编码是其一，有噪信道以及&lt;a href=&quot;https://en.wikipedia.org/wiki/Shannon–Hartley_theorem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;香农极限&lt;/a&gt;是其二，还有就是&lt;a href=&quot;https://en.wikipedia.org/wiki/Rate–distortion_theory&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;数据率失真理论&lt;/a&gt;。这些成果以及背后的信息论体系不仅在通信领域具有重要的理论指导意义，同时也辐射到了如数据压缩，概率推理，机器学习等领域。&lt;/p&gt;
&lt;h2 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Claude_Shannon&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Claude Shannon - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shannon%27s_source_coding_theorem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Shannon’s source coding theorem - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Noisy-channel_coding_theorem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Noisy-channel coding theorem - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Rate%E2%80%93distortion_theory&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Rate–distortion theory - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.inference.phy.cam.ac.uk/mackay/itila/book.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;David MacKay: Information Theory, Inference, and Learning Algorithms: The Book&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这在信息论中是一个非常重要的定理，之所以会想到回头学习信息论的相关知识，是因为这与概率推理有直接的联系，通信的本质就是根据接收到的信道输Y出来推理信道的输入X的过程。&lt;/p&gt;
&lt;h2 id=&quot;Definitions-amp-Notations&quot;&gt;&lt;a href=&quot;#Definitions-amp-Notations&quot; class=&quot;headerlink&quot; title=&quot;Definitions &amp;amp; Notations&quot;&gt;&lt;/a&gt;Definitions &amp;amp; Notations&lt;/h2&gt;&lt;p&gt;在正文开始之间先介绍一些定义和标识，顺便复习一下一些信息论中的基本结论。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 $X, Y, Z$ 来表示随机变量，$\mathcal{A}_{X}$ 表示变量的取值集合，$X^N$ 则表示将 $N$ 个独立的 $X$ 组成的整体作为一个随机变量&lt;/li&gt;
&lt;li&gt;信息熵： $H(X) = -\sum\limits_{p_i}\log{p_i}$&lt;/li&gt;
&lt;li&gt;条件信息熵： $H(X|Y) = \sum\limits_{y \in \mathcal{A}_Y} P(y) H(X|Y=y) = - \sum\limits_{xy \in \mathcal{A}_X\mathcal{A}_Y} P(x, y) \log{P(x|y)}$，满足:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$H(X, Y) = H(X) + H(Y|X) = H(Y) + H(X|Y)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互信息： $I(X; Y) \equiv H(X) - H(X|Y) = H(Y) - H(Y|X)$，度量了两个随机变量相互蕴含了多少关于对方的信息&lt;/li&gt;
&lt;li&gt;信道容量： $C \equiv \underset{\mathcal{P}_X}{\mathrm{max}}\ I(X;Y)$，表示输出变量 $Y$ 最多能够蕴含多少关于输入 $X$ 的信息&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ML" scheme="http://farseer.cn/categories/ML/"/>
    
    
      <category term="Information theory" scheme="http://farseer.cn/tags/Information-theory/"/>
    
  </entry>
  
  <entry>
    <title>Fisher information and CRLB</title>
    <link href="http://farseer.cn/2015/10/10/fisher-information-and-crlb/"/>
    <id>http://farseer.cn/2015/10/10/fisher-information-and-crlb/</id>
    <published>2015-10-09T16:00:00.000Z</published>
    <updated>2016-03-10T01:51:39.790Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Fisher-Information&quot;&gt;&lt;a href=&quot;#Fisher-Information&quot; class=&quot;headerlink&quot; title=&quot;Fisher Information&quot;&gt;&lt;/a&gt;Fisher Information&lt;/h2&gt;&lt;p&gt;又来抄录 Wikipedia 了，Fisher information 这个词我在好多地方见过，一直是不求甚解地意会着，最近发现这影响到一些东西的理解，于是开始翻看百科。&lt;/p&gt;
&lt;p&gt;言归正传，Fisher information 对于学统计的人应该很熟悉，用于描述可观测的变量 X 包含的对于决定它分布的参数 $\theta$ 的信息大小，直观地理解，如果 X 包含的关于 $\theta$ 的信息越多，后者就越确定，也就是其估计的方差越小。了解到这个信息就能得知，对于某些特定的分布模型，我们对于参数 $\theta$ 的极大似然估计 $\hat{\theta}_{ML}$ 的确信程度。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;更加精确地：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X 是一个可观测的随机变量&lt;/li&gt;
&lt;li&gt;X 的分布由未知参数 $\theta$ 决定&lt;/li&gt;
&lt;li&gt;似然函数（likelihood function） 表示为 $f(x; \theta) = P(x | \theta)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Fisher information 的定义如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\mathcal{I}(\theta)=\operatorname{E} \left[\left. \left(\frac{\partial}{\partial\theta} \log f(X;\theta)\right) ^2\right|\theta \right] = \int \left(\frac{\partial}{\partial\theta} \log f(x;\theta)\right) ^2 f(x; \theta)\; \mathrm{d}x \\&lt;br&gt;= - \operatorname{E} \left[\left. \frac{\partial ^2}{\partial\theta ^2} \log f(X;\theta)\right|\theta \right] \tag{1}\label{eq1}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;后一个等号成立是因为：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\frac{\partial ^2}{\partial\theta ^2} \log f(X;\theta)=&lt;br&gt;\frac{\frac{\partial ^2}{\partial\theta ^2} f(X;\theta)}{f(X; \theta)}&lt;br&gt;\;-\;&lt;br&gt;\left( \frac{\frac{\partial}{\partial\theta} f(X;\theta)}{f(X; \theta)} \right) ^2=&lt;br&gt;\frac{\frac{\partial ^2}{\partial\theta ^2} f(X;\theta)}{f(X; \theta)}&lt;br&gt;\;-\;&lt;br&gt;\left( \frac{\partial}{\partial\theta} \log f(X;\theta)\right) ^2&lt;br&gt;\\&lt;br&gt;\operatorname{E} \left[\left. \frac{\frac{\partial ^2}{\partial\theta ^2} f(X;\theta)}{f(X; \theta)}\right|\theta \right]=\int \frac{\frac{\partial ^2}{\partial\theta ^2} f(x;\theta)}{f(x;\theta)}f(x;\theta)\; \mathrm{d}x=&lt;br&gt;\frac{\partial ^2}{\partial\theta ^2} \int f(x; \theta)\; \mathrm{d}x=&lt;br&gt;\frac{\partial ^2}{\partial\theta ^2} \; 1 = 0.&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X 表示随机变量，而 x 表示该变量的特定取值&lt;/li&gt;
&lt;li&gt;取期望值的时候 $\theta$ 保持不变，表示其真实值&lt;/li&gt;
&lt;li&gt;似然函数表示对应的条件概率密度，故 $\int f(x;\theta)\;\mathrm{d}x = 1$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;The-Intuition&quot;&gt;&lt;a href=&quot;#The-Intuition&quot; class=&quot;headerlink&quot; title=&quot;The Intuition&quot;&gt;&lt;/a&gt;The Intuition&lt;/h3&gt;&lt;p&gt;首先来看为什么上边定义的 information 能够表示上边提到的 “X 包含的对于决定它分布的参数 $\theta$ 的信息大小”。&lt;/p&gt;
&lt;p&gt;我们知道后验概率 $P(\theta|x) \propto P(x|\theta) P(\theta)$，当先验分布为均匀分布时（即没有任何对参数的先验知识），$P(\theta|x) \propto f(x;\theta)$&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/fisher.gif&quot; alt=&quot;Fisher&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图中，对于两组特定的样本，其后验概率密度函数的形状与图中的曲线相同，较为陡峭的蓝线在其极大似然的参数 $\hat{\theta}_{ML}$ 附近的变化剧烈，对应了参数较为确定，也就是“X 包含了更多关于参数的信息”。而 Fisher information 恰好能够描述这种陡峭程度，由于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;考虑足够多样本的情形，由于 MLE 是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Consistent_estimator&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;consistent estimator&lt;/a&gt;, $\hat{\theta}_{ML} \to \theta$&lt;/li&gt;
&lt;li&gt;假设 log likelihood 二阶导数的期望近似于 log likelihood 的期望的二阶导数，而后者为一个以 $\theta$ 为极值的函数的二阶导数（在 $\theta$ 处）。&lt;/li&gt;
&lt;li&gt;Fisher information 近似描述了后验概率的 log 期望在 MLE 处的二阶导数的大小，即陡峭程度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Properties-of-MLE&quot;&gt;&lt;a href=&quot;#Properties-of-MLE&quot; class=&quot;headerlink&quot; title=&quot;Properties of MLE&quot;&gt;&lt;/a&gt;Properties of MLE&lt;/h2&gt;&lt;p&gt;顺便提一下有关 MLE (Maximum Likelihood Estimator) 的两个重要属性，这也与 Fisher information 密切相关。&lt;/p&gt;
&lt;h3 id=&quot;Consistency&quot;&gt;&lt;a href=&quot;#Consistency&quot; class=&quot;headerlink&quot; title=&quot;Consistency&quot;&gt;&lt;/a&gt;Consistency&lt;/h3&gt;&lt;p&gt;说的是，当样本足够多时，MLE 趋近于真实参数值，简单证明如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与前文标记略有不同，此处令真实的参数值为 $\theta_0$, 且定义&lt;br&gt;$$&lt;br&gt;L(\theta) = E_{\theta_0} l(X|\theta) = \operatorname{E} \left[\left. log\ f(X;\theta)\right|\theta_0 \right] = \int (log f(x; \theta)) f(x; \theta_0) \mathrm{d}x&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;根据 MLE 的定义&lt;br&gt;$$&lt;br&gt;\hat{\theta}_{ML} = \underset{\theta}{\operatorname{argmax}} L_n(\theta) = \underset{\theta}{\operatorname{argmax}} \frac1n \sum\limits_{i=1} ^n log\ f(x_i; \theta)&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Law_of_large_numbers&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大数定理&lt;/a&gt;，有 $L_n(\theta) \to L(\theta)$&lt;/li&gt;
&lt;li&gt;根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;K-L divergence&lt;/a&gt;，有 $\underset{\theta}{\operatorname{argmax}} L(\theta) = \theta_0$&lt;/li&gt;
&lt;li&gt;根据 2，3，4 可得 $\hat{\theta}_{ML} \to \theta_0$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Asymptotic-normality&quot;&gt;&lt;a href=&quot;#Asymptotic-normality&quot; class=&quot;headerlink&quot; title=&quot;Asymptotic normality&quot;&gt;&lt;/a&gt;Asymptotic normality&lt;/h3&gt;&lt;p&gt;$\sqrt{n}(\hat{\theta}_{ML} - \theta_0) \to ^d N(0, 1/\mathcal{I}(\theta_0))$，在 consistency 的基础上，表明了 MLE 服从高斯分布，其方差为 Fisher information 的倒数。简单证明如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据上边的1得到 $L’_n(\hat{\theta}_{ML}) = 0$，同理有 $L’(\theta_0) = E_{\theta_0} l’(X|\theta_0) = 0$&lt;/li&gt;
&lt;li&gt;不妨设 $\theta_0 \leq \hat{\theta}_{ML}$, 根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean_value_theorem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;微分中值定理&lt;/a&gt;&lt;br&gt;$$&lt;br&gt;\exists \theta_1 \in [\theta, \theta_0], 0 = L’_n(\hat{\theta}_{ML}) = L’_n(\theta_0) + L’’(\theta_1)(\hat{\theta}_{ML} - \theta_0)&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;于是&lt;br&gt;$$&lt;br&gt;\sqrt{n}(\hat{\theta}_{ML} - \theta_0) = - \frac{\sqrt{n}L’_n(\theta_0)}{L’’_n(\theta_1)}&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_limit_theorem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中心极限定理&lt;/a&gt;&lt;br&gt;$$&lt;br&gt;\sqrt{n}L’_n(\theta_0) = \sqrt{n}(\frac1n \sum\limits_{i=1} ^ n f’(x_i; \theta_0) - 0) = \sqrt{n}(\frac1n \sum\limits_{i=1} ^ n f’(x_i; \theta_0) - E_{\theta_0}l’(X|\theta_0)) \to N(0, var_{\theta_0}(l’(X|\theta_0)))&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;根据大数定理（LLN）&lt;br&gt;$$&lt;br&gt;L’’_n(\theta) = \frac1n \sum l’’(X_i|\theta) \to E_{\theta_0}l’’(X|\theta)&lt;br&gt;$$&lt;br&gt;又 $\hat{\theta}_{ML} \to \theta_0, \theta_1 \to \theta_0$，于是&lt;br&gt;$$&lt;br&gt;l’’_n(\theta_1) \to E_{\theta_0}l’’(X|\theta_0) = -\mathcal{I}(\theta_0)&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;根据 4，5 可得&lt;br&gt;$$-\frac{\sqrt{n}L’_n(\theta_0)}{L’’_n(\theta_1)} \to ^d N(0, \frac{var_{\theta_0}(l’(X|\theta_0))}{\mathcal{I}(\theta_0) ^2})&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;又根据 1 以及 $\eqref{eq1}$&lt;br&gt;$$&lt;br&gt;var_{\theta_0}(l’(X|\theta_0)) = E_{\theta_0}(l’(X|\theta_0)) ^2 - (E_{\theta_0}l’(X|\theta_0)) ^2 = \mathcal{I}(\theta_0) - 0&lt;br&gt;$$&lt;br&gt;再根据 3，6 即得结论&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Overview-of-the-Proofs&quot;&gt;&lt;a href=&quot;#Overview-of-the-Proofs&quot; class=&quot;headerlink&quot; title=&quot;Overview of the Proofs&quot;&gt;&lt;/a&gt;Overview of the Proofs&lt;/h3&gt;&lt;p&gt;用一张图表示各个重要结论之间的导出关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/theorems-ov.png&quot; alt=&quot;ov&quot;&gt;&lt;/p&gt;
&lt;p&gt;至于具体的证明细节，就不长篇抄袭了……&lt;/p&gt;
&lt;h2 id=&quot;Cramer–Rao-Lower-Bound&quot;&gt;&lt;a href=&quot;#Cramer–Rao-Lower-Bound&quot; class=&quot;headerlink&quot; title=&quot;Cramér–Rao Lower Bound&quot;&gt;&lt;/a&gt;Cramér–Rao Lower Bound&lt;/h2&gt;&lt;p&gt;另一个关于 Fisher information 的重要结论就是 Cramér–Rao inequality:&lt;br&gt;对于任意的关于 $\theta$ 的无偏估计 $\hat{\theta}$，必然有 $var(\hat{\theta}) \geq 1/\mathcal{I(\theta)}$.&lt;/p&gt;
&lt;p&gt;更一般地，若有偏估计 T 满足 $E(T) = \psi(\theta)$，则 $var(T) \geq \frac{\psi’(\theta) ^2} {\mathcal{I(\theta)}}$.&lt;/p&gt;
&lt;h3 id=&quot;Proof&quot;&gt;&lt;a href=&quot;#Proof&quot; class=&quot;headerlink&quot; title=&quot;Proof&quot;&gt;&lt;/a&gt;Proof&lt;/h3&gt;&lt;p&gt;对上面的一般结论进行简短的证明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;令&lt;br&gt;$$&lt;br&gt;V = l’(\theta) = \frac{\partial}{\partial\theta} log f(X;\theta) = \frac{f’(X;\theta)}{f(X;\theta)}&lt;br&gt;$$&lt;br&gt;有&lt;br&gt;$$&lt;br&gt;E(V) = \int_x f(x;\theta)[\frac{1}{f(x;\theta)}\frac{\partial}{\partial\theta}f(x;\theta)] \mathrm{d}x = \frac{\partial}{\partial\theta} \int_x f(x;\theta)\mathrm{d}x = 0&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;根据 1&lt;br&gt;$$cov(V, T) = E(VT - E(V)T - E(T)V + E(V)E(T)) = E(VT) - E(T)E(V) = E(VT)&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;$$&lt;br&gt;cov(V, T) = E(VT) = \int_x t(x)[\frac{\partial}{\partial\theta}f(x;\theta)] \mathrm{d}x = \frac{\partial}{\partial\theta}[\int_x t(x)f(x;\theta)\mathrm{d}x] = \psi’(\theta)&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Cauchy%E2%80%93Schwarz_inequality&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;柯西-洗袜子不等式&lt;/a&gt;&lt;br&gt;$$&lt;br&gt;var(T)var(V) \geq cov(V, T) ^2 = \psi’(\theta) ^2&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;根据定义 $\eqref{eq1}$，$var(V) = \mathcal{I}(\theta)$，带入 4 即得结论&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Multivariate-Extention&quot;&gt;&lt;a href=&quot;#Multivariate-Extention&quot; class=&quot;headerlink&quot; title=&quot;Multivariate Extention&quot;&gt;&lt;/a&gt;Multivariate Extention&lt;/h3&gt;&lt;p&gt;论文中出现较多的情况是多参数的 CRLB, 定义如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参数： $\boldsymbol{\theta} = \left[ \theta_1, \theta_2, \dots, \theta_d \right] ^T \in \mathbb{R} ^d$&lt;/li&gt;
&lt;li&gt;Fisher information matrix 是一个 d x d 的矩阵，元素&lt;br&gt;$$&lt;br&gt;I_{m, k}&lt;br&gt;= \mathrm{E} \left[&lt;br&gt;\frac{\partial }{\partial \theta_m} \log f\left(x; \boldsymbol{\theta}\right)&lt;br&gt;\frac{\partial }{\partial \theta_k} \log f\left(x; \boldsymbol{\theta}\right)&lt;br&gt;\right] = -\mathrm{E} \left[&lt;br&gt;\frac{\partial  ^2}{\partial \theta_m \partial \theta_k} \log f\left(x; \boldsymbol{\theta}\right)&lt;br&gt;\right].&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;偏估计 $\boldsymbol{T}(X) = (T_1(X), \ldots, T_d(X)) ^T$ 满足 $\mathrm{E}(\boldsymbol{T}(X)) = \boldsymbol{\psi}(\boldsymbol{\theta})$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有结论如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\mathrm{cov}_{\boldsymbol{\theta}}\left(\boldsymbol{T}(X)\right) \geq&lt;br&gt;\frac {\partial \boldsymbol{\psi} \left(\boldsymbol{\theta}\right)}&lt;br&gt;{\partial \boldsymbol{\theta}} [I\left(\boldsymbol{\theta}\right)] ^{-1}&lt;br&gt;\left( \frac {\partial \boldsymbol{\psi}\left(\boldsymbol{\theta}\right)}&lt;br&gt;{\partial \boldsymbol{\theta}}&lt;br&gt;\right) ^T&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;证明略过，抄数学公式也是累…&lt;/p&gt;
&lt;p&gt;综合 CRLB 以及 MLE 的 Asymptotic Normality 性质，可知当样本足够时，MLE 趋向于最优估计（无偏，且方差最小）。&lt;/p&gt;
&lt;h2 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fisher_information&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fisher information&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cram%C3%A9r%E2%80%93Rao_bound#General_scalar_case&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cramér–Rao bound&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ocw.mit.edu/courses/mathematics/18-443-statistics-for-applications-fall-2006/lecture-notes/lecture3.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ocw.mit.edu/courses/mathematics/18-443-statistics-for-applications-fall-2006/lecture-notes/lecture3.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Fisher-Information&quot;&gt;&lt;a href=&quot;#Fisher-Information&quot; class=&quot;headerlink&quot; title=&quot;Fisher Information&quot;&gt;&lt;/a&gt;Fisher Information&lt;/h2&gt;&lt;p&gt;又来抄录 Wikipedia 了，Fisher information 这个词我在好多地方见过，一直是不求甚解地意会着，最近发现这影响到一些东西的理解，于是开始翻看百科。&lt;/p&gt;
&lt;p&gt;言归正传，Fisher information 对于学统计的人应该很熟悉，用于描述可观测的变量 X 包含的对于决定它分布的参数 $\theta$ 的信息大小，直观地理解，如果 X 包含的关于 $\theta$ 的信息越多，后者就越确定，也就是其估计的方差越小。了解到这个信息就能得知，对于某些特定的分布模型，我们对于参数 $\theta$ 的极大似然估计 $\hat{\theta}_{ML}$ 的确信程度。&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://farseer.cn/categories/ML/"/>
    
    
      <category term="math" scheme="http://farseer.cn/tags/math/"/>
    
      <category term="statistics" scheme="http://farseer.cn/tags/statistics/"/>
    
  </entry>
  
  <entry>
    <title>Style mod for GoodReader with vimperator</title>
    <link href="http://farseer.cn/2015/10/05/style-mod-for-goodreader-with-vimperator/"/>
    <id>http://farseer.cn/2015/10/05/style-mod-for-goodreader-with-vimperator/</id>
    <published>2015-10-04T16:00:00.000Z</published>
    <updated>2016-02-17T02:30:18.010Z</updated>
    
    <content type="html">&lt;h2 id=&quot;The-Pain-Point&quot;&gt;&lt;a href=&quot;#The-Pain-Point&quot; class=&quot;headerlink&quot; title=&quot;The Pain Point&quot;&gt;&lt;/a&gt;The Pain Point&lt;/h2&gt;&lt;p&gt;Like I’ve mentioned in other posts, most of my reading is done with digital materials. And the application that I use most often for that purpose is named GoodReader(IOS platform). There certainly are better alternatives, nevertheless, I’m too lazy(poor) to alter.&lt;/p&gt;
&lt;p&gt;The old fashioned UI design of the app seems a little bit complicated and confusing, however the front-end page for file transfer via a WLAN is too simple to be satisfying.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no design not all&lt;/li&gt;
&lt;li&gt;multi-file uploading not allowed&lt;/li&gt;
&lt;li&gt;progressing info is too inconspicuous&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Well, the actual pain point for me is that the &lt;em&gt;submit&lt;/em&gt; button is initially hidden, and is invoked visible with the onChange function of the &lt;em&gt;file&lt;/em&gt; button, a glimpse at the source should be clear:&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;form&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;style&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;font-size:9pt&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;upload&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;action&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;_______HTMLFORMFILEUPLOADVIAHTTP_______&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;method&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;POST&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;enctype&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;multipart/form-data&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Select file to upload:&amp;amp;nbsp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;file&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;filename&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;size&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;40&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;onChange&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;this.form.submit.style.visibility=&#39;visible&#39;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Upload selected file&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;style&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;visibility: hidden&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;form&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;That seems to be OK, however, it’s a disaster if you use vimperator. Vimperator allows you to complete the operation of selecting files with a really nice built-in path completion interface looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/vimp-file.png&quot; alt=&quot;vimp-file&quot;&gt;&lt;/p&gt;
&lt;p&gt;All should be done with keyboard started by pressing &lt;strong&gt;f&lt;/strong&gt; (which is exactly the &lt;em&gt;focus-element&lt;/em&gt; shortcut) at the &lt;em&gt;file&lt;/em&gt; button and ended by pressing &lt;strong&gt;f&lt;/strong&gt; at the &lt;em&gt;submit&lt;/em&gt; button. But the latter is kept hidden after the selection, and &lt;strong&gt;f&lt;/strong&gt; won’t make use of hidden objects. i.e. The problem is that the onChange function won’t be called this way.&lt;/p&gt;
&lt;p&gt;Since the perfect way seems not working, one might surrender to a mouse. As paranoid as I am, however, changes shall be made.&lt;/p&gt;
&lt;p&gt;Once we’ve figured out what went wrong, solutions won’t be far ahead. So &lt;code&gt;Don&amp;#39;t panic!&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions&quot;&gt;&lt;/a&gt;Solutions&lt;/h2&gt;&lt;p&gt;3 dirty ways that I can come up with.&lt;/p&gt;
&lt;h3 id=&quot;Changing-the-Source-Code&quot;&gt;&lt;a href=&quot;#Changing-the-Source-Code&quot; class=&quot;headerlink&quot; title=&quot;Changing the Source Code&quot;&gt;&lt;/a&gt;Changing the Source Code&lt;/h3&gt;&lt;p&gt;The relative part of the vimperator src lies in &lt;code&gt;common/content/buffer.js&lt;/code&gt;.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;focusElement: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;elem&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (elem &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; HTMLFrameElement || elem &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; HTMLIFrameElement)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Buffer.focusedWindow = elem.contentWindow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (elem &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; HTMLInputElement &amp;amp;&amp;amp; elem.type == &lt;span class=&quot;string&quot;&gt;&quot;file&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Buffer.openUploadPrompt(elem);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        buffer.lastInputField = elem;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;openUploadPrompt: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;openUploadPrompt&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;elem&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    commandline.input(&lt;span class=&quot;string&quot;&gt;&quot;Upload file: &quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;path&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; file = io.File(path);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        liberator.assert(file.exists());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        elem.value = file.path;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        completer: completion.file,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;: elem.value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Adding &lt;code&gt;elem.onchange();&lt;/code&gt; to line 19, recompile, replace and restart, not elegant.&lt;/p&gt;
&lt;h3 id=&quot;Autocmd&quot;&gt;&lt;a href=&quot;#Autocmd&quot; class=&quot;headerlink&quot; title=&quot;Autocmd&quot;&gt;&lt;/a&gt;Autocmd&lt;/h3&gt;&lt;p&gt;Add 1 line to .vimperatorrc.&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;autocmd&lt;/span&gt; PageLoad &lt;span class=&quot;number&quot;&gt;192&lt;/span&gt;\\.&lt;span class=&quot;number&quot;&gt;168&lt;/span&gt;\\.* js window.content.document.getElementsByTagName(&lt;span class=&quot;string&quot;&gt;&quot;input&quot;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].onchange()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Works well but may cause error messages when opening other local pages. Of course, we can fix this by a js function with some checking inside, not elegant then.&lt;/p&gt;
&lt;h3 id=&quot;Override-the-Attribute&quot;&gt;&lt;a href=&quot;#Override-the-Attribute&quot; class=&quot;headerlink&quot; title=&quot;Override the Attribute&quot;&gt;&lt;/a&gt;Override the Attribute&lt;/h3&gt;&lt;p&gt;I prefer to change the visibility forcefully, it costs little and is probably bug free. 2 choices still, stylish or vimperator built-in? I chose the latter. So following lines are added to .vimperatorrc or the colorscheme file:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;style -name goodreader-submit-visible http://* &amp;lt;&amp;lt;EOM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @-moz-document regexp(&#39;http://192\\.168\\..*&#39;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        input[type=&quot;submit&quot;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            visibility: visible !important;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EOM&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;The-Pain-Point&quot;&gt;&lt;a href=&quot;#The-Pain-Point&quot; class=&quot;headerlink&quot; title=&quot;The Pain Point&quot;&gt;&lt;/a&gt;The Pain Point&lt;/h2&gt;&lt;p&gt;Like I’ve mentioned in other posts, most of my reading is done with digital materials. And the application that I use most often for that purpose is named GoodReader(IOS platform). There certainly are better alternatives, nevertheless, I’m too lazy(poor) to alter.&lt;/p&gt;
&lt;p&gt;The old fashioned UI design of the app seems a little bit complicated and confusing, however the front-end page for file transfer via a WLAN is too simple to be satisfying.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no design not all&lt;/li&gt;
&lt;li&gt;multi-file uploading not allowed&lt;/li&gt;
&lt;li&gt;progressing info is too inconspicuous&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tweak" scheme="http://farseer.cn/categories/tweak/"/>
    
    
      <category term="vimperator" scheme="http://farseer.cn/tags/vimperator/"/>
    
      <category term="ツッコミ" scheme="http://farseer.cn/tags/%E3%83%84%E3%83%83%E3%82%B3%E3%83%9F/"/>
    
  </entry>
  
  <entry>
    <title>The hybrid Monte Carlo</title>
    <link href="http://farseer.cn/2015/09/22/the-hybrid-monte-carlo/"/>
    <id>http://farseer.cn/2015/09/22/the-hybrid-monte-carlo/</id>
    <published>2015-09-21T16:00:00.000Z</published>
    <updated>2016-03-10T01:52:19.040Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;作为一种先进的采样算法，在 PRML 11.5 中有较为详细的介绍，然而我反复细读了两遍才初窥门径，于是打算将其整理成文。&lt;/p&gt;
&lt;h2 id=&quot;Goals-of-Sampling&quot;&gt;&lt;a href=&quot;#Goals-of-Sampling&quot; class=&quot;headerlink&quot; title=&quot;Goals of Sampling&quot;&gt;&lt;/a&gt;Goals of Sampling&lt;/h2&gt;&lt;p&gt;我决定从 Metropolis 算法开始介绍 Markov Chain Monte Carlo，然后是 Gibbs 采样，最后到混合 Monte Carlo，顺便作为笔记以便日后翻阅。&lt;/p&gt;
&lt;p&gt;不论是哪种算法，其目的都是一致的，即抽取出符合分布 $p(\mathbf{z})$ 的样本，同时，我们希望样本之间是无关的，即满足 &lt;a href=&quot;https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;i.i.d.&lt;/a&gt; 条件。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;采样的目的很大程度上是为了计算期望值，为了近似 $\mathbb{E}[f] = \int f(\mathbf{z}) p(\mathbf{z}) d\mathbf{z} \approx \frac1L \sum\limits_{l=1} ^L f(\mathbf{z} ^{(l)})$.&lt;/p&gt;
&lt;h2 id=&quot;Markov-Chain-Monte-Carlo&quot;&gt;&lt;a href=&quot;#Markov-Chain-Monte-Carlo&quot; class=&quot;headerlink&quot; title=&quot;Markov Chain Monte Carlo&quot;&gt;&lt;/a&gt;Markov Chain Monte Carlo&lt;/h2&gt;&lt;p&gt;Markov Chain Monte Carlo (MCMC) 的基本思想是，通过构造一个状态分布收敛于 $p(\mathbf{z})$ 的 Markov chain 来进行采样，每次根据当前样本和转移函数（条件概率）抽取出下一个样本，序列中较为靠后的样本近似服从目标分布，当序列足够长时，这种采样便能获得很好的效果。&lt;/p&gt;
&lt;p&gt;于是需要解决两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何构造这样的马尔科夫链使得它收敛到唯一的 equilibrium distribution $p(\mathbf{z})$？&lt;/li&gt;
&lt;li&gt;显然，通过 MCMC 直接获取的相邻样本间有很强的相关性，如何处理，使得样本之间近似独立？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Markov-Chains&quot;&gt;&lt;a href=&quot;#Markov-Chains&quot; class=&quot;headerlink&quot; title=&quot;Markov Chains&quot;&gt;&lt;/a&gt;Markov Chains&lt;/h3&gt;&lt;p&gt;首先假设我们选取的转移概率函数 $T(\mathbf{z} ^{(m)}, \mathbf{z} ^{(m+1)}) = p(\mathbf{z} ^{(m+1)} | \mathbf{z} ^{(m)})$ 是时不变的，i.e. 只考虑 time-homogeneous Markov chain. 以便于分析与计算。&lt;/p&gt;
&lt;p&gt;为了解决问题1，分两步走：&lt;/p&gt;
&lt;p&gt;1.1 保证这个 MC 有唯一的 stationary distribution &lt;br&gt;&lt;br&gt;1.2 使得 $p(\mathbf{z})$ 是其 stationary distribution, i.e. $p(\mathbf{z}) = \sum\limits_{\mathbf{z’}} T(\mathbf{z’}, \mathbf{z}) p(\mathbf{z’})$&lt;/p&gt;
&lt;p&gt;根据随机过程的相关理论，1.1 的一个充分条件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;finite state&lt;/li&gt;
&lt;li&gt;irreducible, 即任意两个状态相互可达&lt;/li&gt;
&lt;li&gt;all states are positive recurrent&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更加明确地，对于有限状态的 MC，只需满足 $v = min_{x}min_{x’: p(x’)&amp;gt;0} T(x, x’)/p(x’) &amp;gt; 0$ 即可（相关证明见文末参考链接）。对于无限状态的 MC，收敛性质变得不容易分析，但是与有限状态类似，1.1 的性质并不难满足，后面的讨论都假设它已经成立。&lt;/p&gt;
&lt;p&gt;对于 1.2，我们希望 T 满足下述充分不必要条件 detailed balance:&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;p(\mathbf{z}) T(\mathbf{z}, \mathbf{z’}) = p(\mathbf{z’}) T(\mathbf{z’}, \mathbf{z})\tag{1}\label{eq1}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;直观上看，说的是任意两个状态之间的收支互补，于是分布不变。严格的证明很容易，此处略去。&lt;/p&gt;
&lt;p&gt;至此，为了满足1，只需要找到合适的 T 满足 $\eqref{eq1}$. （假设1.1容易满足）&lt;/p&gt;
&lt;h3 id=&quot;The-Metropolis-Hastings-Algorithm&quot;&gt;&lt;a href=&quot;#The-Metropolis-Hastings-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;The Metropolis-Hastings Algorithm&quot;&gt;&lt;/a&gt;The Metropolis-Hastings Algorithm&lt;/h3&gt;&lt;p&gt;首先假设 $p(\mathbf{z}) = \tilde{p}(\mathbf{z})/ Z_p$，此处的归一化因子难以计算。我们任意取一个已知的容易抽样的条件概率函数 $q(\mathbf{z’} | \mathbf{z})$，若当前状态为 z，则以对应的条件概率抽取下一个候选状态 z’，然后以概率&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;A(\mathbf{z’}, \mathbf{z}) = min(1, \frac{\tilde{p}(\mathbf{z’})q(\mathbf{z} | \mathbf{z’})}{\tilde{p}(\mathbf{z})q(\mathbf{z’} | \mathbf{z})})&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;选择是否接受 z’. 可见对应的转移概率函数 $T(\mathbf{z}, \mathbf{z’}) = q(\mathbf{z’} | \mathbf{z}) A(\mathbf{z’}, \mathbf{z})$ 带入 $\eqref{eq1}$ 可得：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;p(\mathbf{z})q(\mathbf{z’} | \mathbf{z}) A(\mathbf{z’}, \mathbf{z}) = min(p(\mathbf{z})q(\mathbf{z’} | \mathbf{z}), p(\mathbf{z’})q(\mathbf{z} | \mathbf{z’})) \\&lt;br&gt;= min(p(\mathbf{z’})q(\mathbf{z} | \mathbf{z’}), p(\mathbf{z})q(\mathbf{z’} | \mathbf{z})) \\&lt;br&gt;= p(\mathbf{z’})q(\mathbf{z} | \mathbf{z’}) A(\mathbf{z}, \mathbf{z’})&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;此处的证明在我看的 PRML 第一版中将 q 中所有对应的条件和结果给搞反了，不过不影响理解。对于 q 的选取，当状态空间连续时，通常选择高斯分布。&lt;/p&gt;
&lt;p&gt;于是问题1得到了解决，对于问题2，一个简单的做法是在生成的样本中每隔若干选取一个，这样相邻的样本之间的相关度就大大降低了。那么应该间隔多少呢？我在这里略去具体的定量分析，事实上 PRML 对 Random walk 以及独立步长的描述也是含糊不清，但是其定性的描述是非常符合直觉的。&lt;/p&gt;
&lt;p&gt;例如考虑 q 取高斯分布的情况，均值肯定是对应的条件值，若方差很小，则每次转移的平均步长会很小，因此相邻样本之间的关联性很大，为了获取 i.i.d. 需要的间隔就很大；反之若方差很大，转移的平均步长较大，A 取到较小值的概率增加，即采样的失败率下降。因此 q 的方差可以对采样失败率和独立步长进行 trade-off. 而后文介绍的混合蒙特卡洛则能够将这两个值同时降低到一个较为理想的值。&lt;/p&gt;
&lt;h3 id=&quot;Gibbs-Sampling&quot;&gt;&lt;a href=&quot;#Gibbs-Sampling&quot; class=&quot;headerlink&quot; title=&quot;Gibbs Sampling&quot;&gt;&lt;/a&gt;Gibbs Sampling&lt;/h3&gt;&lt;p&gt;Gibbs 采样基于的假设是条件概率容易计算且容易采样，是 Metropolis-Hastings 的一个特例，对于 n 维向量 $\mathbf{z}$, 每 n 次状态转移构成一个新的样本，其中第 k 次转移只改变 $z_k$ 的值，转移概率函数为 $q_k(\mathbf{z’} | \mathbf{z}) = p(z’_k | \mathbf{z_{/k}})$ 即为目标分布下的条件概率。容易算得对应的采样成功率 A 为理想值1.&lt;/p&gt;
&lt;p&gt;在理想的状况下，若 $\mathbf{z}$ 的各个分量相互独立，则每次转移便能够看成是从联合分布中随机抽取一个维度，每 k 次转移完整地从联合分布中抽取一个样本，于是满足 i.i.d. 性质。不然的话，相邻样本间存在相关性，需要舍弃一些中间样本。&lt;/p&gt;
&lt;h2 id=&quot;hybrid-Monte-Carlo&quot;&gt;&lt;a href=&quot;#hybrid-Monte-Carlo&quot; class=&quot;headerlink&quot; title=&quot;hybrid Monte Carlo&quot;&gt;&lt;/a&gt;hybrid Monte Carlo&lt;/h2&gt;&lt;p&gt;根据 &lt;a href=&quot;https://en.wikipedia.org/wiki/Maxwell–Boltzmann_distribution&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Maxwell–Boltzmann&lt;/a&gt; 分布，如果我们将 $\mathbf{z}$ 类比为分子的空间位置，若平衡后分子的位置分布服从 $p(\mathbf{z})$，则对应的空间势能函数 $E(\mathbf{z})$ 满足 $p(\mathbf{z}) = \frac{1}{Z_p} exp(-E(\mathbf{z}))$, 此处忽略了系数 kT.&lt;/p&gt;
&lt;p&gt;若引入分子的动量 $\mathbf{r}$，则总能量为势能+动能，即 $H(\mathbf{z}, \mathbf{r}) = E(\mathbf{z}) + K(\mathbf{r})$, 其中 $K(\mathbf{r}) = \frac12 \sum\limits_{i} r_i ^2$. 则平衡后分子的分布满足&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;p(\mathbf{z}, \mathbf{r}) = \frac{1}{Z_H} exp(-H(\mathbf{z}, \mathbf{r})) \tag{2}\label{eq2}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;若我们将分子的运动看作是随机变量 $(\mathbf{z}, \mathbf{r})$ 上的一个 MC，只不过此处我们只在经典力学范围内进行演绎，因此状态转移函数是确定的。类比于 Maxwell-Boltzmann 分布，可以知道这个 MC 收敛于 $\eqref{eq2}$.&lt;/p&gt;
&lt;p&gt;于是我们可以在上述 Markov Chain 上对扩充后的状态空间 $(\mathbf{z}, \mathbf{r})$ 进行采样，随后再将不需要的动量舍去，便能够得到服从 $p(\mathbf{z})$ 的样本。之所以要引入多余的变量 $\mathbf{r}$，是为了求解动力学方程，从而得到一个确定的转移函数。&lt;/p&gt;
&lt;p&gt;此处我的描述与 PRML 中略有出入，原因是我认为第一版中 P550 中对 $\eqref{eq2}$ 在转移下 invariant 的论述并不正确，anyway，我相信这个结论是对的，而且我上面的论述更让自己信服。&lt;/p&gt;
&lt;p&gt;事实上，如果我们能够通过动力学方程准确地计算出分子的轨迹和动量变化（或者是转移方程 T），回到最初提出的两个要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于要求1，根据上述分析，1.2在 T 下确实得到满足&lt;/li&gt;
&lt;li&gt;只需要每隔足够的时间进行一次采样就能保证独立性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于收敛条件1.2已然满足，我们不需要引入额外的 A，即采样的成功率是 100%. 我们只需要沿着时间轴，每隔一段时间根据转移方程和当前状态确定地计算出下一个样本状态即可。然而在实现的时候存在如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了计算 T，我们需要进行数值积分，因而引入误差，从而导致1.2不再成立&lt;/li&gt;
&lt;li&gt;即便是没有误差，由于能量守恒，和特定的起始状态，抽样并不能遍历整个状态空间，换句话说1.1并不成立&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于1.1，我们可以在某些采样的时候对引入的额外变量 $\mathbf{r}$ 进行 Gibbs 采样来强制进行偏移，由于我们只关心采样后得到的 $\mathbf{z}$，这样的做法在条件概率可采样的情况下是可行的，并且不会降低其采样成功率。虽然这个做法还是存在一定的问题，但是更加细致的分析我本人并不关心。&lt;/p&gt;
&lt;p&gt;于是剩下的就只是误差问题，后面我们将看到即便存在误差，1.2依然可以满足。&lt;/p&gt;
&lt;h3 id=&quot;Dynamical-Systems&quot;&gt;&lt;a href=&quot;#Dynamical-Systems&quot; class=&quot;headerlink&quot; title=&quot;Dynamical Systems&quot;&gt;&lt;/a&gt;Dynamical Systems&lt;/h3&gt;&lt;p&gt;首先我们试图计算 T，建立动力学方程。首先，动量正比于速度，略去质量这个常数后有&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\frac{d z_i}{d t} = r_i = \frac{\partial H}{\partial r_i} \tag{3}\label{eq3}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;又动量变化量正比于外力（可以看作粒子处于势能为 $E(\mathbf{z})$）的力场，于是略去常数后有&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\frac{d r_i}{d t} = - \frac{\partial E(\mathbf{z})}{\partial z_i} = - \frac{\partial H}{\partial z_i}\tag{4}\label{eq4}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;我们假设 $E(\mathbf{z})$ 对应于目标分布，是已知的，且其值以及各个 $\frac{\partial E(\mathbf{z})}{\partial z_i}$ 均容易计算，则我们可以通过如下的 leapfrog 公式近似得到 T:&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\hat{r}_i(t + \epsilon/2) = \hat{r}_i(t) - \frac{\epsilon}{2} \frac{\partial E}{\partial z_i}(\hat{\mathbf{z}}(t)) \\&lt;br&gt;\hat{z_i}(t + \epsilon) = \hat{z_i}(t) + \epsilon \hat{r}_i(t + \epsilon/2) \\&lt;br&gt;\hat{r}_i(t + \epsilon) = \hat{r}_i(t + \epsilon/2) - \frac{\epsilon}{2} \frac{\partial E}{\partial z_i}(\hat{\mathbf{z}}(t + \epsilon))&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;其原理很简单，考虑泰勒展开即可，之所以要将更新穿插进行，一方面是为了精确，更重要的是因为这样得到的 $\hat{T}$ 是可逆的，即正向更新 $\epsilon$ 后紧接着反向更新步长 $-\epsilon$ 可以回到原状态。这使得在不能精确还原 T 的情况下通过巧妙的调整依然可以保证收敛性质1.2。可以看出，我们不单可以顺着时间轴进行采样，逆向回溯也是可行的。&lt;/p&gt;
&lt;h3 id=&quot;The-Algorithm&quot;&gt;&lt;a href=&quot;#The-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;The Algorithm&quot;&gt;&lt;/a&gt;The Algorithm&lt;/h3&gt;&lt;p&gt;所谓的“巧妙的调整”指的是，每次采样时（假设当前状态为 $\mathfrak{R}$），抛硬币决定是正向以 $\epsilon$ 或者反向以 $-\epsilon$ 为步长迭代 L 次 leapfrog 得到候选状态 $\mathfrak{R}’$，同时类似 Metropolis-Hastings 算法，以概率 $min(1, exp(-H(\mathfrak{R’}) + H(\mathfrak{R})))$ 接受该候选状态。&lt;/p&gt;
&lt;p&gt;下面通过证明这样修改后的 T 满足 $\eqref{eq1}$ 从而说明收敛性质1.2得到满足。&lt;/p&gt;
&lt;p&gt;首先，由于状态空间连续，对应版本的 detailed balance 需要考察状态空间中的两块可以相互转化的小区域（区域内的 H 值视为常数），容易知道在 leapfrog 操作下前后对应的状态空间区域的体积不变（每一步更新只在一个维度上平移一个常量，更严格的论述参见书本 p553），令这个不变的体积为 $\delta V$，依据上面描述的 T，有：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;p(\mathfrak{R}) T(\mathfrak{R}, \mathfrak{R’}) = \frac{1}{Z_H}exp(-H(\mathfrak{R})) \delta V \frac12 min{1, exp(-H(\mathfrak{R’}) + H(\mathfrak{R})))} \\&lt;br&gt;= \frac{1}{Z_H}exp(-H(\mathfrak{R’})) \delta V \frac12 min{1, exp(-H(\mathfrak{R}) + H(\mathfrak{R’})))} \\&lt;br&gt;= p(\mathfrak{R’}) T(\mathfrak{R’}, \mathfrak{R})&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;其中系数0.5源自抛硬币的概率，第二个等号的成立只需要对 $H(\mathfrak{R}), H(\mathfrak{R’})$ 的相对大小分类讨论即能得出。注意：第一版中将 min 函数内部的正负号均搞反了，容易造成误导。&lt;/p&gt;
&lt;p&gt;至此，可以看出这个算法在理论上与 MCMC 一样是可行的，那么它的优越性其实在于，在 L 够大的情况下，状态得到充分的偏移，样本间的独立性容易满足，而且此时，由于 leapfrog 的近似，状态转移近似依照 T 进行，因而能量近似守恒，即采样成功率很高。粗略的定量分析可以参照书本 p553-554.&lt;/p&gt;
&lt;h2 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Markov_chain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markov chain&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markov chain Monte Carlo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/cmbishop/prml/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Christopher M. Bishop | PRML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.toronto.edu/pub/radford/review.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Probabilistic Inference Using Markov Chain Monte Carlo Methods&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;作为一种先进的采样算法，在 PRML 11.5 中有较为详细的介绍，然而我反复细读了两遍才初窥门径，于是打算将其整理成文。&lt;/p&gt;
&lt;h2 id=&quot;Goals-of-Sampling&quot;&gt;&lt;a href=&quot;#Goals-of-Sampling&quot; class=&quot;headerlink&quot; title=&quot;Goals of Sampling&quot;&gt;&lt;/a&gt;Goals of Sampling&lt;/h2&gt;&lt;p&gt;我决定从 Metropolis 算法开始介绍 Markov Chain Monte Carlo，然后是 Gibbs 采样，最后到混合 Monte Carlo，顺便作为笔记以便日后翻阅。&lt;/p&gt;
&lt;p&gt;不论是哪种算法，其目的都是一致的，即抽取出符合分布 $p(\mathbf{z})$ 的样本，同时，我们希望样本之间是无关的，即满足 &lt;a href=&quot;https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables&quot;&gt;i.i.d.&lt;/a&gt; 条件。&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://farseer.cn/categories/ML/"/>
    
    
      <category term="statistics" scheme="http://farseer.cn/tags/statistics/"/>
    
      <category term="physics" scheme="http://farseer.cn/tags/physics/"/>
    
  </entry>
  
  <entry>
    <title>Hammersley Clifford Theorem</title>
    <link href="http://farseer.cn/2015/09/13/hammersley-clifford-theorem/"/>
    <id>http://farseer.cn/2015/09/13/hammersley-clifford-theorem/</id>
    <published>2015-09-12T16:00:00.000Z</published>
    <updated>2016-03-10T01:53:42.449Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;PRML 中 8.3.2 小节简单描述了 Markov Random Fields 的分解特性，其中最核心的部分就是 Hammersley Clifford Theorem, 然而它并没有证明这个定理，只是在末尾的时候提到了这个结论，导致我在阅读中间部分的时候一头雾水。好在我 google 到了一个&lt;a href=&quot;http://web.kaist.ac.kr/~kyomin/Fall09MRF/Hammersley-Clifford_Theorem.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;优雅的证明&lt;/a&gt;，顺便翻译在此。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Probabilistic-Graphical-Models&quot;&gt;&lt;a href=&quot;#Probabilistic-Graphical-Models&quot; class=&quot;headerlink&quot; title=&quot;Probabilistic Graphical Models&quot;&gt;&lt;/a&gt;Probabilistic Graphical Models&lt;/h2&gt;&lt;p&gt;先随便插点 PRML 中关于概率图模型比较重要的论述。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概率图模型用于形象地描述一组随机变量的联合分布&lt;ul&gt;
&lt;li&gt;可以被看作是对联合分布的一种过滤器&lt;/li&gt;
&lt;li&gt;如果图 G 中反映出的所有变量间的条件独立性质均在某个分布 P 中满足，则 P 可以通过该过滤器&lt;/li&gt;
&lt;li&gt;在满足上一条的前提下，如果 P 中真实存在的所有变量间的条件独立性在图 G 上均能反映，则称 G 为 P 的 &lt;em&gt;perfect map&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;概率图模型大致分为两种，有向图和无向图&lt;ul&gt;
&lt;li&gt;有向图的优点在于联合分布可以很容易地分解为节点属性（也就是条件概率）的乘积&lt;/li&gt;
&lt;li&gt;然而有向图在反映条件独立性质的时候，并不十分直接（head-2-head）&lt;/li&gt;
&lt;li&gt;无向图可以直观地反映变量间的条件独立性质，代价是联合分布较难表示，而后文将证明的定理就是为了解决这个问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有向图和无向图的表达能力是不同的&lt;ul&gt;
&lt;li&gt;换句话说，给定随机变量集合后，能够用有向图 perfect map 的所有联合分布的集合 D 与能够用无向图 perfect map 的所有联合分布的集合 U 并不相同&lt;/li&gt;
&lt;li&gt;它们与所有该随机变量集合能够形成的联合分布集合 P 的关系如下图：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/DUG.png&quot; alt=&quot;sgd&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Markov-Random-Fields&quot;&gt;&lt;a href=&quot;#Markov-Random-Fields&quot; class=&quot;headerlink&quot; title=&quot;Markov Random Fields&quot;&gt;&lt;/a&gt;Markov Random Fields&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;无向图模型&lt;/li&gt;
&lt;li&gt;图中的每个节点对应一个或一组随机变量&lt;/li&gt;
&lt;li&gt;图中的连线表示随机变量之间的联系，具有如下属性：&lt;ul&gt;
&lt;li&gt;变量间的条件独立性容易判断，事实上，假设 A, B, C 为图 G 中的3组顶点集合&lt;/li&gt;
&lt;li&gt;如果 A 到 B 的每条路线中都至少经过 C 中的一个顶点，则称 A 与 B 在条件 C 下独立&lt;/li&gt;
&lt;li&gt;记作 $A \perp\!\!\!\perp B | C$，满足：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br&gt;P(A, B | C) = P(A | C) \cdot P(B | C)\tag{0}\label{eq0}&lt;br&gt;$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑顶点 $X_i$, 记其所有邻顶点集合为 $N_i$, 令 $D_i = N_i \cup \{X_i\}, A = \{X_i\}, B = G/D_i, C = N_i$&lt;ul&gt;
&lt;li&gt;B 为图中除去顶点 i 及其相邻顶点后的集合，C 为其邻顶点集，A 与 B 中的连线必过 C，于是 $P(X_i, X_{G/D_i} | X_{N_i}) = P(X_i | X_{N_i}) P(X_{G/D_i} | X_{N_i})$&lt;/li&gt;
&lt;li&gt;根据贝叶斯公式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br&gt;P(X_i | X_{G/i}) = \frac{P(X_i, X_{G/D_i} | X_{N_i})}{P(X_{G/D_i} | X_{N_i})} = \frac{P(X_i | X_{N_i}) P(X_{G/D_i} | X_{N_i})}{P(X_{G/D_i} | X_{N_i})} = P(X_i | X_{N_i})\tag{1}\label{eq1}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;换句话说，$X_i$ 的条件概率，仅与其相邻顶点的取值相关。以上便是 MRF 的定义。&lt;/p&gt;
&lt;h2 id=&quot;Gibbs-Distribution&quot;&gt;&lt;a href=&quot;#Gibbs-Distribution&quot; class=&quot;headerlink&quot; title=&quot;Gibbs Distribution&quot;&gt;&lt;/a&gt;Gibbs Distribution&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个定义在无向图 G 上的联合概率分布 $P(X)$ 被称为 Gibbs 分布 iff：&lt;ul&gt;
&lt;li&gt;它能够被分解为关于 G 中的团（联通子图）的正函数的积&lt;/li&gt;
&lt;li&gt;记 $C_G$ 为图 G 中所有团的集合，$Z = \sum_x \prod_{c \in C_G} \phi_c(X_c)$ 为归一化因子，即有：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br&gt;P(X) = \frac1Z \prod\limits_{c \in C_G} \phi_c(X_c)\tag{2}\label{eq2}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;注意到团上的函数之积可以合并，我们可以将 $C_G$ 定义为最大团集合，表达能力不变。&lt;/p&gt;
&lt;h2 id=&quot;Hammersley-Clifford-Theorem&quot;&gt;&lt;a href=&quot;#Hammersley-Clifford-Theorem&quot; class=&quot;headerlink&quot; title=&quot;Hammersley Clifford Theorem&quot;&gt;&lt;/a&gt;Hammersley Clifford Theorem&lt;/h2&gt;&lt;p&gt;该定理说的是，MRF 与 Gibss 分布的定义等价。i.e. 对于同样的 G，上述两种定义能够表示的所有联合概率分布 $P(X)$ 的集合相同。下面给出该定理的证明。&lt;/p&gt;
&lt;h3 id=&quot;Backward-Direction&quot;&gt;&lt;a href=&quot;#Backward-Direction&quot; class=&quot;headerlink&quot; title=&quot;Backward Direction&quot;&gt;&lt;/a&gt;Backward Direction&lt;/h3&gt;&lt;p&gt;先证明：Gibbs 分布满足 MRF 中通过拓扑引入的所有条件独立特性, 即满足 $\eqref{eq1}$.&lt;/p&gt;
&lt;p&gt;通过边缘分布公式，有：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;P(X_i | X_{N_i}) = \frac{P(X_i, X_{N_i})}{P(X_{N_i})} = \frac{\sum_{G/D_i} \prod_{c \in C_G} \phi_c(X_c)}{\sum_{x_i}\sum_{G/D_i} \prod_{c \in C_G} \phi_c(X_c)}\tag{3}\label{eq3}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;然后将 $C_G$ 中的团，依据是否包含 $X_i$ 分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$C_i = \{c \in C_G : X_i \in c\}$&lt;/li&gt;
&lt;li&gt;$R_i = \{c \in C_G : X_i \notin c\}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是将 $\eqref{eq3}$ 中的分子分母均进行分解，得到：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;P(X_i | X_{N_i}) = \frac{\sum_{G/D_i} \prod_{c \in C_i} \phi_c(X_c) \prod_{c \in R_i} \phi_c(X_c)}{\sum_{x_i}\sum_{G/D_i} \prod_{c \in C_i} \phi_c(X_c) \prod_{c \in R_i} \phi_c(X_c)} = \frac{\prod_{c \in C_i} \phi_c(X_c) \sum_{G/D_i} \prod_{c \in R_i} \phi_c(X_c)}{\sum_{x_i} \prod_{c \in C_i} \phi_c(X_c) \sum_{G/D_i} \prod_{c \in R_i} \phi_c(X_c)} \tag{4}\label{eq4}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;之所以能够交换求和号与求积号的顺序，是因为 $C_i$ 中的团 c 包含了 $X_i$, 于是 c 中的所有顶点均在 $D_i$ 中，因此求和过程中 $\prod_{c \in C_i} \phi_c(X_c)$ 保持不变。又 $\sum_{G/D_i} \prod_{c \in R_i} \phi_c(X_c)$ 与 $x_i$ 无关，因此可以被约去，得到：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;P(X_i | X_{N_i}) = \frac{\prod_{c \in C_i} \phi_c(X_c)}{\sum_{x_i}\prod_{c \in C_i} \phi_c(X_c)} = \frac{\prod_{c \in C_i} \phi_c(X_c)}{\sum_{x_i}\prod_{c \in C_i} \phi_c(X_c)} \cdot \frac{\prod_{c \in R_i} \phi_c(X_c)}{\prod_{c \in R_i} \phi_c(X_c)}\\&lt;br&gt;= \frac{\prod_{c \in C_G} \phi_c(X_c)}{\sum_{x_i}\prod_{c \in C_G} \phi_c(X_c)} = \frac{P(X)}{P(X_{G/{i}})} = P(X_i | X_{G/i})&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;即得 $\eqref{eq1}$.&lt;/p&gt;
&lt;h3 id=&quot;Forward-Direction&quot;&gt;&lt;a href=&quot;#Forward-Direction&quot; class=&quot;headerlink&quot; title=&quot;Forward Direction&quot;&gt;&lt;/a&gt;Forward Direction&lt;/h3&gt;&lt;p&gt;需要证明：如果 $\eqref{eq1}$ 成立，则存在这样的 $\phi_c(X_c)$ 使得 $\eqref{eq2}$ 成立。通过构造加以证明，首先定义子集 $s \subset G$ 上的函数：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;f_s(X_s = x_s) = \prod\limits_{z \subset s} P(X_z = x_z, X_{G/z} = 0) ^{-1 ^{|s| - |z|}}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;该函数为所有 s 的子集 z 上的函数之积，$P(X_z = x_z, X_{G/z} = 0)$ 对应于 z 中元素与给定的取值相同，其余元素全为 0 的概率。当 z 与 s 的大小相差为偶数时，对应的指数为1，否则为-1.&lt;/p&gt;
&lt;p&gt;容易直到，如果能够证明如下两个性质，则 $\phi_c(X_c) = f_c(X_c)$ 即满足条件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\prod_{s \subset G} f_s(X_s) = P(X)$&lt;/li&gt;
&lt;li&gt;若 s 不是团，则 $f_s(X_s) = 1$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于性质1，考虑某个 $z \subset G$, 考虑 $\Delta = P(X_z, X_{G/z} = 0)$ 在1的左边出现的所有因子。它在 $f_z(X_z)$ 中出现过，对应的指数为 1，对应的因子为 $\Delta$; 又它出现在 $C_{|G| - |z|} ^1$ 个“恰包含了 z 以及另1个元素的子集”的函数值中，对应的因子的积为 $\Delta ^{- C_{|G| - |z|} ^1}$; 又它出现在 $C_{|G| - |z|} ^2$ 个“恰包含了 z 以及另外2个元素的子集”的函数值中，对应的因子的积为 $\Delta ^{C_{|G| - |z|} ^2}$ …… 由于 $0 = (1 - 1) ^K = C_K ^0 - C_K ^1 + C_K ^2 + \cdots + (-1) ^K C_K ^K$, 1中左侧各个子集 z 对应的因子的总乘积为1，除非 z 取 G，对应的因子即为 $P(X)$.&lt;/p&gt;
&lt;p&gt;接下来，通过 MRF 的属性来证明性质2. 对于 s 非团的情况，取其中不相连的两个顶点 a, b.&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;f_s(X_s) = \prod\limits_{w \subset s/\{a, b\}} [\frac{P(X_w, X_{G/w}=0)P(X_{w \cup \{a, b\}}, X_{G/w \cup \{a, b\}}=0)}{P(X_{w \cup \{a\}}, X_{G/w \cup \{a\}}=0)P(X_{w \cup \{b\}}, X_{G/w \cup \{b\}}=0)}] ^{-1 ^*}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;即考虑 s 中所有子集中 a, b 的出现情况，分为四类，并将对应的因子合并，$-1 ^*$ 表示指数无关紧要，因为紧接着将证明等号右边中每个因子的底数为1. 根据贝叶斯法则：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\frac{P(X_w, X_{G/w} = 0)}{P(X_{w \cup \{a\}}, X_{G/w \cup \{a\}} = 0)} \\&lt;br&gt;= \frac{P(X_a = 0|X_w, X_b = 0, X_{G/w \cup \{a, b\}} = 0)P(X_w, X_b = 0, X_{G/w \cup \{a, b\}} = 0)}{P(X_a | X_w, X_b = 0, X_{G/w \cup \{a, b\}} = 0)P(X_w, X_b = 0, X_{G/w \cup \{a, b\}} = 0)} \\&lt;br&gt;= \frac{P(X_a = 0|X_w, X_b, X_{G/w \cup \{a, b\}} = 0)P(X_w, X_b, X_{G/w \cup \{a, b\}} = 0)}{P(X_a | X_w, X_b, X_{G/w \cup \{a, b\}} = 0)P(X_w, X_b, X_{G/w \cup \{a, b\}} = 0)} \\&lt;br&gt;= \frac{P(X_{w \cup \{b\}}, X_{G/w \cup \{b\}} = 0)} {P(X_{w \cup \{a, b\}}, X_{G/w \cup \{a, b\}} = 0)} \tag{5}\label{eq5}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;上式中第二的等式成立是因为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分子分母的右侧因子相同，同时进行了替换&lt;/li&gt;
&lt;li&gt;取 $A = \{a\}, B = \{b\}, C = G/\{a, b\}$，由 $A \perp\!\!\!\perp B | C$ 以及 $\eqref{eq0}$ 得到 $P(A | B, C) = \frac{P(A, B | C)}{P(B | C)} = P(A | C) = P(A | B = b, C)$ 即 $P(X_a | X_w, X_b = 0, X_{G/w \cup \{a, b\}} = 0) = P(X_a | X_w, X_b, X_{G/w \cup \{a, b\}} = 0)$, 同理分子的部分也相等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据 $\eqref{eq5}$ 容易得到性质2，于是正向的证明完成。&lt;/p&gt;
&lt;h2 id=&quot;Original-Work&quot;&gt;&lt;a href=&quot;#Original-Work&quot; class=&quot;headerlink&quot; title=&quot;Original Work&quot;&gt;&lt;/a&gt;Original Work&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://web.kaist.ac.kr/~kyomin/Fall09MRF/Hammersley-Clifford_Theorem.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hammersley-Clifford_Theorem.pdf&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;PRML 中 8.3.2 小节简单描述了 Markov Random Fields 的分解特性，其中最核心的部分就是 Hammersley Clifford Theorem, 然而它并没有证明这个定理，只是在末尾的时候提到了这个结论，导致我在阅读中间部分的时候一头雾水。好在我 google 到了一个&lt;a href=&quot;http://web.kaist.ac.kr/~kyomin/Fall09MRF/Hammersley-Clifford_Theorem.pdf&quot;&gt;优雅的证明&lt;/a&gt;，顺便翻译在此。&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://farseer.cn/categories/ML/"/>
    
    
      <category term="statistics" scheme="http://farseer.cn/tags/statistics/"/>
    
  </entry>
  
  <entry>
    <title>Quosi Newton Methods</title>
    <link href="http://farseer.cn/2015/09/02/quosi-newton-methods/"/>
    <id>http://farseer.cn/2015/09/02/quosi-newton-methods/</id>
    <published>2015-09-01T16:00:00.000Z</published>
    <updated>2016-03-10T01:54:38.361Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;最近在以蜗牛般的速度啃 PRML。第五章提到了拟牛顿法，这玩意我之前大致意会过，并作了一些笔记，然而我完全无法回忆起来，于是翻出之前的笔记重新意会了一遍，顺便更正了之前一些不太正确的理解，总结整理成下文。&lt;/p&gt;
&lt;h2 id=&quot;Newton’s-Method&quot;&gt;&lt;a href=&quot;#Newton’s-Method&quot; class=&quot;headerlink&quot; title=&quot;Newton’s Method&quot;&gt;&lt;/a&gt;Newton’s Method&lt;/h2&gt;&lt;p&gt;考虑求自变量 X 为 N 维向量的函数 $f(X)$ 的极值点问题。我们知道高中数学中的牛顿法可以用于求解函数0点的：$X_{k+1} = X_n - [J_f(X_k)] ^{-1}f(X_k)$. 那么可导函数的极值问题其实就是求其导函数的0点问题，同样可以用牛顿法求解。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;以同样的迭代方式逼近，设 $X_k$ 为当前对极值点的估计，考虑 f 在其附近的二阶 Taylor 展开：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;f(X) \approx f(X_k) + \nabla f(X_k) \cdot (X - X_k) + 0.5 \cdot (X - X_k) ^T \cdot \nabla ^2 f(X_k) \cdot (X - X_k)\tag{1}\label{eq1}&lt;br&gt;$$.&lt;/p&gt;
&lt;p&gt;引入如下的简化标记（梯度向量，Hessian 矩阵）：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\nabla f = g =&lt;br&gt;\begin{pmatrix}&lt;br&gt;\frac{\partial f}{\partial x_1} \\&lt;br&gt;\frac{\partial f}{\partial x_2} \\&lt;br&gt;\vdots \\&lt;br&gt;\frac{\partial f}{\partial x_N} \\&lt;br&gt;\end{pmatrix} \\&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\nabla ^2 f = H =&lt;br&gt;\begin{pmatrix}&lt;br&gt;\frac{\partial ^2 f}{\partial x_1 ^2} &amp;amp; \frac{\partial ^2 f}{\partial x_1\partial x_2} &amp;amp; \cdots &amp;amp; \frac{\partial ^2 f}{\partial x_1\partial x_N}\\&lt;br&gt;\frac{\partial ^2 f}{\partial x_2\partial x_1} &amp;amp; \frac{\partial ^2 f}{\partial x_2 ^2} &amp;amp; \cdots &amp;amp; \frac{\partial ^2 f}{\partial x_2\partial x_N}\\&lt;br&gt;\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots\\&lt;br&gt;\frac{\partial ^2 f}{\partial x_N\partial x_1} &amp;amp; \frac{\partial ^2 f}{\partial x_N\partial x_2} &amp;amp; \cdots &amp;amp; \frac{\partial ^2 f}{\partial x_N ^2}\\&lt;br&gt;\end{pmatrix}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;$\eqref{eq1}$ 的约等号两边分别对 X 求梯度，得到 $\nabla f(X) = g_k + H_k \cdot (X - X_k)$, 我们希望它的值为0，解出对应的 X，作为极值点的下一个估计 $X_{k+1} = X_k - H_k ^{-1} \cdot g_k$.&lt;/p&gt;
&lt;h3 id=&quot;Wolfe-Conditions&quot;&gt;&lt;a href=&quot;#Wolfe-Conditions&quot; class=&quot;headerlink&quot; title=&quot;Wolfe Conditions&quot;&gt;&lt;/a&gt;Wolfe Conditions&lt;/h3&gt;&lt;p&gt;在拟牛顿法中，实际的更新并不是严格按照上边的等式进行。为了保证每一步迭代之后，估计点更加逼近极值点（此处以极小值为例），我们采取一种 line search 的方法：$X_{k+1} = X_k - \lambda H_k ^{-1} \cdot g_k$，不改变其更新的方向，但是调整更新步长。这里的参数 α 需要满足所谓的 Wolfe 条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f(\mathbf{X}_k+\lambda\mathbf{p}_k)\leq f(\mathbf{X}_k)+c_1\lambda\mathbf{p}_k ^{\mathrm T}\nabla f(\mathbf{X}_k)$&lt;/li&gt;
&lt;li&gt;$\mathbf{p}_k ^{\mathrm T}\nabla f(\mathbf{X}_k+\lambda\mathbf{p}_k) \geq c_2\mathbf{p}_k ^{\mathrm T}\nabla f(\mathbf{X}_k)$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中 $\mathbf{p}_k = - H_k ^{-1} \cdot g_k$ 称作牛顿方向，$0 &amp;lt; c1 &amp;lt; c2 &amp;lt; 1$, 简单用自然语言解释下上面两个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;迭代之后的函数值确实减小了（此处考虑极小值问题，所以牛顿方向需要满足 $p_k ^T g_k &amp;lt; 0$），且至少以线性速率递减，c1 通常取一个很小的数，如 0.0001&lt;/li&gt;
&lt;li&gt;每次迭代之后，梯度以近似指数的速率缩小（考虑到两边均小于0），因而能向0趋近，c2 为衰减速率，因而取一个近似1的较大值即可，如 0.9&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样的性质固然很好，但是如何寻找满足如此复杂条件的步长呢？似乎并没有什么高效的办法。所以实际应用中，这个问题往往被近似为 $argmin_{\lambda} f(X_k + \lambda \mathbf{p}_k)$，这将容易数值求解。&lt;/p&gt;
&lt;p&gt;此外 Wolfe 条件被证明能够保留 Hessian 矩阵的估计值（将在后文出现）的正定性。&lt;/p&gt;
&lt;h3 id=&quot;Secant-Equation-amp-Quosi-Newton-Condition&quot;&gt;&lt;a href=&quot;#Secant-Equation-amp-Quosi-Newton-Condition&quot; class=&quot;headerlink&quot; title=&quot;Secant Equation &amp;amp; Quosi-Newton Condition&quot;&gt;&lt;/a&gt;Secant Equation &amp;amp; Quosi-Newton Condition&lt;/h3&gt;&lt;p&gt;考虑梯度函数在 $X_k$ 处的一阶泰勒展开，有 $\nabla f(X_k+\Delta X) \approx \nabla f(X_k)+H(X_k) \Delta X$，这被称作 Secant 等式，对应与牛顿法类似的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Secant_method&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Secant Method&lt;/a&gt;. 当步长足够小时，上式的直接推论： $g_{k+1} - g_k = H_{k+1} \cdot (X_{k+1} - X_k)$， 这被称为拟牛顿条件（Quosi-Newton condition）后面的拟牛顿法将利用这个等式来迭代地计算 H，从而降低复杂度。&lt;/p&gt;
&lt;h2 id=&quot;Broyden–Fletcher–Goldfarb–Shanno-algorithm&quot;&gt;&lt;a href=&quot;#Broyden–Fletcher–Goldfarb–Shanno-algorithm&quot; class=&quot;headerlink&quot; title=&quot;Broyden–Fletcher–Goldfarb–Shanno algorithm&quot;&gt;&lt;/a&gt;Broyden–Fletcher–Goldfarb–Shanno algorithm&lt;/h2&gt;&lt;p&gt;首先总结下牛顿法的求解思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给定初值 $X_0$ 和精度阈值e，k=0&lt;/li&gt;
&lt;li&gt;计算 $g_k, H_k$&lt;/li&gt;
&lt;li&gt;若 $||g_k|| &amp;lt; e$ 停止，否则计算牛顿方向 $\mathbf{p}_k = - H_k ^{-1} \cdot g_k$&lt;/li&gt;
&lt;li&gt;利用牛顿方向计算最优步长因子，$argmin_{\lambda} f(X_k + \lambda \mathbf{p}_k)$&lt;/li&gt;
&lt;li&gt;k++, goto step 2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;牛顿法的问题就是第二步的数值计算十分低效，PRML 的第五章花了不少篇幅讲解了在神经网络这样特殊的场景下如何利用 back propagation 高效的计算 Jacobian 和 Hessian 矩阵。&lt;/p&gt;
&lt;p&gt;一般场景下的做法是通过 Secant 等式来近似地迭代更新 Hessian 矩阵（或者其逆矩阵），于是步骤2的计算代价被大大降低，这样的方法称为 Quosi-Newton Method.&lt;/p&gt;
&lt;p&gt;由于篇幅的原因（其实是我懒得抄数学公式），我直接跳过比较古老的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Davidon–Fletcher–Powell_formula&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DFP 算法&lt;/a&gt;，直接介绍如今比较流行的 BFGS 和 L-BFGS.&lt;/p&gt;
&lt;p&gt;引入如下记号：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$s_k = X_{k+1} - X_k$&lt;/li&gt;
&lt;li&gt;$y_k = g_{k+1} - g_k$&lt;/li&gt;
&lt;li&gt;$B_k \approx H_k$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设每次迭代更新时，H 的增量满足如下形式 $\Delta B_k = \alpha uu ^T + \beta vv ^T$. 至于为何假设为这样的形式，我估计是出于以下考虑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果高阶导数均连续，则 H 矩阵为对称矩阵，参见 &lt;a href=&quot;https://en.wikipedia.org/wiki/Symmetry_of_second_derivatives#Clairaut.27s_theorem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Clairaut’s theorem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;保留正定性&lt;/li&gt;
&lt;li&gt;碰巧有满足拟牛顿条件的特殊解： $\Delta B_k = \frac{y_k y_k ^T}{y_k ^T s_k} - \frac{B_k s_k s_k ^T B_k}{s_k ^T B_k s_k}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是计算 H 的目标事实上是为了计算牛顿方向，这需要涉及到矩阵求逆运算，幸运的是，上面的迭代公式可以通过 &lt;a href=&quot;https://en.wikipedia.org/wiki/Woodbury\_matrix\_identity&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Woodbury formula&lt;/a&gt; 的特殊形式 &lt;a href=&quot;https://en.wikipedia.org/wiki/Sherman–Morrison\_formula&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sherman–Morrison formula&lt;/a&gt; 巧妙地转化为其逆矩阵的迭代公式：&lt;/p&gt;
&lt;p&gt;$$B_{k+1} ^{-1} = \left (I-\frac { s_k y_k ^T} {y_k ^T s_k} \right ) B_{k} ^{-1} \left (I-\frac { y_k s_k ^T} {y_k ^T s_k} \right )+\frac {s_k s_k ^T} {y_k ^T \, s_k} \\&lt;br&gt;= B_k ^{-1} + \frac{(\mathbf{s}_k ^{\mathrm{T}}\mathbf{y}_k+\mathbf{y}_k ^{\mathrm{T}} B_k ^{-1} \mathbf{y}_k)(\mathbf{s}_k \mathbf{s}_k ^{\mathrm{T}})}{(\mathbf{s}_k ^{\mathrm{T}} \mathbf{y}_k) ^2} - \frac{B_k ^{-1} \mathbf{y}_k \mathbf{s}_k ^{\mathrm{T}} + \mathbf{s}_k \mathbf{y}_k ^{\mathrm{T}}B_k ^{-1}}{\mathbf{s}_k ^{\mathrm{T}} \mathbf{y}_k}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;这样的计算是非常高效的，并且没有需要存储的中间结果矩阵。&lt;/p&gt;
&lt;p&gt;将上述牛顿法算法中的第2-3步中计算牛顿方向的方式换成 $\mathbf{p}_k = - B_{k} ^{-1} \cdot g_k$, 同时加入对 B 的迭代，即得到完整的 BFGS 算法。注意，此处的梯度依然是通过普通方法计算（解析解或者数值解）。&lt;/p&gt;
&lt;h3 id=&quot;L-BFGS&quot;&gt;&lt;a href=&quot;#L-BFGS&quot; class=&quot;headerlink&quot; title=&quot;L-BFGS&quot;&gt;&lt;/a&gt;L-BFGS&lt;/h3&gt;&lt;p&gt;考虑到当自变量的维度 N 过大时，存储 $B_k ^{-1}$ 需要过多的存储资源，于是便有了 L-BFGS 这样的改版算法，在该算法中，并不存储完整的 Hessian 矩阵的逆矩阵的近似值，而是通过存储 2m 个 N 维向量（最近m 个 s 和 y）来近似还原它。如果令：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\rho_k = \frac{1}{y_k ^Ts_k}$&lt;/li&gt;
&lt;li&gt;$V_k = I - \rho_ky_ks_k ^T$&lt;/li&gt;
&lt;li&gt;$D_k = B_k ^{-1}$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;反复利用 BFGS 的递推公式可以得到：&lt;/p&gt;
&lt;span&gt;$$D\_{k+1} = (V\_k ^TV\_{k-1} ^T \cdots V\_{k-m+1} ^T)D\_{k-m+1}(V\_{k-m+1} \cdots V\_{k-1}V\_k) \\\\
    + (V\_k ^TV\_{k-1} ^T \cdots V\_{k-m+2} ^T)(\rho\_{k-m+1}s\_{k-m+1}s\_{k-m+1} ^T)(V\_{k-m+2} \cdots V\_{k-1}V\_k) \\\\
    + (V\_k ^TV\_{k-1} ^T \cdots V\_{k-m+3} ^T)(\rho\_{k-m+2}s\_{k-m+2}s\_{k-m+2} ^T)(V\_{k-m+3} \cdots V\_{k-1}V\_k) \\\\
    + ... \\\\
    + (V\_k ^TV\_{k-1} ^T)(\rho\_{k-2}s\_{k-2}s\_{k-2} ^T)(V\_{k-1}V\_k) \\\\
    + V\_k ^T(\rho\_{k-1}s\_{k-1}s\_{k-1} ^T)V\_k \\\\
    + \rho\_ks\_ks\_k ^T$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;p&gt;于是只需要对 $D_{k-m+1}$ 作出估计即可近似地计算出牛顿方向，通常取 $D_{k-m+1} = \frac{s_k ^T y_k}{y_k ^T y_k} I$.&lt;/p&gt;
&lt;h2 id=&quot;Conjugate-Gradient-Method&quot;&gt;&lt;a href=&quot;#Conjugate-Gradient-Method&quot; class=&quot;headerlink&quot; title=&quot;Conjugate Gradient Method&quot;&gt;&lt;/a&gt;Conjugate Gradient Method&lt;/h2&gt;&lt;p&gt;既然提到了拟牛顿法，就顺便提一下另一种高效的非线性优化算法——共轭梯度法。&lt;/p&gt;
&lt;h3 id=&quot;Steepest-Gradient-Descent&quot;&gt;&lt;a href=&quot;#Steepest-Gradient-Descent&quot; class=&quot;headerlink&quot; title=&quot;Steepest Gradient Descent&quot;&gt;&lt;/a&gt;Steepest Gradient Descent&lt;/h3&gt;&lt;p&gt;最 Naive 的非线性优化思路是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;寻找函数在点 X 的梯度 $\nabla f(X)$&lt;/li&gt;
&lt;li&gt;沿梯度反方向作 line search，寻找更新步长 $argmin_{\lambda} f(X - \lambda \nabla f(X))$&lt;/li&gt;
&lt;li&gt;根据2的结果更新 X，重复1-2直至收敛&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个算法的低效源于：在极值点附近，梯度方向往往并不指向极值（存在某种形变），对应与下图中的绿色折线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Conjugate_gradient.png&quot; alt=&quot;sgd&quot;&gt;&lt;/p&gt;
&lt;p&gt;所以共轭梯度法的基本思路就是将这样的形变考虑在内，通过变化更新方向来抵消影响, 如上图中的红线。&lt;/p&gt;
&lt;h3 id=&quot;Approximate-Linear-Equation&quot;&gt;&lt;a href=&quot;#Approximate-Linear-Equation&quot; class=&quot;headerlink&quot; title=&quot;Approximate Linear Equation&quot;&gt;&lt;/a&gt;Approximate Linear Equation&lt;/h3&gt;&lt;p&gt;由于任意的二阶可导函数在极值点附近近似为一个二次型（通过泰勒展开容易得到），而这样的二次型近似可以大致捕获上边描述的形变，因此我们首先来考虑二次型的极小值问题：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;f(X) = \frac12 X ^\mathrm{T} \mathbf{A}X - X ^\mathrm{T} \mathbf{b} , \quad X\in\mathbf{R} ^n.&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;令其梯度为0，我们得到极值点方程：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\mathbf{AX_*} = \mathbf{b}\tag{2}\label{eq2}&lt;br&gt;$$.&lt;/p&gt;
&lt;h3 id=&quot;A-conjugate-Vectors&quot;&gt;&lt;a href=&quot;#A-conjugate-Vectors&quot; class=&quot;headerlink&quot; title=&quot;A-conjugate Vectors&quot;&gt;&lt;/a&gt;A-conjugate Vectors&lt;/h3&gt;&lt;p&gt;将向量的内积进行扩展，定义 A-dot: $\mathbf{u}^\mathrm{T} \mathbf{A} \mathbf{v}$. 向量 u, v 被称为 A-conjugate iff 其 A-dot 为零，或称 A-orthogonal, 显然这个二元关系满足交换律。下面考虑这个定义在上述优化问题中的意义。&lt;/p&gt;
&lt;p&gt;设 $X_*$ 为待求的上述目标函数的极小值点，则 $f(X) = \frac12 (X - X_*) ^{\mathrm{T}} \mathbf{A} (X - X_*)$&lt;/p&gt;
&lt;p&gt;考虑极值点附近的等势图（如上图），对于 $X_1$，它是从 $X_0$ 出发作 line search 之后得到的最小值点，则向量 $\mathbf{u} = X_1 - X_0$ 必与某个等势线相切，$X_1$ 为切点。由于该处的梯度向量为 $\nabla{f(X_1)} = \mathbf{A} (X_1 - X_*) = \mathbf{A v}$，得到相切关系方程：$\mathbf{u}^\mathrm{T} \mathbf{A} \mathbf{v} = 0$. 换句话说，沿某个方向（如梯度反方向）找到极小值点之后，下一步更新的方向应该选其共轭方向。对于二维，二次型函数，这样的两步更新必能找到极值点；同理对于 N 维的情形，只需 N 步，更新方向两两共轭，这一点稍后会简要分析。&lt;/p&gt;
&lt;p&gt;所以，从上面的分析可以看出，共轭方向的实质是引导更新方向重新指向极值点，从而减少更新步骤，提高效率。那么接下来的问题是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何选择共轭方向？&lt;/li&gt;
&lt;li&gt;如何计算每一步的更新步长？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Iterative-Method&quot;&gt;&lt;a href=&quot;#Iterative-Method&quot; class=&quot;headerlink&quot; title=&quot;Iterative Method&quot;&gt;&lt;/a&gt;Iterative Method&lt;/h3&gt;&lt;p&gt;首先，不失一致性（座标平移），设 $X_0 = 0$. 下面回答上边提出的两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方向选择&lt;ol&gt;
&lt;li&gt;初始时，我们选取的更新方向为 $\mathbf{p}_0 = -\nabla{f(X_0)} = \mathbf{b} - \mathbf{A} X_0$，&lt;/li&gt;
&lt;li&gt;之后将依次选择接近于 $\mathbf{r}_k = \nabla{f(X_k)}$, 且与之前的更新方向均共轭的方向 $\mathbf{p}_k$&lt;/li&gt;
&lt;li&gt;更新的方法类似于正交基的选取，$\mathbf{p}_{k} = \mathbf{r}_{k} - \sum_{i &amp;lt; k}\frac{\mathbf{p}_i ^\mathrm{T} \mathbf{A} \mathbf{r}_{k}}{\mathbf{p}_i ^\mathrm{T}\mathbf{A} \mathbf{p}_i} \mathbf{p}_i$, 即需要从负梯度方向中减去它在之前各个更新方向中的 A-projection. 参见 &lt;a href=&quot;https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gram–Schmidt process&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;更新步长&lt;ol&gt;
&lt;li&gt;由于初始点选为 0 点，所以有 $X_k = \sum\limits_{i &amp;lt; k} \lambda_k \mathbf{p}_k$, 于是 $\mathbf{p}_k ^{\mathrm{T}} \mathbf{A} X_k = 0$. 即每一步的更新方向与此刻 X 所在的方向共轭。&lt;/li&gt;
&lt;li&gt;计算 $argmin_{\lambda_k} - \frac12 (X_k + \lambda_k \mathbf{p}_k) ^{\mathrm{T}} A (X_k + \lambda_k \mathbf{p}_k) + \mathbf{b}(X_k + \lambda_k \mathbf{p}_k)$&lt;/li&gt;
&lt;li&gt;令上式对 $\lambda_k$ 的偏导为0，并结合1中得出的共轭结论，容易得到更新步长的解析解：&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$&lt;br&gt;\lambda_{k} = \frac{\mathbf{p}_k ^\mathrm{T} \mathbf{b}}{\mathbf{p}_k ^\mathrm{T} \mathbf{A} \mathbf{p}_k} = \frac{\mathbf{p}_k ^\mathrm{T} (\mathbf{r}_{k-1}+\mathbf{Ax}_{k-1})}{\mathbf{p}_{k} ^\mathrm{T} \mathbf{A} \mathbf{p}_{k}} = \frac{\mathbf{p}_{k} ^\mathrm{T} \mathbf{r}_{k-1}}{\mathbf{p}_{k} ^\mathrm{T} \mathbf{A} \mathbf{p}_{k}}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;根据上式可以看出，每一步的更新量为向量 &lt;strong&gt;b&lt;/strong&gt; 在 $\mathbf{p}_k$ 方向上的 A-projection. 恰好初始点为0，又极值点满足 $\eqref{eq2}$, 因此各个更新量正好构成了 $X_*$ 在 ${\mathbf{p}_k}$ 这组共轭正交基上的分解，因此只需至多 N 步更新即可找到极值点，具体的形式化推导参见维基百科。&lt;/p&gt;
&lt;h3 id=&quot;Tuning&quot;&gt;&lt;a href=&quot;#Tuning&quot; class=&quot;headerlink&quot; title=&quot;Tuning&quot;&gt;&lt;/a&gt;Tuning&lt;/h3&gt;&lt;p&gt;上面的算法存在的问题在于，计算新方向时，需要记录各个共轭方向的历史信息，当 N 很大时，消耗过多的存储资源，因此共轭梯度法在实际应用时采用某种近似的手段来进行优化，使得只需要记录最近一次的3个向量$X_k, \mathbf{p}_k, \mathbf{r}_k$，如 Fletcher–Reeves 算法，其推导及相关公式参见维基百科。对于一般的非线性优化问题，通用的算法框架如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算负梯度方向&lt;/li&gt;
&lt;li&gt;根据 Fletcher-Reever 公式（或其它变种）计算方向变化量&lt;/li&gt;
&lt;li&gt;根据1,2的结果以及“上一个共轭方向”计算新的共轭方向&lt;/li&gt;
&lt;li&gt;在新的方向上作 line search 找到合适步长&lt;/li&gt;
&lt;li&gt;更新 X&lt;/li&gt;
&lt;li&gt;重复 1-5 直至收敛&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与拟牛顿法相较而言，共轭梯度法的收敛速度要慢一些，但依然比普通的梯度下降法要迅速得多，因而不失为一个好的选择。而且由于它所需的存储资源远小于拟牛顿法（即便是 L-BFGS 也需要 O(2mN)), 格外适用于维度极大的优化问题。&lt;/p&gt;
&lt;h2 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quasi-Newton_method&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Quasi-Newton method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Broyden–Fletcher–Goldfarb–Shanno_algorithm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Broyden–Fletcher–Goldfarb–Shanno algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Conjugate_gradient_method&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Conjugate gradient method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Nonlinear conjugate gradient method&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;最近在以蜗牛般的速度啃 PRML。第五章提到了拟牛顿法，这玩意我之前大致意会过，并作了一些笔记，然而我完全无法回忆起来，于是翻出之前的笔记重新意会了一遍，顺便更正了之前一些不太正确的理解，总结整理成下文。&lt;/p&gt;
&lt;h2 id=&quot;Newton’s-Method&quot;&gt;&lt;a href=&quot;#Newton’s-Method&quot; class=&quot;headerlink&quot; title=&quot;Newton’s Method&quot;&gt;&lt;/a&gt;Newton’s Method&lt;/h2&gt;&lt;p&gt;考虑求自变量 X 为 N 维向量的函数 $f(X)$ 的极值点问题。我们知道高中数学中的牛顿法可以用于求解函数0点的：$X_{k+1} = X_n - [J_f(X_k)] ^{-1}f(X_k)$. 那么可导函数的极值问题其实就是求其导函数的0点问题，同样可以用牛顿法求解。&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://farseer.cn/categories/ML/"/>
    
    
      <category term="math" scheme="http://farseer.cn/tags/math/"/>
    
      <category term="machine learning" scheme="http://farseer.cn/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>Add TOC indexes to PDF</title>
    <link href="http://farseer.cn/2015/08/22/add-toc-indexes-to-pdf/"/>
    <id>http://farseer.cn/2015/08/22/add-toc-indexes-to-pdf/</id>
    <published>2015-08-21T16:00:00.000Z</published>
    <updated>2016-02-17T02:32:34.167Z</updated>
    
    <content type="html">&lt;h2 id=&quot;PDF-books-without-Indexes-are-like-Planets-with-Individuals&quot;&gt;&lt;a href=&quot;#PDF-books-without-Indexes-are-like-Planets-with-Individuals&quot; class=&quot;headerlink&quot; title=&quot;PDF books without Indexes are like Planets with Individuals&quot;&gt;&lt;/a&gt;PDF books without Indexes are like Planets with Individuals&lt;/h2&gt;&lt;p&gt;I prefer e-books to paper books, actually I may have read only 1-2 paper books in recent 3 years, while e-books of a much larger amount. The pros of e-books are really obvious:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;portability&lt;/li&gt;
&lt;li&gt;context can be copied&lt;/li&gt;
&lt;li&gt;easy to manage&lt;/li&gt;
&lt;li&gt;easy to navigate&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I don’t want to argue about the superiorities here. I just wanna to convey that the 4th feature is a crucial one, and it is mainly achieved via indexes, bookmarks, reference links, etc. There’s no doubt that among those approaches, indexes play the most significant role. So I say that e-books without indexes are like planets with individuals, i.e. huge gaps among separated pieces of text.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Indexes-Instrumentality-Project&quot;&gt;&lt;a href=&quot;#Indexes-Instrumentality-Project&quot; class=&quot;headerlink&quot; title=&quot;Indexes Instrumentality Project&quot;&gt;&lt;/a&gt;Indexes Instrumentality Project&lt;/h2&gt;&lt;p&gt;Well, if you encounter such planets, &lt;code&gt;Don&amp;#39;t Panic!&lt;/code&gt; Please pick up the holy weapons, smash the individuals and reunite them as a strongly connected conglomerate. You may need to carry these handy weapons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;vim&lt;/li&gt;
&lt;li&gt;pdftk&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;First-Impact&quot;&gt;&lt;a href=&quot;#First-Impact&quot; class=&quot;headerlink&quot; title=&quot;First Impact&quot;&gt;&lt;/a&gt;First Impact&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Dissect the “&lt;a href=&quot;http://wiki.evageeks.org/Black_Moon&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Black Moon&lt;/a&gt;“ to get the seed of life &lt;a href=&quot;http://wiki.evageeks.org/Lilith&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lilith&lt;/a&gt;, &lt;code&gt;pdftk earth.pdf dump_data &amp;gt; Lilith&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Next, form the &lt;a href=&quot;http://wiki.evageeks.org/A.T._Field&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A.T. Field&lt;/a&gt;, simply copy the catalog from the file. If it’s a scanned version, some kind of OCR weapon will help&lt;/li&gt;
&lt;li&gt;Use vim to reshape (macros shall be helpful) the A.T. Field into the form of human egos, A.K.A. 心の壁:&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 Chap1:title                 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.1 Chap1-Sec1:title          4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.1.1 Chap1-Sec1-Para1:title  9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.1.2 xxxx                    10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 Chap2:title                 20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Destroy-the-A-T-Field-of-egos&quot;&gt;&lt;a href=&quot;#Destroy-the-A-T-Field-of-egos&quot; class=&quot;headerlink&quot; title=&quot;Destroy the A.T. Field of egos&quot;&gt;&lt;/a&gt;Destroy the A.T. Field of egos&lt;/h3&gt;&lt;p&gt;Piercing human egos with the &lt;a href=&quot;http://wiki.evageeks.org/Spear_of_Longinus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spear of Longinus&lt;/a&gt; (vimscript):&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;:&#39;&amp;lt;,&#39;&amp;gt;s#\v(\s*)([0-9.]+ )(.* )(\d+)#\=&quot;BookmarkBegin\rBookmarkTitle: &quot;.submatch(2).submatch(3).&quot;\rBookmarkLevel: &quot;.len(split(submatch(2), &#39;\.&#39;)).&quot;\rBookmarkPageNumber: &quot;.(submatch(4)+offset)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;After that, souls of the following form will occur:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BookmarkBegin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkTitle: 1 Chap1:title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkLevel: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkPageNumber: 16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkBegin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkTitle: 1.1 Chap1-Sec1:title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkLevel: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkPageNumber: 19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkBegin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkTitle: 1.1.1 Chap1-Sec1-Para1:title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkLevel: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkPageNumber: 24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkBegin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkTitle: 1.1.2 xxxx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkLevel: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkPageNumber: 25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkBegin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkTitle: 2 Chap2:title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkLevel: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BookmarkPageNumber: 35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Here the “offset” is taken as 15, which means the very first page of the book lies in the 16th page of the PDF file due to the tedious bullshit at the beginning.&lt;/li&gt;
&lt;li&gt;If no section numbers provided, indentations will be good indicators of the bookmark levels&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Third-Impact&quot;&gt;&lt;a href=&quot;#Third-Impact&quot; class=&quot;headerlink&quot; title=&quot;Third Impact&quot;&gt;&lt;/a&gt;Third Impact&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Souls shall be gathered into Lilith’s egg, &lt;code&gt;cat souls &amp;gt;&amp;gt; Lilith&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Unite as a single existence, &lt;code&gt;pdftk earth.pdf update_info Lilith output reborn.pdf&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Done.&lt;/p&gt;
&lt;h2 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://vimdoc.sourceforge.net/htmldoc/change.html#sub-replace-expression&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vimdoc sub-replace-expression&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.pdflabs.com/docs/pdftk-man-page/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pdftk-man-page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.evangelion.co.jp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;新世紀エヴァンゲリオン&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PDF-books-without-Indexes-are-like-Planets-with-Individuals&quot;&gt;&lt;a href=&quot;#PDF-books-without-Indexes-are-like-Planets-with-Individuals&quot; class=&quot;headerlink&quot; title=&quot;PDF books without Indexes are like Planets with Individuals&quot;&gt;&lt;/a&gt;PDF books without Indexes are like Planets with Individuals&lt;/h2&gt;&lt;p&gt;I prefer e-books to paper books, actually I may have read only 1-2 paper books in recent 3 years, while e-books of a much larger amount. The pros of e-books are really obvious:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;portability&lt;/li&gt;
&lt;li&gt;context can be copied&lt;/li&gt;
&lt;li&gt;easy to manage&lt;/li&gt;
&lt;li&gt;easy to navigate&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I don’t want to argue about the superiorities here. I just wanna to convey that the 4th feature is a crucial one, and it is mainly achieved via indexes, bookmarks, reference links, etc. There’s no doubt that among those approaches, indexes play the most significant role. So I say that e-books without indexes are like planets with individuals, i.e. huge gaps among separated pieces of text.&lt;/p&gt;
    
    </summary>
    
      <category term="tweak" scheme="http://farseer.cn/categories/tweak/"/>
    
    
      <category term="vim" scheme="http://farseer.cn/tags/vim/"/>
    
      <category term="EVA" scheme="http://farseer.cn/tags/EVA/"/>
    
      <category term="中二病" scheme="http://farseer.cn/tags/%E4%B8%AD%E4%BA%8C%E7%97%85/"/>
    
  </entry>
  
  <entry>
    <title>SVD++ Implementation in GraphX</title>
    <link href="http://farseer.cn/2015/08/16/svd-implementation-in-graphx/"/>
    <id>http://farseer.cn/2015/08/16/svd-implementation-in-graphx/</id>
    <published>2015-08-15T16:00:00.000Z</published>
    <updated>2016-02-17T02:38:31.316Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Clarification&quot;&gt;&lt;a href=&quot;#Clarification&quot; class=&quot;headerlink&quot; title=&quot;Clarification&quot;&gt;&lt;/a&gt;Clarification&lt;/h2&gt;&lt;p&gt;写完之后我突然发现这个标题看上去貌似有“以下实现是由本人完成的”这样的误导，所以特此澄清，下文出现的代码统统摘自&lt;br&gt; &lt;a href=&quot;https://github.com/apache/spark.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;apache/spark&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;SVD-Intro&quot;&gt;&lt;a href=&quot;#SVD-Intro&quot; class=&quot;headerlink&quot; title=&quot;SVD++ Intro&quot;&gt;&lt;/a&gt;SVD++ Intro&lt;/h2&gt;&lt;p&gt;首先简单介绍 SVD++ 算法在协同过滤中的应用及其数学直觉。&lt;/p&gt;
&lt;h3 id=&quot;SVD-in-CF&quot;&gt;&lt;a href=&quot;#SVD-in-CF&quot; class=&quot;headerlink&quot; title=&quot;SVD in CF&quot;&gt;&lt;/a&gt;SVD in CF&lt;/h3&gt;&lt;p&gt;考虑 CF 中最为常见的用户给电影评分的场景，我们需要一个数学模型来模拟用户给电影打分的场景，i.e. 对评分进行预测。&lt;/p&gt;
&lt;p&gt;一个 Naive 的方案可以是将评分矩阵看作是两个矩阵的乘积：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;U = \begin{bmatrix}&lt;br&gt;u_{11} &amp;amp; \cdots &amp;amp; u_{1k} \\&lt;br&gt;\vdots &amp;amp; \ddots &amp;amp; \vdots \\&lt;br&gt;u_{m1} &amp;amp; \cdots &amp;amp; u_{mk}&lt;br&gt;\end{bmatrix}&lt;br&gt;\begin{bmatrix}&lt;br&gt;i_{11} &amp;amp; \cdots &amp;amp; i_{1n} \\&lt;br&gt;\vdots &amp;amp; \ddots &amp;amp; \vdots \\&lt;br&gt;i_{k1} &amp;amp; \cdots &amp;amp; i_{kn}&lt;br&gt;\end{bmatrix}&lt;br&gt;$$.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;其中的 $u_{xy}$ 可以看作是 user x 对电影的隐藏特质 y 的热衷程度，而 $i_{yz}$ 可以看作是特质 y 在电影 z 中的体现程度。那么上述模型的评分预测公式为：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\hat{r}_{ui} = q_i ^T p_u&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;q 和 p 分别对应了电影和用户在各个隐藏特质上的特征向量。&lt;/p&gt;
&lt;p&gt;以上的模型中，用户和电影都体现得无差别，例如某些用户非常挑剔，总是给予很低的评分；或是某部电影拍得奇烂，恶评如潮。为了模拟以上的情况，需要引入 baseline predictor.&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\hat{r}_{ui} = \mu + b_i + b_u + q_i ^T p_u&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;其中 μ 为所有评分基准，$b_i$ 为电影 i 的评分均值相对 μ 的偏移，$b_u$ 类似。注意，这些均为参数，需要通过训练得到具体数值，不过可以用相应的均值作为初始化时的估计。&lt;/p&gt;
&lt;h3 id=&quot;SVD&quot;&gt;&lt;a href=&quot;#SVD&quot; class=&quot;headerlink&quot; title=&quot;SVD++&quot;&gt;&lt;/a&gt;SVD++&lt;/h3&gt;&lt;p&gt;某个用户对某个电影进行了评分，那么说明他看过这部电影，那么这样的行为事实上蕴含了一定的信息，因此我们可以这样来理解问题：评分的行为从侧面反映了用户的喜好，可以将这样的反映通过隐式参数的形式体现在模型中，从而得到一个更为精细的模型，便是 SVD++.&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\hat{r}_{ui} = \mu + b_i + b_u + (p_u + \frac{1}{\sqrt{|N(u)|}}\sum_{j\in N(u)} y_j ) ^T q_i \tag{1}\label{eq1}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;其中 N(u) 为该用户所评价过的所有电影的集合，$y_j$ 为隐藏的“评价了电影 j”反映出的个人喜好偏置。收缩因子取集合大小的根号是一个经验公式，并没有理论依据。&lt;/p&gt;
&lt;p&gt;事实上隐式返回的形式可以是多样的，例如可以考虑一个用户的相邻用户对其产生的影响，这在Koren 的原始论文中也有提及，他甚至在最后提到了一个整合了两者的模型。&lt;/p&gt;
&lt;p&gt;但是有些方式在实际应用中存在问题，比如我们反过来考虑用户的评价行为对电影特征的影响就不合适，这是因为实际应用中用户数量往往是远大于电影数量的，这么做会引入过多的隐式参数，导致模型在训练的时候难以收敛。&lt;/p&gt;
&lt;p&gt;我们暂且只关注上面公式对应的隐式模型，因为后文关心的 GraphX 中的实现如此。&lt;/p&gt;
&lt;h3 id=&quot;Training&quot;&gt;&lt;a href=&quot;#Training&quot; class=&quot;headerlink&quot; title=&quot;Training&quot;&gt;&lt;/a&gt;Training&lt;/h3&gt;&lt;p&gt;有了上述的模型，我们的训练目标非常明确，即最小化 RMSE:&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;min_{q_*,x_*,y_*,b_*,} \sum\limits_{(u, i) \in \mathfrak{K}} (r_{ui}-\hat{r}_{ui}) ^2 + \lambda_6(b_u ^2 + b_i ^2) + \lambda_7(||q_i|| ^2 + ||p_u|| ^2 + ||y_j|| ^2)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;后两项为正规化因子，为了避免过拟合，之所以选这么诡异的下标，是为了跟 GraphX 中的实现对应，事实上该实现是参照了原论文中的命名，只可惜搞乱了希腊字母 lambda 和 gamma，Whatever…&lt;/p&gt;
&lt;p&gt;带入 $\eqref{eq1}$ 后求偏导，容易得到如下的学习公式：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;e_{ui} \overset{def}{=} r_{ui} - \hat{r}_{ui} \\&lt;br&gt;b_u \gets b_u + \gamma_1 \cdot (e_{ui} - \lambda_6 \cdot b_u) \\&lt;br&gt;b_i \gets b_i + \gamma_1 \cdot (e_{ui} - \lambda_6 \cdot b_i) \\&lt;br&gt;q_i \gets q_i + \gamma_2 \cdot (e_{ui} \cdot (p_u + |N(u)| ^{-\frac{1}{2}} \sum_{j \in N(u)} y_j) - \lambda_7 \cdot q_i) \\&lt;br&gt;p_u \gets p_u + \gamma_2 \cdot (e_{ui} \cdot q_i - \lambda_7 \cdot p_u) \\&lt;br&gt;\forall j \in N(u): y_j \gets y_j + \gamma_2 \cdot (e_{ui} \cdot |N(u)| ^{-\frac{1}{2}} \cdot q_i - \lambda_7 \cdot y_j)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;此处选取了两种学习速率。&lt;/p&gt;
&lt;h2 id=&quot;Implementation-in-GraphX&quot;&gt;&lt;a href=&quot;#Implementation-in-GraphX&quot; class=&quot;headerlink&quot; title=&quot;Implementation in GraphX&quot;&gt;&lt;/a&gt;Implementation in GraphX&lt;/h2&gt;&lt;p&gt;GraphX 是 Apache Spark 中的图计算框架，SVD++ 算法以一种图的形式在其中得到了实现。基本思路：将用户和电影看作两种节点，打分看作是连接对应节点的边，从而得到一个二分图。更具体的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户节点 u 具有四元组属性 $(p_u, p_u + |N(u)| ^{-\frac{1}{2}} \cdot \sum\limits_{j \in N(u)} y_j, b_u, |N(u)| ^{-\frac{1}{2}})$&lt;/li&gt;
&lt;li&gt;电影（姑且这么叫）节点 i 具有四元组属性 $(q_i, y_i, b_i, *)$&lt;/li&gt;
&lt;li&gt;边节点具有属性 $r_{ui}$，边的源节点为 u，目标节点为 i&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实了解了上述设定之后源码便容易理解了，下面具体展开一下。&lt;/p&gt;
&lt;h3 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h3&gt;&lt;p&gt;首先看下入口函数的类型：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;/span&gt;(edges: &lt;span class=&quot;type&quot;&gt;RDD&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;]], conf: &lt;span class=&quot;type&quot;&gt;Conf&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : (&lt;span class=&quot;type&quot;&gt;Graph&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;), &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;函数参数为一个包含了所有的评分的 RDD，需要转化成 Edge 的数据结构，可以简单理解为三元组 (u, i, rate).&lt;/li&gt;
&lt;li&gt;函数的返回值为一个二元组，第1元为训练之后得到的图，图中的各个节点包括了训练之后得到的各个参数&lt;ul&gt;
&lt;li&gt;向量以数组的形式存储&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二元为所有评分的均值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Initialization&quot;&gt;&lt;a href=&quot;#Initialization&quot; class=&quot;headerlink&quot; title=&quot;Initialization&quot;&gt;&lt;/a&gt;Initialization&lt;/h3&gt;&lt;p&gt;首先计算 baseline predictor 的初始值（各种均值），以及随机初始化各个个性向量。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Generate default vertex attribute&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;defaultF&lt;/span&gt;&lt;/span&gt;(rank: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;): (&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;) = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// &lt;span class=&quot;doctag&quot;&gt;TODO:&lt;/span&gt; use a fixed random seed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; v1 = &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;.fill(rank)(&lt;span class=&quot;type&quot;&gt;Random&lt;/span&gt;.nextDouble())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; v2 = &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;.fill(rank)(&lt;span class=&quot;type&quot;&gt;Random&lt;/span&gt;.nextDouble())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (v1, v2, &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// calculate global rating mean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;edges.cache()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; (rs, rc) = edges.map(e =&amp;gt; (e.attr, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;L)).reduce((a, b) =&amp;gt; (a._1 + b._1, a._2 + b._2))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; u = rs / rc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// construct graph&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; g = &lt;span class=&quot;type&quot;&gt;Graph&lt;/span&gt;.fromEdges(edges, defaultF(conf.rank)).cache()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;materialize(g)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;edges.unpersist()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Calculate initial bias and norm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; t0 = g.aggregateMessages[(&lt;span class=&quot;type&quot;&gt;Long&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;)](&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ctx =&amp;gt; &amp;#123; ctx.sendToSrc((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;L, ctx.attr)); ctx.sendToDst((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;L, ctx.attr)) &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (g1, g2) =&amp;gt; (g1._1 + g2._1, g1._2 + g2._2))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; gJoinT0 = g.outerJoinVertices(t0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (vid: &lt;span class=&quot;type&quot;&gt;VertexId&lt;/span&gt;, vd: (&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    msg: &lt;span class=&quot;type&quot;&gt;Option&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;Long&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;)]) =&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (vd._1, vd._2, msg.get._2 / msg.get._1 - u, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; / scala.math.sqrt(msg.get._1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;.cache()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;materialize(gJoinT0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g.unpersist()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g = gJoinT0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;9-12: 首先计算 μ, 在输入的 RDD 上作简单的 MapReduce 即可&lt;/li&gt;
&lt;li&gt;14-17: 从边生成图 g，节点的属性全部为 defaultF 函数生成的随机初始值，将图进行存储，并释放边的 RDD （后续类似操作的描述在下文中省略）&lt;/li&gt;
&lt;li&gt;19-22: 通过聚合消息，得到一个拓扑一致的图，图中的节点属性为 &lt;code&gt;(num(rates), sum(rates))&lt;/code&gt;，用于计算个体均值来初始化 $b_i = \sum(r_{*i})/num(r_{*i}) - u, b_u = \sum(r_{u*})/num(r_{u*}) - u$ （事实上并不是图，而是一个包含了节点 ID 及其接收到的消息的 RDD，具体的类型请参见官方文档）&lt;/li&gt;
&lt;li&gt;24-31: 通过将两个图进行合并，更新 g 中对应的属性值，函数无副作用，因此要重命名&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Trainning-Through-Messages&quot;&gt;&lt;a href=&quot;#Trainning-Through-Messages&quot; class=&quot;headerlink&quot; title=&quot;Trainning Through Messages&quot;&gt;&lt;/a&gt;Trainning Through Messages&lt;/h3&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sendMsgTrainF&lt;/span&gt;&lt;/span&gt;(conf: &lt;span class=&quot;type&quot;&gt;Conf&lt;/span&gt;, u: &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (ctx: &lt;span class=&quot;type&quot;&gt;EdgeContext&lt;/span&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; (usr, itm) = (ctx.srcAttr, ctx.dstAttr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; (p, q) = (usr._1, itm._1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; rank = p.length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; pred = u + usr._3 + itm._3 + blas.ddot(rank, q, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, usr._2, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pred = math.max(pred, conf.minVal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pred = math.min(pred, conf.maxVal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; err = ctx.attr - pred&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// updateP = (err * q - conf.gamma7 * p) * conf.gamma2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; updateP = q.clone()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blas.dscal(rank, err * conf.gamma2, updateP, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blas.daxpy(rank, -conf.gamma7 * conf.gamma2, p, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, updateP, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// updateQ = (err * usr._2 - conf.gamma7 * q) * conf.gamma2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; updateQ = usr._2.clone()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blas.dscal(rank, err * conf.gamma2, updateQ, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blas.daxpy(rank, -conf.gamma7 * conf.gamma2, q, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, updateQ, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// updateY = (err * usr._4 * q - conf.gamma7 * itm._2) * conf.gamma2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; updateY = q.clone()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blas.dscal(rank, err * usr._4 * conf.gamma2, updateY, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blas.daxpy(rank, -conf.gamma7 * conf.gamma2, itm._2, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, updateY, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ctx.sendToSrc((updateP, updateY, (err - conf.gamma6 * usr._3) * conf.gamma1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ctx.sendToDst((updateQ, updateY, (err - conf.gamma6 * itm._3) * conf.gamma1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;该函数的作用是利用上边分析得到的学习公式，以边为单位，以消息的形式，逐个对节点参数进行调整&lt;/li&gt;
&lt;li&gt;此处仅仅是计算更新，发送消息，稍后进行消息的聚合，参数的更新&lt;/li&gt;
&lt;li&gt;更新公式与上文完全对应，不再展开，有趣的是，原论文中的 lambda6 和 lambda7 在此处被混为了 gamma，事实上这并不符合规范，正则化参数通常应该写作 lambda，Whatever…&lt;/li&gt;
&lt;li&gt;参数 conf 为训练参数，包括：&lt;ul&gt;
&lt;li&gt;rank: 表示隐藏特质的个数，即矩阵的维度 k&lt;/li&gt;
&lt;li&gt;maxIters: 迭代次数上限，此处的实现是确确实实地执行到该上限，不会提前判断是否收敛&lt;/li&gt;
&lt;li&gt;gamma1-2: 表示两个学习速率&lt;/li&gt;
&lt;li&gt;gamma6-7: 表示两个正则化参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Updating-Properties&quot;&gt;&lt;a href=&quot;#Updating-Properties&quot; class=&quot;headerlink&quot; title=&quot;Updating Properties&quot;&gt;&lt;/a&gt;Updating Properties&lt;/h3&gt;&lt;p&gt;执行如下的更新步骤 maxIters 次：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Phase 1, calculate pu + |N(u)|^(-0.5)*sum(y) for user nodes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g.cache()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; t1 = g.aggregateMessages[&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;]](&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctx =&amp;gt; ctx.sendToSrc(ctx.dstAttr._2),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(g1, g2) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; out = g1.clone()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blas.daxpy(out.length, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, g2, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, out, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    out&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; gJoinT1 = g.outerJoinVertices(t1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(vid: &lt;span class=&quot;type&quot;&gt;VertexId&lt;/span&gt;, vd: (&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    msg: &lt;span class=&quot;type&quot;&gt;Option&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;]]) =&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (msg.isDefined) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; out = vd._1.clone()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blas.daxpy(out.length, vd._4, msg.get, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, out, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (vd._1, out, vd._3, vd._4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;.cache()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;materialize(gJoinT1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g.unpersist()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g = gJoinT1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Phase 2, update p for user nodes and q, y for item nodes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g.cache()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; t2 = g.aggregateMessages(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sendMsgTrainF(conf, u),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(g1: (&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;), g2: (&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;)) =&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; out1 = g1._1.clone()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blas.daxpy(out1.length, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, g2._1, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, out1, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; out2 = g2._2.clone()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blas.daxpy(out2.length, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, g2._2, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, out2, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (out1, out2, g1._3 + g2._3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; gJoinT2 = g.outerJoinVertices(t2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(vid: &lt;span class=&quot;type&quot;&gt;VertexId&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vd: (&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    msg: &lt;span class=&quot;type&quot;&gt;Option&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;)]) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; out1 = vd._1.clone()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blas.daxpy(out1.length, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, msg.get._1, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, out1, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; out2 = vd._2.clone()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blas.daxpy(out2.length, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, msg.get._2, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, out2, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (out1, out2, vd._3 + msg.get._3, vd._4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;.cache()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;materialize(gJoinT2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g.unpersist()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g = gJoinT2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;首先将与某个用户节点相连的所有电影节点的属性2，即 $y_i$ 进行聚合以更新用户属性2（参见上文）&lt;ol&gt;
&lt;li&gt;每个 Triplet 向其源节点（用户）发送其目标节点（电影）的属性2，见第4行&lt;/li&gt;
&lt;li&gt;用户节点将收到的消息中的值进行聚合，此处为向量求和&lt;/li&gt;
&lt;li&gt;将取到的和乘以系数（此处为属性4），加上属性1，即得到更新后的属性2，见14-16行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;对 sendMsgTrainF 的消息进行聚合，并更新各个 p, q, y, b&lt;ol&gt;
&lt;li&gt;消息聚合时，消息中所带的更新值对应位置各自求和（p, q, y 为向量），见31-35行&lt;/li&gt;
&lt;li&gt;通过 join 将值更新至图 g，见41-45行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Testing&quot;&gt;&lt;a href=&quot;#Testing&quot; class=&quot;headerlink&quot; title=&quot;Testing&quot;&gt;&lt;/a&gt;Testing&lt;/h3&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// calculate error on training set&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sendMsgTestF&lt;/span&gt;&lt;/span&gt;(conf: &lt;span class=&quot;type&quot;&gt;Conf&lt;/span&gt;, u: &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (ctx: &lt;span class=&quot;type&quot;&gt;EdgeContext&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;), &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; (usr, itm) = (ctx.srcAttr, ctx.dstAttr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; (p, q) = (usr._1, itm._1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; pred = u + usr._3 + itm._3 + blas.ddot(q.length, q, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, usr._2, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pred = math.max(pred, conf.minVal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pred = math.min(pred, conf.maxVal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; err = (ctx.attr - pred) * (ctx.attr - pred)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ctx.sendToDst(err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g.cache()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; t3 = g.aggregateMessages[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;](sendMsgTestF(conf, u), _ + _)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; gJoinT3 = g.outerJoinVertices(t3) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (vid: &lt;span class=&quot;type&quot;&gt;VertexId&lt;/span&gt;, vd: (&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;], &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;), msg: &lt;span class=&quot;type&quot;&gt;Option&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;]) =&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (msg.isDefined) (vd._1, vd._2, vd._3, msg.get) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; vd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;.cache()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;materialize(gJoinT3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g.unpersist()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g = gJoinT3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;将每部电影相关的误差平方和存入该节点的属性4（之前的这个域并无意义），见第17行&lt;/li&gt;
&lt;li&gt;这里有个问题，看到17行的代码，你可能会想，如果节点没有收到 msg，i.e. 这个电影没有人进行评价，那么它的属性4会保留原值，追溯代码发现这个原值在 Initialization 的第27行被定义，那么按说这个节点没人评价就没有连线，那么在 init 的时候也并不能收到消息，所以27行中的 msg 应该是 None，直接调用 get 难道不会抛出异常么？&lt;ul&gt;
&lt;li&gt;事实上回忆图 g 的生成过程，它是通过一个包含所有边的 RDD 生成的，调用的是 fromEdges 方法，用这个方法生成的图中是不会有孤立点存在的，所以27行这么写是安全的，而这里的17行其实可以不进行条件判断，这样一边存在判断，另一边没有判断的做法反而让人困惑，Whatever…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Misc&quot;&gt;&lt;a href=&quot;#Misc&quot; class=&quot;headerlink&quot; title=&quot;Misc&quot;&gt;&lt;/a&gt;Misc&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;算法中的 materialize 函数在该文件中定义，写作两个 count 操作，为的是触发对应的顶点和边 RDD 的生成，我比较纳闷的是，materialize 随后 cache 应该是属于常见操作，为什么 RDD 不提供对应的接口通用呢？&lt;ul&gt;
&lt;li&gt;单独调用 cache 方法只是说在该 RDD 被第一次真正计算的时候再进行 cache，是个 lazy 的操作，并不触发计算任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;我认为用图的方式对该算法进行抽象是符合直觉的，因为算法中涉及到对 N(u) 集合的计算，对应了图中的邻节点的概念，如果用普通的 RDD 操作，则需要涉及到一系列的 filter，直觉上性能是有损失的，当然具体的性能我没有调研，所以其实我只是瞎扯蛋。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Referrences&quot;&gt;&lt;a href=&quot;#Referrences&quot; class=&quot;headerlink&quot; title=&quot;Referrences&quot;&gt;&lt;/a&gt;Referrences&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Koren, Yehuda. “Factorization meets the neighborhood: a multifaceted collaborative filtering model.” Proceedings of the 14th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2008.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://spark.apache.org/docs/latest/graphx-programming-guide.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GraphX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Clarification&quot;&gt;&lt;a href=&quot;#Clarification&quot; class=&quot;headerlink&quot; title=&quot;Clarification&quot;&gt;&lt;/a&gt;Clarification&lt;/h2&gt;&lt;p&gt;写完之后我突然发现这个标题看上去貌似有“以下实现是由本人完成的”这样的误导，所以特此澄清，下文出现的代码统统摘自&lt;br&gt; &lt;a href=&quot;https://github.com/apache/spark.git&quot;&gt;apache/spark&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;SVD-Intro&quot;&gt;&lt;a href=&quot;#SVD-Intro&quot; class=&quot;headerlink&quot; title=&quot;SVD++ Intro&quot;&gt;&lt;/a&gt;SVD++ Intro&lt;/h2&gt;&lt;p&gt;首先简单介绍 SVD++ 算法在协同过滤中的应用及其数学直觉。&lt;/p&gt;
&lt;h3 id=&quot;SVD-in-CF&quot;&gt;&lt;a href=&quot;#SVD-in-CF&quot; class=&quot;headerlink&quot; title=&quot;SVD in CF&quot;&gt;&lt;/a&gt;SVD in CF&lt;/h3&gt;&lt;p&gt;考虑 CF 中最为常见的用户给电影评分的场景，我们需要一个数学模型来模拟用户给电影打分的场景，i.e. 对评分进行预测。&lt;/p&gt;
&lt;p&gt;一个 Naive 的方案可以是将评分矩阵看作是两个矩阵的乘积：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;U = \begin{bmatrix}&lt;br&gt;u_{11} &amp;amp; \cdots &amp;amp; u_{1k} \\&lt;br&gt;\vdots &amp;amp; \ddots &amp;amp; \vdots \\&lt;br&gt;u_{m1} &amp;amp; \cdots &amp;amp; u_{mk}&lt;br&gt;\end{bmatrix}&lt;br&gt;\begin{bmatrix}&lt;br&gt;i_{11} &amp;amp; \cdots &amp;amp; i_{1n} \\&lt;br&gt;\vdots &amp;amp; \ddots &amp;amp; \vdots \\&lt;br&gt;i_{k1} &amp;amp; \cdots &amp;amp; i_{kn}&lt;br&gt;\end{bmatrix}&lt;br&gt;$$.&lt;/p&gt;
    
    </summary>
    
      <category term="notes" scheme="http://farseer.cn/categories/notes/"/>
    
    
      <category term="scala" scheme="http://farseer.cn/tags/scala/"/>
    
      <category term="spark" scheme="http://farseer.cn/tags/spark/"/>
    
      <category term="ml" scheme="http://farseer.cn/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>CPS and Monads</title>
    <link href="http://farseer.cn/2015/08/03/cps-and-monads/"/>
    <id>http://farseer.cn/2015/08/03/cps-and-monads/</id>
    <published>2015-08-02T16:00:00.000Z</published>
    <updated>2016-02-17T02:39:58.103Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Aha&quot;&gt;&lt;a href=&quot;#Aha&quot; class=&quot;headerlink&quot; title=&quot;Aha&quot;&gt;&lt;/a&gt;Aha&lt;/h2&gt;&lt;p&gt;最近搬了个地儿，离开了生活了近6年的合肥。呆在合肥的时候不觉得她有什么不好，现在想想空气质量是真不照；呆在合肥的时候不觉得她有什么好，现在想想吃饭是真便宜。&lt;/p&gt;
&lt;p&gt;总之就是这段时间一堆烂事，导致前边挖下的坑没能及时填上。另外，随着研究方向的逐渐明确，也许不能再写这些“不务正业”的玩意了，也许会写点跟方向相关的内容，虽然我觉得这个方向上的工作纯忽悠，完全不值一提。我就是一个始终觉得别人研究的东西无比高大上，自己手上的东西都是crap的人。&lt;/p&gt;
&lt;h2 id=&quot;Useful-Monads-with-Interpretor&quot;&gt;&lt;a href=&quot;#Useful-Monads-with-Interpretor&quot; class=&quot;headerlink&quot; title=&quot;Useful Monads with Interpretor&quot;&gt;&lt;/a&gt;Useful Monads with Interpretor&lt;/h2&gt;&lt;p&gt;上一篇结尾提到的那篇论文总算是看完了。既然不能完全消化，吸收，然后拉出屎来；那么我就简单粗暴地吞下去，嚼一嚼，吐出来好了（美其名曰翻译+注释）。&lt;/p&gt;
&lt;p&gt;论文很长，肯定不能逐字翻，我主要关心的是第三章，但是直接跳过前边又不行，所以先简单节选些第二章的内容。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;An-Interpretor-in-A-Monad&quot;&gt;&lt;a href=&quot;#An-Interpretor-in-A-Monad&quot; class=&quot;headerlink&quot; title=&quot;An Interpretor in A Monad&quot;&gt;&lt;/a&gt;An Interpretor in A Monad&lt;/h3&gt;&lt;p&gt;先贴一段基础代码，方便后续查看。&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Name&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Name&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          | &lt;span class=&quot;type&quot;&gt;Con&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          | &lt;span class=&quot;type&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          | &lt;span class=&quot;type&quot;&gt;Lam&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          | &lt;span class=&quot;type&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Wrong&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           | &lt;span class=&quot;type&quot;&gt;Num&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           | &lt;span class=&quot;type&quot;&gt;Fun&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Environment&lt;/span&gt; = [(&lt;span class=&quot;type&quot;&gt;Name&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;showval&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;showval&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Wrong&lt;/span&gt;   = &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;wrong&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;showval&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Num&lt;/span&gt; i) = showint i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;showval&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Fun&lt;/span&gt; f) = &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;function&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Environment&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Var&lt;/span&gt; x) e   = lookup x e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Con&lt;/span&gt; i) e   = unitM (&lt;span class=&quot;type&quot;&gt;Num&lt;/span&gt; i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Add&lt;/span&gt; u v) e = interp u e `bindM` (\a -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      interp v e `bindM` (\b -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      add a b))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Lam&lt;/span&gt; x v) e = unitM (&lt;span class=&quot;type&quot;&gt;Fun&lt;/span&gt; (\a -&amp;gt; interp v ((x, a):e)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;App&lt;/span&gt; t u) e = interp t e `bindM` (\f -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     interp u e `bindM` (\a -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     apply f a))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;lookup&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Name&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Environment&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;lookup&lt;/span&gt; x []         = unitM &lt;span class=&quot;type&quot;&gt;Wrong&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;lookup&lt;/span&gt; x ((y, b):e) = &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x == y &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; unitM b &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; lookup x e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Num&lt;/span&gt; i) (&lt;span class=&quot;type&quot;&gt;Num&lt;/span&gt; j) = unitM (&lt;span class=&quot;type&quot;&gt;Num&lt;/span&gt; (i + j))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt; a b             = unitM &lt;span class=&quot;type&quot;&gt;Wrong&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;apply&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;apply&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Fun&lt;/span&gt; k) a = k a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;apply&lt;/span&gt; f a       = unitM &lt;span class=&quot;type&quot;&gt;Wrong&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;test&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;test&lt;/span&gt; t = showM (interp t [])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;简单的几点说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Value 以自身形态存储于 Environment，只不过每次读取的时候，我们用 unitM 将其转换为对应的 M Value，这样比直接存 M Value 肯定是要节省空间的&lt;/li&gt;
&lt;li&gt;所有的函数返回值都是 M Value，M 取不同的 Monad，这个解释器就会扩充得到相应的功能&lt;/li&gt;
&lt;li&gt;参数传递通过 call-by-value，因为:&lt;ul&gt;
&lt;li&gt;函数的参数类型是 Value 而不是 M Value&lt;/li&gt;
&lt;li&gt;interp的最后一行是先 &lt;code&gt;interp u e&lt;/code&gt; 再将值传递给 apply 的，这边的 bindM 可以想象成数据处理单元之间的管道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Standard-Interpretor&quot;&gt;&lt;a href=&quot;#Standard-Interpretor&quot; class=&quot;headerlink&quot; title=&quot;Standard Interpretor&quot;&gt;&lt;/a&gt;Standard Interpretor&lt;/h3&gt;&lt;p&gt;如果我们不想给这个解释器添加任何功能，我们可以将 M 定义为啥也不干，结合上篇文章里提到的概念，所谓啥也不干，是说 M 为一个 Cat -&amp;gt; Cat 的 identity endofunctor，写成 haskell 就是：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;M&lt;/span&gt; a    = a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;unitM&lt;/span&gt; a     = a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; `bindM` k = k a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;showM&lt;/span&gt; a     = showval a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Error-Messages&quot;&gt;&lt;a href=&quot;#Error-Messages&quot; class=&quot;headerlink&quot; title=&quot;Error Messages&quot;&gt;&lt;/a&gt;Error Messages&lt;/h3&gt;&lt;p&gt;为了给解释器添加类似 exception 的功能，我们只需要将上边的 M 替换为下面的 Monad E，先上代码：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;E&lt;/span&gt; a              = &lt;span class=&quot;type&quot;&gt;Success&lt;/span&gt; a | &lt;span class=&quot;type&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;unitE&lt;/span&gt; a               = &lt;span class=&quot;type&quot;&gt;Success&lt;/span&gt; a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;errorE&lt;/span&gt; s              = &lt;span class=&quot;type&quot;&gt;Error&lt;/span&gt; s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;type&quot;&gt;Success&lt;/span&gt; a) `bindE` k = k a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;type&quot;&gt;Error&lt;/span&gt; s) `bindE` k   = &lt;span class=&quot;type&quot;&gt;Error&lt;/span&gt; s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;showE&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Success&lt;/span&gt; a)     = &lt;span class=&quot;string&quot;&gt;&quot;Success: &quot;&lt;/span&gt; ++ showval a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;showE&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Error&lt;/span&gt; s)       = &lt;span class=&quot;string&quot;&gt;&quot;Error: &quot;&lt;/span&gt; ++ s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;思想很简单，如果每次计算是成功的，那么传递成功的结果进行后续的计算；否则，不论后边进行了什么样的操作，都返回最初的错误信息。论文中还给出了带出错位置信息的版本 P，这边就不赘述了。&lt;/p&gt;
&lt;h3 id=&quot;State&quot;&gt;&lt;a href=&quot;#State&quot; class=&quot;headerlink&quot; title=&quot;State&quot;&gt;&lt;/a&gt;State&lt;/h3&gt;&lt;p&gt;M 可以用于记录各种状态信息，文中给出了用于记录归约操作次数的版本 S：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- general state&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;S&lt;/span&gt; a    = &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; -&amp;gt; (&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;unitS&lt;/span&gt; a     = \s0 -&amp;gt; (a, s0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;m&lt;/span&gt; `bindS` k = \s0 -&amp;gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; (a, s1) = m s0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                         (b, s2) = k a s1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (b, s2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- reduction count specific&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;showS&lt;/span&gt; m = &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; (a, s1) = m &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Value: &quot;&lt;/span&gt; ++ showval a ++ &lt;span class=&quot;string&quot;&gt;&quot;; &quot;&lt;/span&gt; ++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;&quot;Count: &quot;&lt;/span&gt; ++ showint s1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;tickS&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;S&lt;/span&gt; ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;tickS&lt;/span&gt; = \s -&amp;gt; ((), s + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;apply&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Fun&lt;/span&gt; k) a     = tickS `bindS` (\() -&amp;gt; k a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Num&lt;/span&gt; i) (&lt;span class=&quot;type&quot;&gt;Num&lt;/span&gt; j) = tickS `bindS` (\() -&amp;gt; unitS (&lt;span class=&quot;type&quot;&gt;Num&lt;/span&gt; (i + j)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数的返回值类型读作：“给我一个初始状态，我给你返回一个值和一个终止状态”&lt;ul&gt;
&lt;li&gt;函数仍然是 pure 的，跟状态有关的所有信息都被包在返回值中，返回值本身以函数的形式记录了对所有不同的初始状态所要作出的应答&lt;/li&gt;
&lt;li&gt;unitS 对 Value 进行封装，很好理解&lt;/li&gt;
&lt;li&gt;bindS 也很明确，给定初始状态 s0，先通过 m 得到一个值 a 和一个新状态 s1，再将 a 传递给函数 k，将其返回值作用在状态 s1 上…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tickS 设计得较为巧妙&lt;ul&gt;
&lt;li&gt;apply 和 add 两个函数的执行都要将状态中记录的归约次数加1，如果每个都分开写，例如将 apply 写成 &lt;code&gt;\s -&amp;gt; k a (s + 1)&lt;/code&gt;，就会很麻烦&lt;/li&gt;
&lt;li&gt;用 tickS 抽取出它们共同的加1操作部分，通过 bindS 拼接，那么后续只需要关注自身的逻辑就好&lt;/li&gt;
&lt;li&gt;() 表示一个我们不关心的 Value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果想要添加输出当前 count 的原语，可以这么做：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;fetchS&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;fetchS&lt;/span&gt; = \s -&amp;gt; (s, s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt; = ... | &lt;span class=&quot;type&quot;&gt;Count&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Count&lt;/span&gt; e = fetchS `bindS` (\i -&amp;gt; unitS (&lt;span class=&quot;type&quot;&gt;Num&lt;/span&gt; i))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一种自然的想法是，用上边的 State 来实现输出，但是这样会导致计算的过程之中无法输出，所有的输出都积攒到了最后。正确的做法：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;O&lt;/span&gt; a = (&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;unitO&lt;/span&gt; a = (&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;m&lt;/span&gt; `bindO` k = &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; (r, a = m); (s, b) = k a &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (r ++ s, b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;showO&lt;/span&gt; (s, a) = &lt;span class=&quot;string&quot;&gt;&quot;Output: &quot;&lt;/span&gt; ++ s ++ &lt;span class=&quot;string&quot;&gt;&quot;Value: &quot;&lt;/span&gt; ++ showval a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过将每个值和产生这个值过程中产生的输出字符串捆绑，通过字符串拼接进行传递。接下来添加实际输出所需的原语：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;outO&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;O&lt;/span&gt; ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;outO&lt;/span&gt; a = (showval a ++ &lt;span class=&quot;string&quot;&gt;&quot;; &quot;&lt;/span&gt;, ())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt; = ... | &lt;span class=&quot;type&quot;&gt;Out&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Out&lt;/span&gt; u) e = interp u e `bindO` (\a -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   outO a `bindO` (\() -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   unitO a))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Out 的实际执行过程中，调用了 outO，后者通过 showval 产生实际效果，由于 lazy evaluation，这使得在执行过程中就可以产生输出。&lt;/p&gt;
&lt;p&gt;没想明白这样的做法怎么就 Pure 了…&lt;/p&gt;
&lt;h2 id=&quot;CPS-Interpretor&quot;&gt;&lt;a href=&quot;#CPS-Interpretor&quot; class=&quot;headerlink&quot; title=&quot;CPS Interpretor&quot;&gt;&lt;/a&gt;CPS Interpretor&lt;/h2&gt;&lt;p&gt;经过前面这么长的铺垫，终于要进入正题了…&lt;/p&gt;
&lt;h3 id=&quot;What-is-CPS-Continuation&quot;&gt;&lt;a href=&quot;#What-is-CPS-Continuation&quot; class=&quot;headerlink&quot; title=&quot;What is CPS/Continuation ?&quot;&gt;&lt;/a&gt;What is CPS/Continuation ?&lt;/h3&gt;&lt;p&gt;具体解释参见文末的引用链接。我认为 Continuation 就是一种语言本身可见的程序执行控制的抽象，比如说，它可以表示为一个函数，类型：&lt;code&gt;A -&amp;gt; Answer&lt;/code&gt;，蕴含了对A类型的数据的操作。这样的抽象通常用于添加一些控制机制，如 exceptions, generators, coroutines…&lt;/p&gt;
&lt;p&gt;对于 CPS，个人理解就是每个函数除了接收原来的参数之外，还需要一个 continuation 用于表示得到该函数的返回值之后还需要进行的操作，对于 CPS 的好处，参见下方 wikipedia 的链接。由于递归函数在改写为 CPS 风格之后会自动变为 tail call （详情参见维基百科中的例子），所以很久以前我一直以为它跟 TCO 是一回事…&lt;/p&gt;
&lt;h3 id=&quot;A-Monad-of-Continuation&quot;&gt;&lt;a href=&quot;#A-Monad-of-Continuation&quot; class=&quot;headerlink&quot; title=&quot;A Monad of Continuation&quot;&gt;&lt;/a&gt;A Monad of Continuation&lt;/h3&gt;&lt;p&gt;简单介绍了概念之后，我们构建这样的 Monad K:&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;K&lt;/span&gt; a = (&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Answer&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Answer&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;unitK&lt;/span&gt; a = \c -&amp;gt; c a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;m&lt;/span&gt; `bindM` k = \c -&amp;gt; m (\a -&amp;gt; k a c)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 CPS 中，函数需要传递额外的 continuation，通过 Currying，我们可以将函数返回值设置成一个接收 continuation 的函数来实现，即上面的 K a 对应的类型，读作“给我一个 continuation，还你一个结果”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unitK 就是将普通的 a 类型的值转化为 CPS 中对应的函数返回值的操作&lt;/li&gt;
&lt;li&gt;bindM 的两个参数，m 具有类型 &lt;code&gt;K a&lt;/code&gt;， k 具有类型 &lt;code&gt;a -&amp;gt; K b&lt;/code&gt;，那么根据 Monad 的类型，等号右边应该具有类型 &lt;code&gt;K b&lt;/code&gt;；也就是说，&lt;code&gt;m (\a -&amp;gt; k a c)&lt;/code&gt; 应该具有类型 Answer；&lt;code&gt;\a -&amp;gt; k a c&lt;/code&gt; 应该具有类型 continuation，即 &lt;code&gt;a -&amp;gt; Answer&lt;/code&gt;；…；于是类型是OK的&lt;ul&gt;
&lt;li&gt;什么意思呢？如果把 continuation 理解成“之后需要进行的操作”，那么可以作如下解释：“m 将之后需要进行的操作丢给了 k”，也就是说，不论如何，下一步执行的是 k，至于再之后，交给 k 来处理… 如此继续下去，便能够得到一个非常精确的执行流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将上述定义的 unit 和 bind 带入一开始的解释器中，归约后得到：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Environment&lt;/span&gt; -&amp;gt; (&lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Answer&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Answer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Var&lt;/span&gt; x) e   = \c -&amp;gt; lookup x e c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Con&lt;/span&gt; i) e   = \c -&amp;gt; c (&lt;span class=&quot;type&quot;&gt;Num&lt;/span&gt; i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Add&lt;/span&gt; u v) e = \c -&amp;gt; interp u e (\a -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                           interp v e (\b -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                           add a b c))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Lam&lt;/span&gt; x v) e = \c -&amp;gt; c (&lt;span class=&quot;type&quot;&gt;Fun&lt;/span&gt; (\a -&amp;gt; interp v ((x, a):e)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;App&lt;/span&gt; t u) e = \c -&amp;gt; interp t e (\f -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                           interp u e (\a -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                           apply f a c))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里的 Answer 类型可以有多种取法，最简单的，取作 Value。&lt;/p&gt;
&lt;h3 id=&quot;Callcc&quot;&gt;&lt;a href=&quot;#Callcc&quot; class=&quot;headerlink&quot; title=&quot;Callcc&quot;&gt;&lt;/a&gt;Callcc&lt;/h3&gt;&lt;p&gt;熟悉 scheme 的应该知道 call/cc，即 call with current continuation. 下面我们会看到，这个操作可以很容易地被定义。&lt;/p&gt;
&lt;p&gt;在谈具体的实现之前，先扯点别的。我们知道 STLC 通过 Curry-Howard isomorphism 对应到的是 intuitionistic logic，不包括排中律。如果想要将其扩充称为 classical logic，我们需要添加额外的表达式。由于排中律与 Pierce’s Law 逻辑等价，我们可以通过添加一个具有类型 &lt;code&gt;((A -&amp;gt; B) -&amp;gt; A) -&amp;gt; A&lt;/code&gt; 的表达式（对任意A，B）来实现。&lt;/p&gt;
&lt;p&gt;这样的表达式被称作 Felleisen’s $\mathfrak{C}$，而 call/cc 正是这样的表达式。&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;callccK&lt;/span&gt; :: ((a -&amp;gt; &lt;span class=&quot;type&quot;&gt;K&lt;/span&gt; b) -&amp;gt; &lt;span class=&quot;type&quot;&gt;K&lt;/span&gt; a) -&amp;gt; &lt;span class=&quot;type&quot;&gt;K&lt;/span&gt; a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;callccK&lt;/span&gt; h = \c -&amp;gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k a = \d -&amp;gt; c a &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; h k c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;首先来看类型，这里 h 具有类型 &lt;code&gt;(a -&amp;gt; K b) -&amp;gt; K a&lt;/code&gt;，于是 &lt;code&gt;k :: a -&amp;gt; K b&lt;/code&gt;，等号右边的表达式具有类型 &lt;code&gt;K a&lt;/code&gt;，即 &lt;code&gt;h k c :: Answer&lt;/code&gt;，亦即 &lt;code&gt;K a c :: Answer&lt;/code&gt;，于是类型是正确的&lt;/li&gt;
&lt;li&gt;下面分析语义，这里唯一需要注意的就是对 k 的定义，说的是，如果 k 以参数 a 被调用，则忽略调用时的 continuation，直接以 c 作为 continuation 继续执行。这么描述可能还是无法和 call/cc 完全对应上，下面加入如下的原语:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt; = ... | &lt;span class=&quot;type&quot;&gt;Callcc&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Term&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;interp&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Callcc&lt;/span&gt; x v) e = callccK (\k -&amp;gt; interp v ((x, &lt;span class=&quot;type&quot;&gt;Fun&lt;/span&gt; k):e))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      = (\c -&amp;gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k a = \d -&amp;gt; c a &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (interp v ((x, &lt;span class=&quot;type&quot;&gt;Fun&lt;/span&gt; k):e) c))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;第二个等号是我为了阅读进行的一步替换操作&lt;/li&gt;
&lt;li&gt;此处将参数 x 绑定到了函数 k，相当于起个名字，当 &lt;code&gt;interp v e&amp;#39;&lt;/code&gt; 真正执行到对应于 k 的 apply 时，就会触发上文提到的 continuation 的切换。当然如果 v 中不包含 k 的调用，它只是将 v 进行求值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不难验证表达式 &lt;code&gt;(Add (Con 1) (Callcc &amp;quot;k&amp;quot; (Add (Con 2) (App (Var &amp;quot;k&amp;quot;) (Con 4)))))&lt;/code&gt; 通过解释之后的值为 5，正如 call/cc.&lt;/p&gt;
&lt;h2 id=&quot;CPS-to-Monads&quot;&gt;&lt;a href=&quot;#CPS-to-Monads&quot; class=&quot;headerlink&quot; title=&quot;CPS to Monads&quot;&gt;&lt;/a&gt;CPS to Monads&lt;/h2&gt;&lt;p&gt;上边的例子说明了：通过选取特殊的 Monad K，我们将一个 Monad 解释器改造成了一个 CPS 解释器（通过替换掉全部的 unit 和 bind 操作）。&lt;br&gt;下面说明其相反的操作（即用 CPS 实现 Monad）也是可行的，方法是通过修改 Answer 的类型。&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Answer&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;showK&lt;/span&gt; n = showM (n unitM)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;promoteK&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;M&lt;/span&gt; a -&amp;gt; &lt;span class=&quot;type&quot;&gt;K&lt;/span&gt; a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;promoteK&lt;/span&gt; m = \c -&amp;gt; m `bindM` c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;promte 中 continuation &lt;code&gt;c :: a -&amp;gt; M Value&lt;/code&gt;, &lt;code&gt;m :: M a&lt;/code&gt;，于是类型OK&lt;/li&gt;
&lt;li&gt;promte 将 M Value 类型转换为 K Value 类型，从而可以传入 CPS 解释器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是上面提到的几种 Monad 分别对应如下的 CPS 版本：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;errorK&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; -&amp;gt; (a -&amp;gt; &lt;span class=&quot;type&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;errorK&lt;/span&gt; s = promoteK (errorE s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         = \c -&amp;gt; (errorE s) `bindE` c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         = \c -&amp;gt; &lt;span class=&quot;type&quot;&gt;Error&lt;/span&gt; s `bindE` c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         = \c -&amp;gt; &lt;span class=&quot;type&quot;&gt;Error&lt;/span&gt; s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;tickK&lt;/span&gt; :: (() -&amp;gt; &lt;span class=&quot;type&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;tickK&lt;/span&gt; = promoteK tickS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      = \c -&amp;gt; tickS `bindS` c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      = \c -&amp;gt; (\s -&amp;gt; ((), s + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) `bindS` c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      = \c -&amp;gt; \s -&amp;gt; c () (s + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;outK&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt; -&amp;gt; (&lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;outK&lt;/span&gt; a = promoteK (outO a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       = \c -&amp;gt; (outO a) `bindO` c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       = \c -&amp;gt; (showval a ++ &lt;span class=&quot;string&quot;&gt;&quot;; &quot;&lt;/span&gt;, ()) `bindO` c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       = \c -&amp;gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; (s, b) = c () &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (showval a ++ &lt;span class=&quot;string&quot;&gt;&quot;; &quot;&lt;/span&gt; ++ s, b)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;过程已经足够详细，这里就不展开具体的分析了。&lt;/p&gt;
&lt;h2 id=&quot;Monads-vs-CPS&quot;&gt;&lt;a href=&quot;#Monads-vs-CPS&quot; class=&quot;headerlink&quot; title=&quot;Monads vs. CPS&quot;&gt;&lt;/a&gt;Monads vs. CPS&lt;/h2&gt;&lt;p&gt;根据 Wadler 的分析，Monads 提供了比 CPS 更为精细的表达能力的控制。&lt;/p&gt;
&lt;p&gt;例如对于 Monad S (上文提到过的 State Monad) 中的类型 &lt;code&gt;S a&lt;/code&gt;，它在 CPS 中对应的类型为 &lt;code&gt;(a -&amp;gt; S Value) -&amp;gt; S Value&lt;/code&gt;，它包括这样的表达式 &lt;code&gt;\c -&amp;gt; \s -&amp;gt; (Wrong, s)&lt;/code&gt;（此处原文中写成了 &lt;code&gt;\c -&amp;gt; \s -&amp;gt; (Wrong, c)&lt;/code&gt;，我认为这是个 typo），在 Monad 中，我们可以控制这样的表达式是否能够被创建；但是 CPS 不具备这样的能力。&lt;/p&gt;
&lt;h2 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuation-passing_style&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Continuation-passing style&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Continuation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tail call&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Matthias_Felleisen&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Matthias Felleisen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wadler, Philip. “The essence of functional programming.” Proceedings of the 19th ACM SIGPLAN-SIGACT symposium on Principles of programming languages. ACM, 1992.&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Aha&quot;&gt;&lt;a href=&quot;#Aha&quot; class=&quot;headerlink&quot; title=&quot;Aha&quot;&gt;&lt;/a&gt;Aha&lt;/h2&gt;&lt;p&gt;最近搬了个地儿，离开了生活了近6年的合肥。呆在合肥的时候不觉得她有什么不好，现在想想空气质量是真不照；呆在合肥的时候不觉得她有什么好，现在想想吃饭是真便宜。&lt;/p&gt;
&lt;p&gt;总之就是这段时间一堆烂事，导致前边挖下的坑没能及时填上。另外，随着研究方向的逐渐明确，也许不能再写这些“不务正业”的玩意了，也许会写点跟方向相关的内容，虽然我觉得这个方向上的工作纯忽悠，完全不值一提。我就是一个始终觉得别人研究的东西无比高大上，自己手上的东西都是crap的人。&lt;/p&gt;
&lt;h2 id=&quot;Useful-Monads-with-Interpretor&quot;&gt;&lt;a href=&quot;#Useful-Monads-with-Interpretor&quot; class=&quot;headerlink&quot; title=&quot;Useful Monads with Interpretor&quot;&gt;&lt;/a&gt;Useful Monads with Interpretor&lt;/h2&gt;&lt;p&gt;上一篇结尾提到的那篇论文总算是看完了。既然不能完全消化，吸收，然后拉出屎来；那么我就简单粗暴地吞下去，嚼一嚼，吐出来好了（美其名曰翻译+注释）。&lt;/p&gt;
&lt;p&gt;论文很长，肯定不能逐字翻，我主要关心的是第三章，但是直接跳过前边又不行，所以先简单节选些第二章的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="PLT" scheme="http://farseer.cn/categories/PLT/"/>
    
    
      <category term="haskell" scheme="http://farseer.cn/tags/haskell/"/>
    
  </entry>
  
  <entry>
    <title>Monads in Category Theory and Monads in Haskell</title>
    <link href="http://farseer.cn/2015/07/09/monads-in-category-theory-and-monads-in-haskell/"/>
    <id>http://farseer.cn/2015/07/09/monads-in-category-theory-and-monads-in-haskell/</id>
    <published>2015-07-08T16:00:00.000Z</published>
    <updated>2016-02-17T02:40:10.353Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Aha&quot;&gt;&lt;a href=&quot;#Aha&quot; class=&quot;headerlink&quot; title=&quot;Aha&quot;&gt;&lt;/a&gt;Aha&lt;/h2&gt;&lt;p&gt;最近尝试学习一些基础的范畴论，无奈资质愚钝，浅尝则止了。不过还是想通过这篇文章来加深一下对某些东西的粗浅认识。&lt;/p&gt;
&lt;p&gt;我在看monads的定义的时候，总是无法将范畴论中的那套东西联系到haskell中的定义上，为此，我查阅了一些资料，花了很多时间去思考（所谓勤能补拙），总算是让自己相信了。&lt;/p&gt;
&lt;h2 id=&quot;Monads-in-Category-Theory&quot;&gt;&lt;a href=&quot;#Monads-in-Category-Theory&quot; class=&quot;headerlink&quot; title=&quot;Monads in Category Theory&quot;&gt;&lt;/a&gt;Monads in Category Theory&lt;/h2&gt;&lt;p&gt;从什么地方写起，这是个问题，想了想决定跳过category的定义，直接从functor说起，因为cat的定义比较简单，一搜一看就能理解，而functor在我之前的文章中对它的描述有偏差，这边顺便就纠正了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Functors&quot;&gt;&lt;a href=&quot;#Functors&quot; class=&quot;headerlink&quot; title=&quot;Functors&quot;&gt;&lt;/a&gt;Functors&lt;/h3&gt;&lt;p&gt;functors用于联系多个cat，假设C和D为两个cat，一个functor $F: C \to D$ 可以看作是从C到D的映射，对应关系如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对C中任意的object A，$\exists F(A) \in D$&lt;/li&gt;
&lt;li&gt;对C中任意的morphism $f: A \to B$, $\exists F(f): F(A) \to F(B)$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要满足如下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$F(id_A) = id_{F(A)}$&lt;/li&gt;
&lt;li&gt;$F(f \circ g) = F(f) \circ F(g)$ 先复合再映射与先映射再复合等效&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一图流：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Functor.png&quot; alt=&quot;functor&quot;&gt;&lt;/p&gt;
&lt;p&gt;对应到haskell中的定义&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Functor&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;f&lt;/span&gt; :: * -&amp;gt; *) &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;fmap对应了上述定义中从C中的morphism到D中的morphism之间的映射。那么C和D究竟是什么呢？&lt;/p&gt;
&lt;p&gt;C这个范畴被称为Hask，它的objects为haskell中的所有类型，morphisms为所有haskell函数，haskell中的函数满足结合律，所以它是一个cat。这里haskell中的类型不仅仅包括集合，还有一些高阶的类型，故Hask和Set这个cat是不等价的。&lt;/p&gt;
&lt;p&gt;至于D嘛，就要看你的functor是做什么的了，比如对应的是list，那么D就是由所有list类型组成的category。此时的fmap就是我们熟知的lisp中的map函数。&lt;/p&gt;
&lt;p&gt;我对functor的理解就是，从D中找到C中对应的东西之后，套上F的标签即可。&lt;/p&gt;
&lt;h3 id=&quot;Definition-of-Monad&quot;&gt;&lt;a href=&quot;#Definition-of-Monad&quot; class=&quot;headerlink&quot; title=&quot;Definition of Monad&quot;&gt;&lt;/a&gt;Definition of Monad&lt;/h3&gt;&lt;p&gt;首先，一个monad是一个functor，它从cat C映射到C自身，即 $T: C \to C$，这样的functor被叫做endofunctor。光是这样还不足够，需要有两个natural transformations:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\eta: 1_C \to T$ 从C上的identity functor(所有的部件映射到自身)到T的映射&lt;/li&gt;
&lt;li&gt;$\mu: T \circ T \to T$ 从两个T的复合所形成的endofunctor到T的映射&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我就不展开关于natural transformation的定义了，简单来说就是functors之间的映射，所以这里的抽象层级又高了，这也就是范畴论绕人的地方。&lt;/p&gt;
&lt;p&gt;它们要满足的游戏规则很简单，一图流：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/monad_laws1.png&quot; alt=&quot;monad&quot;&gt;&lt;/p&gt;
&lt;p&gt;或者，为了避免使用natural transformation，这样来简化定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;T是C上的endofunctor，这点没变&lt;/li&gt;
&lt;li&gt;对于C中的任意object X，有如下两个morphisms(这和C中的morphisms有层次上的差异，不过并不需要理会)&lt;ol&gt;
&lt;li&gt;$\eta_X: X \to T(X)$&lt;/li&gt;
&lt;li&gt;$\mu_X: T(T(X)) \to T(X)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;规则变为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/monad_laws2.png&quot; alt=&quot;monad&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;A-monad-in-X-is-just-a-monoid-in-the-category-of-endofunctors-of-X&quot;&gt;&lt;a href=&quot;#A-monad-in-X-is-just-a-monoid-in-the-category-of-endofunctors-of-X&quot; class=&quot;headerlink&quot; title=&quot;A monad in X is just a monoid in the category of endofunctors of X&quot;&gt;&lt;/a&gt;A monad in X is just a monoid in the category of endofunctors of X&lt;/h3&gt;&lt;p&gt;首先，X是一个cat，”the category of endofunctors” 是这样的一个cat，其中的objects是从X到X的endofunctor，morphisms是它们之间的natural transformations.&lt;/p&gt;
&lt;p&gt;这些endofunctors中，可以被称作monad的那些，必须满足上一节描述的条件，而这些条件正是称为上述范畴中的一个monoid object的条件。这里的monoid object，或者简称monoid，也是范畴论中的概念，是群论中“么半群”的扩展，Set(集合这个范畴)中的monoid object就是群论中的monoid。&lt;/p&gt;
&lt;p&gt;我不想被monoid object这个概念再绕进去了，我们直接跟么半群进行比较吧，一个monoid就是一个缺少逆的群，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个集合S&lt;/li&gt;
&lt;li&gt;一个S上的二元运算 $S \cdot S \to S$&lt;/li&gt;
&lt;li&gt;一个S上的么元 $e: S$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它需要满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结合律 $a \cdot (b \cdot c) = (a \cdot b) \cdot c$ 对应上图中的左侧，等式左边对应路径：右-&amp;gt;下，右边对应：下-&amp;gt;右&lt;/li&gt;
&lt;li&gt;单位元 $a \cdot e = e \cdot a = a$，对应上图中的右侧&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，我觉得严格地说，这句话的中文翻译“Monad就是自函子范畴上的么半群”是不对的，因为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;并不是所有范畴上的自函子构成的范畴，（我不知道所有范畴的所有自函子是否能构成范畴，总感觉这包含自指的定义有些问题）&lt;/li&gt;
&lt;li&gt;并不是么半群，而是范畴论中的monoid object，（不知道怎么翻译，我觉得至少不能跟群混起来吧）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;From-Category-Theory-To-Haskell&quot;&gt;&lt;a href=&quot;#From-Category-Theory-To-Haskell&quot; class=&quot;headerlink&quot; title=&quot;From Category Theory To Haskell&quot;&gt;&lt;/a&gt;From Category Theory To Haskell&lt;/h3&gt;&lt;p&gt;Haskell中的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Functor&lt;/span&gt; m =&amp;gt; &lt;span class=&quot;type&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return :: a -&amp;gt; m a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&amp;gt;&amp;gt;=)  :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Left unit: &lt;code&gt;(return a) &amp;gt;&amp;gt;= k = k a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Right unit: &lt;code&gt;m &amp;gt;&amp;gt;= return = m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Associative: &lt;code&gt;m &amp;gt;&amp;gt;= (\a -&amp;gt; (k a) &amp;gt;&amp;gt;= (\b -&amp;gt; h b)) = (m &amp;gt;&amp;gt;= (\a -&amp;gt; k a)) &amp;gt;&amp;gt;= (\b -&amp;gt; h b)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先，haskell中的monad都是haskell中的functor，所以它们的C都是Hask这个范畴，那么问题来了，之前说了functor是从Hask到它的子范畴的映射，怎么还能是endofunctor呢？事实上对于任意的functor，我们可以任意扩展它的目标范畴，因为根据定义，所有的限定词都是存在，干脆扩充到Hask算了，于是haskell中的所有monad都是Hask到自身的endofunctor.&lt;/p&gt;
&lt;p&gt;上面的return对应的自然是$\eta$，这个很好理解，但是下面的这个bind是什么鬼？规则又和上面的图片有何关联？&lt;/p&gt;
&lt;p&gt;首先，我们需要一个与上边的$\mu$对应的操作join，并且它的表示能力是与bind完全等价的。&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;join&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Monad&lt;/span&gt; m =&amp;gt; m (m a) -&amp;gt; m a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;join&lt;/span&gt; x = x &amp;gt;&amp;gt;= id&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&amp;gt;&amp;gt;=) :: &lt;span class=&quot;type&quot;&gt;Monad&lt;/span&gt; m =&amp;gt; m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;x&lt;/span&gt; &amp;gt;&amp;gt;= f = join(fmap f x)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有了定义之后，通过简单地代换不难验证，上边的三条规则与下述规则是等价的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;join . fmap join = join . join&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;join . fmap return = join . return = id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return . f = fmap f . return&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;join . fmap (fmap f) = fmap f . join&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fmap id = id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fmap (f . g) = fmap f . fmap g&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事实上，可以这样从这六条规则推出上述三条：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Left unit: &lt;code&gt;(return a) &amp;gt;&amp;gt;= k = join(fmap k (return a)) = join(return(k a)) = (k a)&lt;/code&gt; 用到了规则2和3&lt;/li&gt;
&lt;li&gt;Right unit: &lt;code&gt;m &amp;gt;&amp;gt;= return = join(fmap return m) = m&lt;/code&gt; 用到了规则2&lt;/li&gt;
&lt;li&gt;Associative: 将bind替换为join后利用规则6直接得到&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;又，将join替换成$\mu$, return替换成$\eta$，容易得到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;后六条规则中的5和6来自functor的约束，无需多加说明&lt;/li&gt;
&lt;li&gt;对于规则1，对应上图左侧，等式左边对应路径：右-&amp;gt;下，右边对应路径：下-&amp;gt;右&lt;/li&gt;
&lt;li&gt;对于规则2，对应上图右侧，等式左边对应路径：下-&amp;gt;右，等式中间对应路径：右-&amp;gt;下&lt;/li&gt;
&lt;li&gt;对于3-4，可以通过下面的示意图说明，假设f为C上的morphism $f: A \to B$，A和B均为C中的Objects&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/monad_law3.png&quot; alt=&quot;monad&quot;&gt;&lt;/p&gt;
&lt;p&gt;至此，两种monad的定义得到了统一，happy ending.&lt;/p&gt;
&lt;h2 id=&quot;The-essence-of-FP&quot;&gt;&lt;a href=&quot;#The-essence-of-FP&quot; class=&quot;headerlink&quot; title=&quot;The essence of FP&quot;&gt;&lt;/a&gt;The essence of FP&lt;/h2&gt;&lt;p&gt;“The essence of functional programming” 这篇文章中给出了多个利用monad来灵活地扩展解释器的例子，让人能够直观地体会到monad的好处。&lt;/p&gt;
&lt;p&gt;另外，该文章还指出了monad和CPS的微妙联系，如果我能邻会精神的话，也许会有后文…&lt;/p&gt;
&lt;h2 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid_(category_theory\&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Monoid (category theory)&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Monad_(category_theory\&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Monad (category theory)&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Natural_transformation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Natural transformation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Haskell/Category theory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wadler, Philip. “The essence of functional programming.” Proceedings of the 19th ACM SIGPLAN-SIGACT symposium on Principles of programming languages. ACM, 1992.&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Aha&quot;&gt;&lt;a href=&quot;#Aha&quot; class=&quot;headerlink&quot; title=&quot;Aha&quot;&gt;&lt;/a&gt;Aha&lt;/h2&gt;&lt;p&gt;最近尝试学习一些基础的范畴论，无奈资质愚钝，浅尝则止了。不过还是想通过这篇文章来加深一下对某些东西的粗浅认识。&lt;/p&gt;
&lt;p&gt;我在看monads的定义的时候，总是无法将范畴论中的那套东西联系到haskell中的定义上，为此，我查阅了一些资料，花了很多时间去思考（所谓勤能补拙），总算是让自己相信了。&lt;/p&gt;
&lt;h2 id=&quot;Monads-in-Category-Theory&quot;&gt;&lt;a href=&quot;#Monads-in-Category-Theory&quot; class=&quot;headerlink&quot; title=&quot;Monads in Category Theory&quot;&gt;&lt;/a&gt;Monads in Category Theory&lt;/h2&gt;&lt;p&gt;从什么地方写起，这是个问题，想了想决定跳过category的定义，直接从functor说起，因为cat的定义比较简单，一搜一看就能理解，而functor在我之前的文章中对它的描述有偏差，这边顺便就纠正了。&lt;/p&gt;
    
    </summary>
    
      <category term="PLT" scheme="http://farseer.cn/categories/PLT/"/>
    
    
      <category term="haskell" scheme="http://farseer.cn/tags/haskell/"/>
    
  </entry>
  
  <entry>
    <title>Coprime probabilities</title>
    <link href="http://farseer.cn/2015/06/28/coprime-probabilities/"/>
    <id>http://farseer.cn/2015/06/28/coprime-probabilities/</id>
    <published>2015-06-27T16:00:00.000Z</published>
    <updated>2016-02-17T02:40:37.053Z</updated>
    
    <content type="html">&lt;h2 id=&quot;A-Conclusion&quot;&gt;&lt;a href=&quot;#A-Conclusion&quot; class=&quot;headerlink&quot; title=&quot;A Conclusion&quot;&gt;&lt;/a&gt;A Conclusion&lt;/h2&gt;&lt;p&gt;听说了一个有趣的结论：两个随机的正整数互质的概率为 $\frac{6}{\pi ^2}$，对它的推导过程感到好奇，于是通过wikipedia学习了一些数学知识…&lt;/p&gt;
&lt;h2 id=&quot;Basic-Analysis&quot;&gt;&lt;a href=&quot;#Basic-Analysis&quot; class=&quot;headerlink&quot; title=&quot;Basic Analysis&quot;&gt;&lt;/a&gt;Basic Analysis&lt;/h2&gt;&lt;p&gt;何为“两个随机正整数”？正整数集合的度是无穷大，所以要使得所有整数对出现的概率相同是无法达到的。&lt;/p&gt;
&lt;p&gt;问题需要如此描述：我们用 $Z_2(t)$ 表示互质整数对的个数，其中每个整数对中的两个整数都不大于t，于是所要求的概率即为 $limit_{t \to \infty} \frac{Z_2(t)}{t ^2} $。&lt;/p&gt;
&lt;p&gt;我们忽略这个定义，直接考虑无穷的情形，两个整数互质，说明对任意的质数p，它们不能同时被p整除；一个随机正整数被p整除的概率为$1/p$，于是它们不同时被p整除的概率为$1-1/p ^2$，对于不同的质数p，相互独立；于是所求即为：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\prod\limits_{prime\ p} (1-1/p ^2)\tag{1}\label{eq1}&lt;br&gt;$$.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;更加严密地，我们有 $t ^k = \sum\limits_{d | t} Z_k(t/d)$，等式左边为k元正整数向量的个数（所有成员不大于t），右边为所有k个正整数最大公约数为d时的个数（gcd为d时，若将所有整数除以d，得到的向量正是$Z_k(t/d)中的一员，即每个数不大于t/d，且gcd为1。这是一个同构关系$）。&lt;/p&gt;
&lt;p&gt;对上式进行 Möbius 反演变换，得到 $Z_k(t) = \sum\limits_{d | t} \mu(d)(t/d) ^k$，于是$\frac{Z_k(t)}{t ^k} = \sum\limits_{d | t} \frac{\mu(d)}{d ^k}$，于是当 $t \to \infty$ 时，所求为：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\sum\limits_{d = 1} ^{\infty} \frac{\mu(d)}{d ^k} = \frac{1}{\zeta(k)}\tag{2}\label{eq2}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;zeta函数的定义以及该等式的证明见下文。&lt;/p&gt;
&lt;h2 id=&quot;Riemann-Zeta-Function&quot;&gt;&lt;a href=&quot;#Riemann-Zeta-Function&quot; class=&quot;headerlink&quot; title=&quot;Riemann Zeta Function&quot;&gt;&lt;/a&gt;Riemann Zeta Function&lt;/h2&gt;&lt;p&gt;黎曼Zeta函数是一个知名函数，在数论，物理等多个领域有广泛的应用。&lt;br&gt;定义如下 $\zeta(s) = \sum\limits_{n=1} ^{\infty} \frac{1}{n ^s}$，接下来我们证明：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\zeta(s) = \prod\limits_{prime\ p} \frac{1}{1-p ^{-s}}\tag{3}\label{eq3}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;从而可以推出，&lt;code&gt;随机k个正整数的gcd为1的概率为&lt;/code&gt; $1/\zeta(k)$.（通过类似于$\eqref{eq1}$的分析过程）&lt;/p&gt;
&lt;p&gt;该结论称为 “Euler product formula for the Riemann zeta function”. 事实它对复数域上的s，在满足s的实部大于1的时候均成立，我在这不求甚解，只关心s为整数的情况。先来看下欧拉给出的符合直觉的证明，该证明只用到了初等数学的知识，非常的直接。&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\zeta(s) = 1 + 1/2 ^s + 1/3 ^s + 1/4 ^s \cdots \\&lt;br&gt;\zeta(s)/2 ^s = 1/2 ^s + 1/4 ^s + 1/6 ^s + 1/8 ^s \cdots \\&lt;br&gt;(1-1/2 ^s)\zeta(s) = 1 + 1/3 ^s + 1/5 ^s + 1/7 ^s \cdots \\&lt;br&gt;(1-1/2 ^s)/3 ^s \zeta(s) = 1/3 ^s + 1/9 ^s + 1/15 ^s \cdots \\&lt;br&gt;(1-1/2 ^s)(1-1/3 ^s) \zeta(s) = 1 + 1/5 ^s + 1/7 ^s + 1/11 ^s \cdots \\&lt;br&gt;\vdots \\&lt;br&gt;\prod\limits_{prime\ p} (1-p ^s) \zeta(s) = 1&lt;br&gt;$$&lt;/p&gt;
&lt;h2 id=&quot;Dirichlet-Series&quot;&gt;&lt;a href=&quot;#Dirichlet-Series&quot; class=&quot;headerlink&quot; title=&quot;Dirichlet Series&quot;&gt;&lt;/a&gt;Dirichlet Series&lt;/h2&gt;&lt;p&gt;狄力克雷级数与黎曼Zeta函数有密切的联系，我们可以通过它的相关理论证明一些重要的结论。&lt;br&gt;其定义如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\mathfrak{D}^{A}_w(s) = \sum\limits_{a \in A} \frac{1}{w(a) ^s} = \sum\limits_{n=1} ^{\infty} \frac{a_n}{n ^s}.&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;其中A为一个集合，w为一个$A \to \mathbb{N}$的函数，它满足如下的运算规则：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;A \cap B = \varnothing \rightarrow \\&lt;br&gt;\mathfrak{D}^{A \uplus B}_w(s) = \mathfrak{D}^{A}_w(s) + \mathfrak{D}^{B}_w(s) \\&lt;br&gt;\forall (a, b) \in A \times B, w(a,b) = u(a)v(b) \rightarrow \\&lt;br&gt;\mathfrak{D}^{A \times B}_w(s) = \mathfrak{D}^{A}_u(s) \cdot \mathfrak{D}^{B}_v(s)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;这两个运算规则也很符合直觉，类似多项式展开… 利用这两个定理， “Euler product formula for the Riemann zeta function” 可以这样证明：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\zeta(s) = \mathfrak{D}^{\mathbb{N}}_{\mathrm{id}}(s) = \prod\limits_{prime\ p}&lt;br&gt;\mathfrak{D}^{\{p ^n : n \in \mathbb{N}\}}_{\mathrm{id}}(s) = \prod_{prime\ p} \sum_{n \in \mathbb{N}} \mathfrak{D}^{\{p ^n\}}_{\mathrm{id}}(s) \\&lt;br&gt;= \prod\limits_{prime\ p} \sum\limits_{n \in \mathbb{N}} \frac{1}{(p ^n) ^s}&lt;br&gt;= \prod\limits_{prime\ p} \sum\limits_{n \in \mathbb{N}} \left(\frac{1}{p ^s}\right) ^n&lt;br&gt;= \prod_{prime\ p} \frac{1}{1-p ^{-s}}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;就是说将所有的正整进行质因数分解，于是得到正整数到一个质因数指数向量的一一映射，正整数集合便可以表示成无穷个质数幂次集合的笛卡尔积…&lt;/p&gt;
&lt;h3 id=&quot;Dirichlet-Convolution&quot;&gt;&lt;a href=&quot;#Dirichlet-Convolution&quot; class=&quot;headerlink&quot; title=&quot;Dirichlet Convolution&quot;&gt;&lt;/a&gt;Dirichlet Convolution&lt;/h3&gt;&lt;p&gt;我们可以通过狄力克雷卷积证明结论$\eqref{eq2}$。&lt;/p&gt;
&lt;p&gt;可以用另一种方式表示狄力克雷级数：$DG(f, s) = \sum\limits_{n=1}^{\infty} \frac{f(n)}{n ^s}$.&lt;br&gt;定义卷积如下 $(f * g)(n) = \sum\limits_{d|n}f(d)g(n/d)$，可以得到卷积公式如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;DG(f, s) \cdot DG(g, s) = DG(f * g, s)\tag{4}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;将定义直接带入，展开，右边的每一项在左边出现且仅出现一次。&lt;br&gt;根据这条定理我们有：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\zeta(s) \cdot \sum\limits_{n=1}^{\infty}\frac{\mu(n)}{n ^s} =&lt;br&gt;DG(1, s) \cdot DG(\mu, s) = DG(1 * \mu, s) =&lt;br&gt;\sum\limits_{n=1}^{\infty}\frac{\sum\limits_{d|n}\mu(d)}{n ^s} = 1&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;注意到上式右边的通项分子满足：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\sum\limits_{d|n}\mu(d) =&lt;br&gt; \begin{cases}&lt;br&gt;    1 &amp;amp;\mbox{n = 1} \\&lt;br&gt;    0 &amp;amp;\mbox{n &amp;gt; 1}&lt;br&gt;\end{cases}&lt;br&gt;$$&lt;/p&gt;
&lt;h2 id=&quot;Basel-Problem&quot;&gt;&lt;a href=&quot;#Basel-Problem&quot; class=&quot;headerlink&quot; title=&quot;Basel Problem&quot;&gt;&lt;/a&gt;Basel Problem&lt;/h2&gt;&lt;p&gt;事实上要求原问题的解，根据公式$\eqref{eq3}$以及其推论，我们只需要计算$\zeta(2)$即可，之所以用Möbius反演绕了一圈，其实只是为了将几个著名的结论串在一起，以揭示其内在联系。最终我们还是无法避免地需要求这个级数和。&lt;/p&gt;
&lt;h3 id=&quot;Euler’s-Approach&quot;&gt;&lt;a href=&quot;#Euler’s-Approach&quot; class=&quot;headerlink&quot; title=&quot;Euler’s Approach&quot;&gt;&lt;/a&gt;Euler’s Approach&lt;/h3&gt;&lt;p&gt;这个问题最早由欧拉解决，考虑sin(x)的泰勒展开，得到：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\frac{sin(x)}{x} = 1 - x ^2/3! + x ^4/5! - x ^6/7! + \cdots \tag{5}\label{eq5}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;又，根据 “Weierstrass factorization theorem”, 有：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\frac{sin(x)}{x} = (1-\frac{x}{\pi})(1+\frac{x}{\pi})(1-\frac{x}{2\pi})(1+\frac{x}{2\pi})(1-\frac{x}{3\pi})(1+\frac{x}{3\pi})\cdots \\&lt;br&gt;= (1-\frac{x ^2}{\pi ^2})(1-\frac{x ^2}{4\pi ^2})(1-\frac{x ^2}{9\pi ^2})\cdots \tag{6}\label{eq6}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;其实就是因式分解，只不过是在复数域上进行。比较 $\eqref{eq5}, \eqref{eq6}$ 中的二次项系数，容易得出：$\zeta(2) = \sum\limits_{n=1}^{\infty} 1/n ^2 = \pi ^2/6$&lt;/p&gt;
&lt;h3 id=&quot;Other-Approaches&quot;&gt;&lt;a href=&quot;#Other-Approaches&quot; class=&quot;headerlink&quot; title=&quot;Other Approaches&quot;&gt;&lt;/a&gt;Other Approaches&lt;/h3&gt;&lt;p&gt;wikipedia还给出了三种解法，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用zeta函数和 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bernoulli_number&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bernoulli number&lt;/a&gt; 的关系公式 $\zeta(2n) = \frac{(2\pi)^{2n}(-1)^{n+1} B_{2n}}{2\cdot(2n)!}$&lt;/li&gt;
&lt;li&gt;通过对 $f(x) = 2 \sum\limits_{n=1}^{\infty}\frac{(-1)^{n+1}}{n} sin(nx)$ 进行傅里叶变换，然后通过 &lt;a href=&quot;https://en.wikipedia.org/wiki/Parseval&amp;#39;s_identity&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Parseval’s identity&lt;/a&gt;（如果没记错的话也叫能量公式）求值&lt;/li&gt;
&lt;li&gt;通过不等式夹逼&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的解法见参考链接。&lt;/p&gt;
&lt;h2 id=&quot;PS&quot;&gt;&lt;a href=&quot;#PS&quot; class=&quot;headerlink&quot; title=&quot;PS&quot;&gt;&lt;/a&gt;PS&lt;/h2&gt;&lt;p&gt;一个简单的数学问题可以将诸多著名的结论联系起来，贯穿了数论，概率论，数学分析，复变等多个分支；而wikipedia的内容组织形式以及其足够的专业度让我可以完全在站内找到我所需要的答案。&lt;/p&gt;
&lt;h2 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Möbius_inversion_formula&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Möbius inversion formula&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Proof_of_the_Euler_product_formula_for_the_Riemann_zeta_function&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Proof of the Euler product formula for the Riemann zeta function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_series&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dirichlet series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_convolution&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dirichlet convolution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Basel_problem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Basel problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Bernoulli_number&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bernoulli number&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Parseval&amp;#39;s_identity&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Parseval’s identity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Weierstrass_factorization_theorem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Weierstrass factorization theorem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Coprime_integers&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Coprime integers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A-Conclusion&quot;&gt;&lt;a href=&quot;#A-Conclusion&quot; class=&quot;headerlink&quot; title=&quot;A Conclusion&quot;&gt;&lt;/a&gt;A Conclusion&lt;/h2&gt;&lt;p&gt;听说了一个有趣的结论：两个随机的正整数互质的概率为 $\frac{6}{\pi ^2}$，对它的推导过程感到好奇，于是通过wikipedia学习了一些数学知识…&lt;/p&gt;
&lt;h2 id=&quot;Basic-Analysis&quot;&gt;&lt;a href=&quot;#Basic-Analysis&quot; class=&quot;headerlink&quot; title=&quot;Basic Analysis&quot;&gt;&lt;/a&gt;Basic Analysis&lt;/h2&gt;&lt;p&gt;何为“两个随机正整数”？正整数集合的度是无穷大，所以要使得所有整数对出现的概率相同是无法达到的。&lt;/p&gt;
&lt;p&gt;问题需要如此描述：我们用 $Z_2(t)$ 表示互质整数对的个数，其中每个整数对中的两个整数都不大于t，于是所要求的概率即为 $limit_{t \to \infty} \frac{Z_2(t)}{t ^2} $。&lt;/p&gt;
&lt;p&gt;我们忽略这个定义，直接考虑无穷的情形，两个整数互质，说明对任意的质数p，它们不能同时被p整除；一个随机正整数被p整除的概率为$1/p$，于是它们不同时被p整除的概率为$1-1/p ^2$，对于不同的质数p，相互独立；于是所求即为：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\prod\limits_{prime\ p} (1-1/p ^2)\tag{1}\label{eq1}&lt;br&gt;$$.&lt;/p&gt;
    
    </summary>
    
      <category term="fun" scheme="http://farseer.cn/categories/fun/"/>
    
    
      <category term="math" scheme="http://farseer.cn/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>The Byzantine Generals Problem</title>
    <link href="http://farseer.cn/2015/05/17/the-byzantine-generals-problem/"/>
    <id>http://farseer.cn/2015/05/17/the-byzantine-generals-problem/</id>
    <published>2015-05-16T16:00:00.000Z</published>
    <updated>2016-02-17T03:16:44.189Z</updated>
    
    <content type="html">&lt;h2 id=&quot;闲扯&quot;&gt;&lt;a href=&quot;#闲扯&quot; class=&quot;headerlink&quot; title=&quot;闲扯&quot;&gt;&lt;/a&gt;闲扯&lt;/h2&gt;&lt;p&gt;之前挖下的坑还没有填完，但在此之前，由于各种原因，我决定先写些有关拜占庭将军问题的东西。&lt;/p&gt;
&lt;p&gt;拜占庭将军问题是可信计算中的一个非常经典的问题，这个名称我估计是源于Lamport对古罗马的莫名情愫。关于历史的问题，我不懂就不逼逼了。&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;p&gt;拜占庭军队有许多分支，驻扎在敌人城外，每一分支由各自的将军指挥。将军们只能靠通讯员进行通讯。在观察了敌人以后，忠诚的将军们必须制订一个统一的行动计划。然而，这些将军中有叛徒。叛徒试图扰乱计划的制定。&lt;/p&gt;
&lt;p&gt;因此，能够解决该问题的正确算法必须保证如下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有忠诚的将军能够达成相同的行动计划。&lt;/li&gt;
&lt;li&gt;少数的叛徒不能使忠诚的将军做出错误的计划。&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;What-is-a-bad-plan&quot;&gt;&lt;a href=&quot;#What-is-a-bad-plan&quot; class=&quot;headerlink&quot; title=&quot;What is a bad plan?&quot;&gt;&lt;/a&gt;What is a bad plan?&lt;/h3&gt;&lt;p&gt;事实上，我们很难定义什么样的计划是错误的，但是我们可以提出更高的要求来保证计划是正确的。&lt;br&gt;作如下假设：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的将军根据占据独立作出判断，不失一般性，此处将判断简化为 attack/retreat 二者之一。&lt;/li&gt;
&lt;li&gt;用 w(i) 表示第i个将军作出的判断。&lt;ol&gt;
&lt;li&gt;如果第i个将军是忠诚的，那么他发出的表示自己意见的消息都如下：“我是i，我认为应该w(i)”。&lt;/li&gt;
&lt;li&gt;如果第i个将军是叛徒，那么他可以给不同的将军发送表达不同意愿的消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;每个将军可以转述别人的消息，如：“我是i，j告诉我说他认为应该w’(j)”。&lt;ol&gt;
&lt;li&gt;同样的道理，忠诚的将军在转述的时候也不说谎。&lt;/li&gt;
&lt;li&gt;叛徒则可以随意造谣。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最后每个将军根据接收到的消息猜测所有人的判断，最后得到一个判断矩阵V，其中$V_{ij}$表示将军i认为将军j的判断。&lt;ol&gt;
&lt;li&gt;第i个将军只具有V中第i行信息的读写权限，因此最后的决定完全取决于该行向量。&lt;/li&gt;
&lt;li&gt;当i将军收到“我是j，我认为该w’(j)”这样的消息的时候，他并不能直接将$V_{ij}$置为w’(j)，因为j有可能是叛徒。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;所有忠诚将军在得到最终V中对应的行向量之后，有统一的函数来将其映射为最终决定。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上述假设的基础上，我们认为一个正确的算法最终能够使 V 满足如下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于任意两个都是忠诚的将军，设为m和n，其在V中对应的行向量（第m行和第n行）完全相同，从而推出所有忠将的决定相同。&lt;/li&gt;
&lt;li&gt;对于任意两个忠诚的将军，m&amp;amp;n，$V_{ij} = w(j)$，也就是说忠诚将军的意志不被曲解。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果满足这两个条件，那么最终达到的忠将之间的一致决定我们认为就是正确的。&lt;/p&gt;
&lt;h3 id=&quot;Interactive-Consistency-Conditions&quot;&gt;&lt;a href=&quot;#Interactive-Consistency-Conditions&quot; class=&quot;headerlink&quot; title=&quot;Interactive Consistency Conditions&quot;&gt;&lt;/a&gt;Interactive Consistency Conditions&lt;/h3&gt;&lt;p&gt;上述要求有一个等价形式。描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n个将军，其中有一个统帅c，n-1个副官l.&lt;/li&gt;
&lt;li&gt;统帅下达命令，副官则只能传达命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法需要满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IC1: 所有忠诚的副官都执行相同的命令。&lt;/li&gt;
&lt;li&gt;IC2: 如果统帅是忠诚的，那么所有忠诚的副官都执行统帅下达的命令。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实就是将之前的V拆成不同的列，在决定第i列时，将军i作为统帅，其余将军作为副官。&lt;br&gt;本文之后所说的拜占庭将军问题，都是采用这样的简化模型。&lt;/p&gt;
&lt;h2 id=&quot;Impossibility-Results&quot;&gt;&lt;a href=&quot;#Impossibility-Results&quot; class=&quot;headerlink&quot; title=&quot;Impossibility Results&quot;&gt;&lt;/a&gt;Impossibility Results&lt;/h2&gt;&lt;p&gt;拜占庭将军问题在如下情况无解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不小于1/3的将军是叛徒。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Proof-of-1-traitor-in-3-generals&quot;&gt;&lt;a href=&quot;#Proof-of-1-traitor-in-3-generals&quot; class=&quot;headerlink&quot; title=&quot;Proof of 1 traitor in 3 generals&quot;&gt;&lt;/a&gt;Proof of 1 traitor in 3 generals&lt;/h3&gt;&lt;p&gt;首先证明3个将军中有1个是叛徒时，无法解决。假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;副官1是忠诚的。&lt;/li&gt;
&lt;li&gt;副官1收到来自统帅的消息attack，来自副官2转述的消息retreat.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;则有以下两种情形。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/byz_1_in_3.png&quot; alt=&quot;byz&quot;&gt;&lt;/p&gt;
&lt;p&gt;副官1无法分辨哪一方的消息为假，但是如果是图1的情形，我们要求满足IC2，于是他只能选择相信统帅，执行attack; 同理，如果副官2也是忠将，也就是图2的情形，那么他也只能选择相信统帅，执行retreat. 于是两个忠诚的副官执行了不同的命令，违背了IC1.&lt;/p&gt;
&lt;h3 id=&quot;Proof-of-the-rest&quot;&gt;&lt;a href=&quot;#Proof-of-the-rest&quot; class=&quot;headerlink&quot; title=&quot;Proof of the rest&quot;&gt;&lt;/a&gt;Proof of the rest&lt;/h3&gt;&lt;p&gt;反证法，假设“m个叛徒，且总将军数不大于3m”时问题（下面简称为m-3m问题）有解，我们试图用这个解来构造上边1个叛徒3个将军问题（下面简称为1-3问题）的解，从而导出矛盾。&lt;/p&gt;
&lt;p&gt;将m-3m问题中的将军尽可能均匀地分成3份（目的是使3份处于等价地位，无法通过数量进行区分），因为叛徒的数量至少有三分之一，所以一定有一种分法使得某一组中全为叛徒。在这样的分配方式下，让这3组将军扮演1-3问题中的角色。进行如下模拟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果统帅不是叛徒，如上图1，则全为叛徒的那组扮演l2，统帅所在那组扮演c，其余扮演l1.&lt;/li&gt;
&lt;li&gt;如果统帅为叛徒，如上图2，则令统帅被分到全叛徒组，且该组扮演c，其余两组分别扮演l1和l2.&lt;/li&gt;
&lt;li&gt;扮演c的非统帅将军发送 “he said xxx”，这里的xxx与统帅发出的真实指令（同目标）相同。&lt;/li&gt;
&lt;li&gt;所有被分在非全叛徒组的叛徒都不表现为叛徒。&lt;/li&gt;
&lt;li&gt;组内成员互不通信，组间通信方式采取1-3问题中对应组角色之间的消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个忠将，由于他处于忠诚的组，组中的每个将军的行为都是忠诚的，他知道其余的组员会获得跟他完全一样的消息，所以组内的通信不会带来任何附加消息，因此可以忽略。于是模拟出的1-3问题的消息全集构成了原本m-3m问题的消息全集。&lt;/p&gt;
&lt;p&gt;根据假设，m-3m问题可解，根据解的IC1和IC2性质，可以推出模拟的1-3问题也有对应解，从而得到矛盾。&lt;/p&gt;
&lt;h2 id=&quot;Oral-Message-Algorithm&quot;&gt;&lt;a href=&quot;#Oral-Message-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Oral Message Algorithm&quot;&gt;&lt;/a&gt;Oral Message Algorithm&lt;/h2&gt;&lt;p&gt;如果通信的信道满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A1: 所有消息被准确送达。&lt;/li&gt;
&lt;li&gt;A2: 消息的接收者知道送信人的身份。&lt;/li&gt;
&lt;li&gt;A3: 消息的丢失可以被检测（timeout机制）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么当叛徒数量小于1/3时，问题有解，下面，用递归的方式给出算法 OM(m).&lt;/p&gt;
&lt;p&gt;首先，令majority函数返回一个向量中的众数，如果attack数量与retreat一样多，选择retreat.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OM(0) （适用于0个叛徒时）&lt;ol&gt;
&lt;li&gt;c发送命令给所有的l.&lt;/li&gt;
&lt;li&gt;每个l采用他从c收到的消息作为行动，如果没有收到消息，则执行retreat.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;OM(m) （适用于m个叛徒）&lt;ol&gt;
&lt;li&gt;c发送命令给所有的l.&lt;/li&gt;
&lt;li&gt;假设v(i)为第i个l收到的来自c的命令（默认retreat），他以OM(m-1)算法中c的角色向其余n-2个l发送消息：”c told me to v’(i)”.&lt;ol&gt;
&lt;li&gt;如果第i个l为忠将，则v’(i) = v(i).&lt;/li&gt;
&lt;li&gt;如果为叛徒，则v’(i)可视消息目标变化而变化。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;通过n-1次算法OM(m-1)，每个忠将确认所有的l“声称从c处获得的消息”。即每个忠将得到一个消息向量V，其中第i个是该l对”c told me to v’(i)”中v’(i)的判断v’’(i)，然后他将执行majority(V).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OM(1)如下图，此处由于信道的A2性质省略了”c told me to”的消息字样，但是当m更大时，两个l之间会有多条层次不同的消息，要注意区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/byz_OM.png&quot; alt=&quot;byz&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Proof-of-algorithm-OM-m&quot;&gt;&lt;a href=&quot;#Proof-of-algorithm-OM-m&quot; class=&quot;headerlink&quot; title=&quot;Proof of algorithm OM(m)&quot;&gt;&lt;/a&gt;Proof of algorithm OM(m)&lt;/h3&gt;&lt;p&gt;Lemma1: 对于任意的m和k，如果有多于2k+m个将军，且最多k个叛徒，则OM(m)满足IC2.&lt;/p&gt;
&lt;p&gt;Proof: 对m作归纳：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;m = 0时，所有l采用盲从的策略，必然满足IC2.&lt;/li&gt;
&lt;li&gt;设m = m’-1时成立。&lt;/li&gt;
&lt;li&gt;考虑OM(m’)的第2步，采用了n-1次OM(m’-1)算法，算法作用于n-1个将军，由于 $n-1 &amp;gt; 2k + (m’-1)$，归纳假设可知，&lt;br&gt;对任意i，如果第i个l忠诚，那么在他发出的 “c told me to v’(i)”的问题上，所有其它的忠诚的l判断出的 v’’(i) = v’(i) = v(i) （第一个等号根据IC2，第二个等号根据i忠诚）。&lt;/li&gt;
&lt;li&gt;由于 $n-1 &amp;gt; 2k + (m’-1) \geq 2k$，于是n-1个l中多数为忠诚，那么当c为忠时，他会给所有l发送同样的v，其中多数忠诚的l转发了相同的v，且被正确理解。于是任意忠的l所判断出的V中，多数为v，即 majority(V) = v，也就是IC2的要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Theorem1: 对任意m，最多m个叛徒，至少3m+1个将军时，OM(m)满足IC1和IC2.&lt;/p&gt;
&lt;p&gt;Proof: 对m作归纳：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;m = 0时，结论显然。&lt;/li&gt;
&lt;li&gt;m = m’-1时成立。&lt;/li&gt;
&lt;li&gt;令k = m’，利用Lemma1，可以证明OM(m’)满足IC2.&lt;/li&gt;
&lt;li&gt;只需证明IC1，也就是说，当c为叛徒时，所有忠的l还能够达成一致的决定。&lt;ol&gt;
&lt;li&gt;此时n-1个l中最多有m-1个叛徒，$n-1 &amp;gt; 3m’-1 &amp;gt; 3(m’-1)$，于是归纳假设可得，每个被执行的OM(m’-1)算法也满足IC1.&lt;/li&gt;
&lt;li&gt;也就是说，即使第i个l是叛徒，他所发出的”c told me to v’(i)”的消息在所有忠的l中被统一解读为v’’(i) (可能不等于v(i))，换句话说，所有忠的l可以得到完全一样的V.&lt;/li&gt;
&lt;li&gt;作用在相同的函数majority上，必然得到相同的结果，于是IC1也成立。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Signed-Messages-Algorithm&quot;&gt;&lt;a href=&quot;#Signed-Messages-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Signed Messages Algorithm&quot;&gt;&lt;/a&gt;Signed Messages Algorithm&lt;/h2&gt;&lt;p&gt;通过给消息进行签名来简化问题。在A1-A3的基础上加入如下假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A4: 忠将的签名不能被伪造，无法对“被他签名认证的消息”进行篡改。&lt;/li&gt;
&lt;li&gt;A5: 所有人可以识别任何一个将军的签名。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决问题，引入新的函数：choice(V)，它的输入为一组决定，输出为一个决定，且满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果V只包含一个元素v，则 choice(V) = v.&lt;/li&gt;
&lt;li&gt;choice(empty set) = retreat.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引入如下记号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$x:j$ 表示值x被将军i签名。&lt;/li&gt;
&lt;li&gt;$v:j:i$ 表示值v首先被将军j签名，然后$v:j$作为整体被将军i签名。&lt;/li&gt;
&lt;li&gt;每个将军i记录一个集合V(i)，包含所有他收到的签名合法的消息值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这样的假设下，给出算法SM(m):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;c发送签名了的消息v给所有l.&lt;ul&gt;
&lt;li&gt;若c为叛徒，则v可视目标而定，且可以选择只给部分的l发送消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于每个i：&lt;ol&gt;
&lt;li&gt;如果i从c收到消息$v:0$，并且V(i)为空，则令 V(i)={v}，且他将发送$v:0:i$给其他所有l.&lt;/li&gt;
&lt;li&gt;如果i收到消息$v:0:j_i:…:j_k$，并且v不在V(i)中，则将v添加到V(i)，如果 $k &amp;lt; m$，则他将发送$v:0:j_i:…:j_k:i$给所有除了$j_i…j_k$之外的l.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果i为叛徒，则他可以选择部分l转发消息，或者完全不转发，但是他无法更改已经被c签名的消息（根据A4）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对每个i，当他不再接收消息，他将执行choice(V(i)).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/byz_SM.png&quot; alt=&quot;byz&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来，证明该算法SM(m)在最多只有m个叛徒时满足IC1，IC2.&lt;/p&gt;
&lt;h3 id=&quot;Proof-of-algorithm-SM-m&quot;&gt;&lt;a href=&quot;#Proof-of-algorithm-SM-m&quot; class=&quot;headerlink&quot; title=&quot;Proof of algorithm SM(m)&quot;&gt;&lt;/a&gt;Proof of algorithm SM(m)&lt;/h3&gt;&lt;p&gt;Theorem2: SM(m)在最多m个叛徒时解决拜占庭将军问题。&lt;/p&gt;
&lt;p&gt;Proof:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意如果c为忠，则对于步骤2，根据A4，叛徒并不能修改v的值，于是所有的V(i)将只包含一个值v，IC2被满足。&lt;/li&gt;
&lt;li&gt;如果c为叛徒，我们只需证明对于忠的副官i和j，最后得到的V(i) = V(j).&lt;ol&gt;
&lt;li&gt;对于V(i)中的任意元素v，假设2中添加时对应的消息为$v:0:j_1:…:j_k$，如果j在$j_1…j_k$中，则v已被添加如V(j).&lt;/li&gt;
&lt;li&gt;j不在$j_1…j_k$中，分两种情况：&lt;ol&gt;
&lt;li&gt;$k &amp;lt; m$, 则i在接收到该消息后将会向j转发，于是v会出现在V(j)中。&lt;/li&gt;
&lt;li&gt;$k = m$，由于最多只有m个叛徒，c是叛徒，所以$j_1…j_k$中至少有一个忠诚的，他会将消息转发给j.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;综上所述，V(i) = V(j)，于是IC1满足。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Missing-Communication-Paths&quot;&gt;&lt;a href=&quot;#Missing-Communication-Paths&quot; class=&quot;headerlink&quot; title=&quot;Missing Communication Paths&quot;&gt;&lt;/a&gt;Missing Communication Paths&lt;/h2&gt;&lt;p&gt;以上算法均假设将军两两之间均可通信，但是现实中的情形往往不是如此。将将军视为节点，能够通信的两个将军之间连线，则&lt;br&gt;当所形成的图非完全图时，是否有办法解决拜占庭将军问题呢？&lt;/p&gt;
&lt;p&gt;首先引入概念regular-set，如果一个节点集合$\{i_1, …, i_p\}$满足如下条件，就说它是一个regular-set.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;集合中的每个元素都与i相连。&lt;/li&gt;
&lt;li&gt;对于任意不同于i的节点k，和1-p中的下表j，存在一条路径 $p_{j,k}$ 从 $i_j$ 到k，且不经过i；所有这样的路径 $p_{j,k}$ 除了k以外没有其它相同的节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果一个图被成为p-regular的，则它满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个节点的邻居集合形成一个regular-set.&lt;/li&gt;
&lt;li&gt;每个节点的度为p.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下左图给出了一个3-regular非完全图的例子，右边则为一个反例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/byz_regular.png&quot; alt=&quot;byz&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Algorithm-OM-m-p&quot;&gt;&lt;a href=&quot;#Algorithm-OM-m-p&quot; class=&quot;headerlink&quot; title=&quot;Algorithm OM(m, p)&quot;&gt;&lt;/a&gt;Algorithm OM(m, p)&lt;/h3&gt;&lt;p&gt;改进OM算法，使之能够解决3m-regular拓扑下的拜占庭将军问题。改进后的算法OM(m, p)如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择c的一个邻居集合N，N的大小为p，且N为regular-set.&lt;/li&gt;
&lt;li&gt;c将他的消息v发送给N中的每个l.&lt;/li&gt;
&lt;li&gt;对N中的每个i，副官i从c处接收到v(i)消息（默认为retreat），i将”c told me to v’(i)”以如下方式发送给任意其它副官k：&lt;ol&gt;
&lt;li&gt;m = 1, 则沿路径$p_{i,k}$发送，消息内容被直接信任。&lt;/li&gt;
&lt;li&gt;m &amp;gt; 1, 则他以统帅的角色使用OM(m-1, p-1)算法发送，新的通信关系图为将原本的c从原图G中移除所得。&lt;/li&gt;
&lt;li&gt;当i为忠时v’(i) = v(i)，否则v’(i)视k不同可以有不同选择。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;类似于OM(m)算法的第3步，每个N中的将军对步骤3中收到的所有”c told me to xxx”消息的值作判断，最后得出向量V，执行majority(V).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意到3中执行OM(m-1, p-1)算法时需要在新的统帅的邻居集合中选取大小为p-1的regular-set，因此要使算法能够持续进行，需要保证原图G为p-regular的。&lt;br&gt;因此我们可以规定，OM(m, p)算法只在G为p-regular时有定义。&lt;/p&gt;
&lt;h4 id=&quot;Proof-of-algorithm-OM-m-p&quot;&gt;&lt;a href=&quot;#Proof-of-algorithm-OM-m-p&quot; class=&quot;headerlink&quot; title=&quot;Proof of algorithm OM(m, p)&quot;&gt;&lt;/a&gt;Proof of algorithm OM(m, p)&lt;/h4&gt;&lt;p&gt;类似于OM(m)的证明，需要如下引理：&lt;/p&gt;
&lt;p&gt;Lemma2: 对于任意的$m &amp;gt; 0, k \geq 0, p \geq 2k + m$，如果最多k个叛徒，则OM(m, p)满足IC2.&lt;/p&gt;
&lt;p&gt;Proof: 对m作归纳:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;m = 1时，若c为忠，则所有的v(i) = v，考虑某个忠的副官i，他收到的步骤3中的消息均来自不相交的路径（regular-set的要求），这样的消息有$p \geq 2k+1$个，而叛徒最多不超过k，于是，一半以上的路径是全忠的（鸽巢定理）。于是i最终的V中有超过一半的值为v，majority(V) = v，IC2满足。&lt;/li&gt;
&lt;li&gt;假设m = m’-1时满足。&lt;/li&gt;
&lt;li&gt;m = m’时，如果c为忠，所有v(i) = v, 考虑某个忠的副官i，他收到的步骤3中的p个消息中，一半以上来自忠的l（p &amp;gt; 2k），归纳假设，步骤3中忠的l发出的消息”c told me to v”不会被曲解，即i最终的V中，一半以上为v，IC2满足。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Theorem3: 对任意的$m &amp;gt; 0, p \geq 3m$，最多m个叛徒时，算法OM(m, p)(有定义意味着G为p-regular)能够满足IC1, IC2, i.e. 可以解决拜占庭将军问题。&lt;/p&gt;
&lt;p&gt;Proof:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据Lemma2，令k=m，可得IC2满足，只需证明IC1，即c为叛徒的情况下，所有忠将的行为依然保持一致。为此我们只需证明所有忠将在步骤4中的V全等。&lt;/li&gt;
&lt;li&gt;m = 1时，最多一个叛徒，于是就是c，其余所有l为忠，根据算法步骤3中的情况1，所有的l收到同样的$V = \{v(i)\}$，IC1满足。&lt;/li&gt;
&lt;li&gt;与OM(m)的证明类似，对m作归纳可得结论，这里不再赘述。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OM(m, p)需要G至少为3m-regular，这是一个非常苛刻的要求，当总将军数为3m+1时，G必为完全图。因此这样的扩展算法并不是很有效。&lt;/p&gt;
&lt;h3 id=&quot;Extension-of-algorithm-SM&quot;&gt;&lt;a href=&quot;#Extension-of-algorithm-SM&quot; class=&quot;headerlink&quot; title=&quot;Extension of algorithm SM&quot;&gt;&lt;/a&gt;Extension of algorithm SM&lt;/h3&gt;&lt;p&gt;扩展算法SM时，不需要对G作非常苛刻的假设，事实上只需满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有忠将构成的子图是连通的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这被称为 weakest connectivity hypothesis，因为当它不满足时，拜占庭将军问题不可解，理由如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果c忠，且某个l与c之间通信必须经过一个叛徒，则无法保证该l会执行c发出的指令（考虑叛徒不作任何转发）。&lt;/li&gt;
&lt;li&gt;如果某两个l为忠，且他们之间通信必须经过一个叛徒，则无法保证他们会得到相同的判断（考虑c为叛徒，c给两个忠的l发不同消息，且其余叛徒不进行任何转发）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对SM算法的修改十分简单，只需在每一步发消息时去掉无法接收的部分即可。&lt;/p&gt;
&lt;p&gt;接下去证明如下定理：&lt;/p&gt;
&lt;p&gt;Theorem4: 对任意的m和d，如果最多m个叛徒，且所有忠将构成的子图具有直径d（最小的d使得任意两节点可以通过某长度不超过d的路径相连），则算法SM(m + d -1)满足IC1, IC2, i.e. 解决了拜占庭将军问题。&lt;/p&gt;
&lt;p&gt;Proof:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与Theorem2的证明类似，若c忠，则c发出的消息全为v，且不能被篡改，由于联通，每个忠的i可以收到合法的v，且V(i) = {v}，IC2满足。&lt;/li&gt;
&lt;li&gt;若c为叛徒，只需证明对于任意两个忠的i，j，如果i收到合法消息$v’:0:j_1:…:j_k$, 则j也能收到值为v’的合法消息，即V(i) = V(j).&lt;ol&gt;
&lt;li&gt;j在$j_1…j_k$中，则j已然收到，结论显然。&lt;/li&gt;
&lt;li&gt;$k &amp;lt; m$，则i将继续转发该消息，i与j之间有一条长度不超过d的忠路径，因此总条数为 $k + d &amp;lt; m + d $，不超过$m + d -1$，因而可以正确传达。&lt;/li&gt;
&lt;li&gt;$k \geq m$，则由于c为叛徒，最多m个叛徒，j1-jm中至少有一个忠，则在消息传递到他时，他会继续转发消息，该消息经过长度不超过d的忠路径之后必然能够到达j，结论成立。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以想见算法SM改更加具有实用价值。&lt;/p&gt;
&lt;h2 id=&quot;Conclusion&quot;&gt;&lt;a href=&quot;#Conclusion&quot; class=&quot;headerlink&quot; title=&quot;Conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;拜占庭将军问题可以很容易的同构到可信系统，其中出错的程序可能导致意想不到的结果，因此可被视作叛徒。算法OM和SM都能够用于解决这类问题，但是其通信开销巨大，然而在不作其它假设的前提下，这样的开销是必须的。&lt;/p&gt;
&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Lamport, Leslie, Robert Shostak, and Marshall Pease. “The Byzantine generals problem.” ACM Transactions on Programming Languages and Systems (TOPLAS) 4.3 (1982): 382-401.&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;闲扯&quot;&gt;&lt;a href=&quot;#闲扯&quot; class=&quot;headerlink&quot; title=&quot;闲扯&quot;&gt;&lt;/a&gt;闲扯&lt;/h2&gt;&lt;p&gt;之前挖下的坑还没有填完，但在此之前，由于各种原因，我决定先写些有关拜占庭将军问题的东西。&lt;/p&gt;
&lt;p&gt;拜占庭将军问题是可信计算中的一个非常经典的问题，这个名称我估计是源于Lamport对古罗马的莫名情愫。关于历史的问题，我不懂就不逼逼了。&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;p&gt;拜占庭军队有许多分支，驻扎在敌人城外，每一分支由各自的将军指挥。将军们只能靠通讯员进行通讯。在观察了敌人以后，忠诚的将军们必须制订一个统一的行动计划。然而，这些将军中有叛徒。叛徒试图扰乱计划的制定。&lt;/p&gt;
&lt;p&gt;因此，能够解决该问题的正确算法必须保证如下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有忠诚的将军能够达成相同的行动计划。&lt;/li&gt;
&lt;li&gt;少数的叛徒不能使忠诚的将军做出错误的计划。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="TCS" scheme="http://farseer.cn/categories/TCS/"/>
    
    
      <category term="distributed" scheme="http://farseer.cn/tags/distributed/"/>
    
      <category term="paper" scheme="http://farseer.cn/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>The Church-Rosser Theorem</title>
    <link href="http://farseer.cn/2015/05/03/the-church-rosser-theorem/"/>
    <id>http://farseer.cn/2015/05/03/the-church-rosser-theorem/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2016-02-17T03:16:44.125Z</updated>
    
    <content type="html">&lt;h2 id=&quot;闲扯&quot;&gt;&lt;a href=&quot;#闲扯&quot; class=&quot;headerlink&quot; title=&quot;闲扯&quot;&gt;&lt;/a&gt;闲扯&lt;/h2&gt;&lt;p&gt;最近写的尽是些有的没的，完全没有干货。怎么说，最近考虑在思考人生，价值观在改变，简而言之就是又退化到科学&amp;gt;&amp;gt;技术的中二阶段。一方面看到现阶段所谓“技术产物”的各种各样的问题，另一方面由于自身智力，能力，精力的限制，没有办法对其进行改进和提升，只能采取粗暴的、眼不见为净的鸵鸟政策。其实我知道自己是躲不掉的（当然我说的是找工作），但是还是想在不得不面对之前关心些别的，或者说补救些别的，能补多少是多少吧。年轻的时候有大把时间，却不想念书，现在老了，想念书了，却没有多少时间了（有时间也架不住嗜睡）。&lt;/p&gt;
&lt;p&gt;Anyway, 我接下来准备翻译大段的关于无类型lambda-calculus中Church-Rosser定理的证明，为什么要做这么无聊的事情？因为我觉得有趣…为什么不先完善下之前对STLC的证明？1.不求甚解是我的一贯毛（feng）病（ge）；2.这个定理在它的证明中会有一丢丢的作用，Normalization证明的补充会在之后进行。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;beta-eta-reduction&quot;&gt;&lt;a href=&quot;#beta-eta-reduction&quot; class=&quot;headerlink&quot; title=&quot;beta-eta-reduction&quot;&gt;&lt;/a&gt;beta-eta-reduction&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;$\beta-reduction$ 就不赘述了&lt;/li&gt;
&lt;li&gt;$\beta-equivalence$ 为其自反，对称，传递闭包，记作 $=_{\beta}$，描述的是这样的二元关系：两个表达式可以通过若干步正向或者反向的beta归约相互转化。&lt;/li&gt;
&lt;li&gt;$\eta-reduction$ 规定如果两个表达式作用在任意相同的表达式上，得到的结果相同，则可以认为两个表达式相同，即函数相同的定义。于是有$\lambda x.Mx \rightarrow_{\eta} M, where\ x \notin FV(M)$&lt;/li&gt;
&lt;li&gt;$\beta\eta-reduction$ 就是两者的结合，记作 $\rightarrow_{\beta\eta}$&lt;/li&gt;
&lt;li&gt;结合后的多步操作，即其自反，传递闭包记作 $\twoheadrightarrow_{\beta\eta}$，equivalence, normal form的概念也有相应的扩充&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Statement-of-Church-Rosser-Theorem&quot;&gt;&lt;a href=&quot;#Statement-of-Church-Rosser-Theorem&quot; class=&quot;headerlink&quot; title=&quot;Statement of Church-Rosser Theorem&quot;&gt;&lt;/a&gt;Statement of Church-Rosser Theorem&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用双箭头表示 $\twoheadrightarrow_{\beta}$ 或者 $\twoheadrightarrow_{\beta\eta}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果某M, N, P满足 $M \twoheadrightarrow N \land M \twoheadrightarrow P$，则存在某个Z，使得 $N \twoheadrightarrow Z \land P \twoheadrightarrow Z$。&lt;br&gt;就是说，不论在beta或者是beta-eta的操作语义下，如果N和P对于M都是多步可达的，那么它们必定共享某个可达的表达式Z，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Church_Rosser.png&quot; alt=&quot;cr&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;What-does-that-theorem-imply&quot;&gt;&lt;a href=&quot;#What-does-that-theorem-imply&quot; class=&quot;headerlink&quot; title=&quot;What does that theorem imply?&quot;&gt;&lt;/a&gt;What does that theorem imply?&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Corollary 1&lt;/strong&gt; : 如果 $M =_{\beta} N$，则存在某表达式Z，使得$M,N \twoheadrightarrow_{\beta} Z$，对beta-eta有同样结论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt; : 前提条件等价于如下描述：存在一个有限的表达式序列$M_0, M_1, …, M_n$，其中相邻的两个表达式满足关系$\leftarrow_{\beta}$或者$\rightarrow_{\beta}$，且头和尾分别是M和N。&lt;/p&gt;
&lt;p&gt;对n进行归纳，当n为0时，M与N恒等，结论显然。若n-1时成立，归纳假设，存在Z’使得$M \twoheadrightarrow_{\beta} Z’ \land M_{n-1} \twoheadrightarrow_{\beta} Z’$。&lt;br&gt;N和$M_n$之间的关系有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$N \rightarrow_{\beta} M_{n-1}$ : 于是有 $N \twoheadrightarrow_{\beta} Z’$，于是Z’即满足&lt;/li&gt;
&lt;li&gt;$N \leftarrow_{\beta} M_{n-1}$ : 我们将Church-Rosser定理作用于$M_{n-1}, Z’, N$，于是存在Z使得 $Z’ \twoheadrightarrow_{\beta} Z \land N \twoheadrightarrow_{\beta} Z$，于是 $M \twoheadrightarrow_{\beta} Z’ \twoheadrightarrow_{\beta} Z$，得证。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于beta-eta有类似证明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Corollary 2&lt;/strong&gt; : 如果N是一个normal form(无法继续归约)，$N =_{\beta} M$，则 $M \twoheadrightarrow_{\beta} N$, beta-eta类似。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt; : &lt;strong&gt;1&lt;/strong&gt;的简单推论，Z只能是N&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Corollary 3&lt;/strong&gt; : 如果$M =_{\beta} N$，则其中一者的normal form也是另一者的normal form, beta-eta类似。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt; : 不妨设M有normal form Z，于是有$M =_{\beta} Z =_{\beta} N$，于是根据&lt;strong&gt;2&lt;/strong&gt;有 $N \twoheadrightarrow_{\beta} Z$，得证。&lt;/p&gt;
&lt;p&gt;可以看出&lt;strong&gt;3&lt;/strong&gt;是一个很有意义的推论，有助于后续性质的推导。&lt;/p&gt;
&lt;h3 id=&quot;Why-is-that-hard-to-proof&quot;&gt;&lt;a href=&quot;#Why-is-that-hard-to-proof&quot; class=&quot;headerlink&quot; title=&quot;Why is that hard to proof?&quot;&gt;&lt;/a&gt;Why is that hard to proof?&lt;/h3&gt;&lt;p&gt;对下图中的a, b, c作与该定理的描述相似的解读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Church_Rosser_abc.png&quot; alt=&quot;cr-abc&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a等价于Church-Rosser定理&lt;/li&gt;
&lt;li&gt;容易证明c蕴含a，但是$\beta\eta-reduction$不满足c(又叫Diamond property)&lt;/li&gt;
&lt;li&gt;a蕴含b，反之不然（反例见下图），于是我们无法通过证明b来证明a&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Church_Rosser_ba.png&quot; alt=&quot;cr-ba&quot;&gt;&lt;/p&gt;
&lt;p&gt;定理的证明过程通过寻找一个满足如下性质的归约关系 $\triangleright$ 来克服上述困难：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\triangleright$ 满足c&lt;/li&gt;
&lt;li&gt;其自反，传递闭包即为$\twoheadrightarrow_{\beta\eta}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设能够找到这样的关系，那么根据其c性质推出其a性质，又在a中，其多步的闭包与beta-eta相同，便能证明beta-eta满足a性质&lt;/p&gt;
&lt;h2 id=&quot;Proof-of-the-Theorem&quot;&gt;&lt;a href=&quot;#Proof-of-the-Theorem&quot; class=&quot;headerlink&quot; title=&quot;Proof of the Theorem&quot;&gt;&lt;/a&gt;Proof of the Theorem&lt;/h2&gt;&lt;p&gt;$\triangleright$ 定义如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\overline{M \triangleright M}$&lt;/li&gt;
&lt;li&gt;$\dfrac{P \triangleright P’ \ \ N \triangleright N’}{PN \triangleright P’N’}$&lt;/li&gt;
&lt;li&gt;$\dfrac{N \triangleright N’}{\lambda x.N \triangleright \lambda x.N’}$&lt;/li&gt;
&lt;li&gt;$\dfrac{Q \triangleright Q’ \ \ N \triangleright N’}{(\lambda x.Q)N \triangleright Q’[N’/x]}$&lt;/li&gt;
&lt;li&gt;$\dfrac{P \triangleright P’, where\ x \notin FV(P)}{\lambda x.Px \triangleright P’}$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Lemma1&quot;&gt;&lt;a href=&quot;#Lemma1&quot; class=&quot;headerlink&quot; title=&quot;Lemma1&quot;&gt;&lt;/a&gt;Lemma1&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Lemma1&lt;/strong&gt; :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果$M \rightarrow_{\beta} M’$ 则 $M \triangleright M’$&lt;/li&gt;
&lt;li&gt;如果$M \triangleright M’$ 则 $M \twoheadrightarrow_{\beta\eta} M’$&lt;/li&gt;
&lt;li&gt;$\twoheadrightarrow_{\triangleright} = \twoheadrightarrow_{\beta\eta}$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt; :&lt;/p&gt;
&lt;p&gt;1和2类似，通过对前提中的关系进行归纳便容易得证，这里就不展开冗长的过程了。事实上这个新的关系又叫作&lt;strong&gt;parallel one-step reduction&lt;/strong&gt;，它的每步归约可以比beta-eta多做一些事情，相当于把多步并作一步进行（也可以不选择并行，根据1），这么理解之后1和2的结论便是显然成立的。&lt;/p&gt;
&lt;p&gt;至于3，根据1可得，若beta-eta多步归约可达，则parallel one-step多步归约可达，即$\twoheadrightarrow_{\triangleright} \subseteq \twoheadrightarrow_{\beta\eta}$；根据2，反之，即$\twoheadrightarrow_{\beta\eta} \subseteq \twoheadrightarrow_{\triangleright}$。&lt;/p&gt;
&lt;h3 id=&quot;Lemma2&quot;&gt;&lt;a href=&quot;#Lemma2&quot; class=&quot;headerlink&quot; title=&quot;Lemma2&quot;&gt;&lt;/a&gt;Lemma2&lt;/h3&gt;&lt;p&gt;至此，我们只需证明parallel one-step满足性质c。为此，我们还需要若干引理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lemma2&lt;/strong&gt; : 若 $M \triangleright M’ \land U \triangleright U’$，则 $M[U/y] \triangleright M’[U’/y]$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt; : 对 $M \triangleright M’$ 进行归纳，共5种情况，对于标号1, 2, 3, 5的情况，结论显然，不再赘述，针对4：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有$M = (\lambda x.Q)N \land M’ = Q’[N’/x] \land Q \triangleright Q’ \land N \triangleright N’$&lt;/li&gt;
&lt;li&gt;归纳假设，有$Q[U/y] \triangleright Q’[U’/y] \land N[U/y] \triangleright N’[U’/y]$&lt;/li&gt;
&lt;li&gt;根据规则4，有$(\lambda x.Q[U/y]) N[U/y] \triangleright Q’[U’/y][N’[U’/y]/x] = Q’[N’/x][U’/y]$ 即 $M[U/y] \triangleright M’[U’/y]$，得证&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Lemma3&quot;&gt;&lt;a href=&quot;#Lemma3&quot; class=&quot;headerlink&quot; title=&quot;Lemma3&quot;&gt;&lt;/a&gt;Lemma3&lt;/h3&gt;&lt;p&gt;引入最终形态（maximal parallel one-step reduct）M*的概念，形式化定义如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$x^* = x$, for variable x&lt;/li&gt;
&lt;li&gt;$(PN)^* = P^*N^*$, if PN is not a $\beta-redex$&lt;/li&gt;
&lt;li&gt;$(\lambda x.N)^* = \lambda x.N^*$, if $\lambda x.N$ is not a $\eta-redex$&lt;/li&gt;
&lt;li&gt;$((\lambda x.Q) N)^* = Q^*[N^*/x]$&lt;/li&gt;
&lt;li&gt;$(\lambda x.P x)^* = P^*$, if $x \notin FV(P)$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Lemma3&lt;/strong&gt; : 若 $M \triangleright M’$，则 $M’ \triangleright M^*$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt; : 对M的大小进行归纳，首先，按照惯例，将前提分成5种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;M = M’ = x, 又 M* = x, 成立&lt;/li&gt;
&lt;li&gt;M = PN，M’ = P’N’, $P \triangleright P’ \land N \triangleright N’$. 归纳假设，得到 $P’ \triangleright P^* \land N’ \triangleright N^*$，再分为两种情况：&lt;ol&gt;
&lt;li&gt;PN不是个beta可约式，根据终极形态的定义2，$M’ = P’ N’ \triangleright P^*N^* = M^*$，得证&lt;/li&gt;
&lt;li&gt;PN beta可约，则P为一个lambda函数，设$P = \lambda x.Q$，则根据终极心态定义4 $M^* = Q^*[N^*/x]$，对$P \triangleright P’$再分情况，只能是1, 3, 5：&lt;ol&gt;
&lt;li&gt;若为1，$M’ = PN’ = Q[N’/x]$，由于Q为M的一部分，大小小于M，归纳假设，有$Q \triangleright Q \triangleright Q^*$，于是根据&lt;strong&gt;Lemma2&lt;/strong&gt;, $M’ = Q[N’/x] \triangleright Q^*[N^*/x] = M^*$&lt;/li&gt;
&lt;li&gt;若为3，$P’ = \lambda x.Q’ \land Q \triangleright Q’$，同理，Q的大小小于M，归纳假设有$Q’ \triangleright Q^*$，于是根据归约条件4，$M’ = (\lambda x.Q’)N’ \triangleright Q^*[N^*/x] = M^*$&lt;/li&gt;
&lt;li&gt;若为5，$P = \lambda x.R’x \land P’ = R’ \land R \triangleright R’$ 且x不是P’的自由变量，Rx是M的子式，归纳假设，$Rx \triangleright R’x \triangleright (Rx)^*$，根据&lt;strong&gt;Lemma2&lt;/strong&gt;，有$M’ = R’N’ = (R’x)[N’/x] \triangleright (Rx)^*[N^*/x] = M^*$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;$M = \lambda x.N \land M’ = \lambda x.N’ \land N \triangleright N’$，分两种情况&lt;ol&gt;
&lt;li&gt;M eta不可约，则根据终极形态定义3，$M^* = \lambda x.N^*$，根据归约定义3，$M’ = \lambda x.N’ \triangleright \lambda x.N^* = M^*$&lt;/li&gt;
&lt;li&gt;M eta可约，则$M = \lambda x.Px \land N=Px \land x \notin FV(P)$，根据终极形态定义5，M* = P*, 对$N \triangleright N’$再分情况，只能是1, 2, 4：&lt;ol&gt;
&lt;li&gt;若为1，N=N’=Px, P为M的子式，归纳假设，根据归约条件5，$P \triangleright P \triangleright P^*, M’ = \lambda x.Px \triangleright P^* = M^*$&lt;/li&gt;
&lt;li&gt;若为2，$N’ = P’x \land P \triangleright P’$，同理，归纳假设，根据归约条件5， $P’ \triangleright P^*, M’ = \lambda x.P’x \triangleright P^* = M^*$&lt;/li&gt;
&lt;li&gt;若为4，$P = \lambda y.Q \land N’ = Q’[x/y] \land Q \triangleright Q’$，P为M子式，有$P \triangleright \lambda y.Q’ \triangleright P^*$，于是$M’ = \lambda x.Q’[x/y] = \lambda y.Q’ \triangleright P^*$，右边最后一个等号是因为x不是Q’的自由变量&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;$M = (\lambda x.Q)N \land M’ = Q’[N’/x] \land Q \triangleright Q’ \land N \triangleright N’$，根据终极形态定义4，$M^* = Q^*[N^*/x]$，根据&lt;strong&gt;Lemma2&lt;/strong&gt;，得证&lt;/li&gt;
&lt;li&gt;$M = \lambda x.Px \land M’=P’ \land P \triangleright P’$，同上，归纳假设，$M’ = P’ \triangleright P^* = M^*$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Q.E.D&lt;/p&gt;
&lt;h3 id=&quot;Diamond-Property&quot;&gt;&lt;a href=&quot;#Diamond-Property&quot; class=&quot;headerlink&quot; title=&quot;Diamond Property&quot;&gt;&lt;/a&gt;Diamond Property&lt;/h3&gt;&lt;p&gt;终于，可以通过Lemma3来证明parallel one-step满足c属性，i.e. Diamond Property了。&lt;/p&gt;
&lt;p&gt;回忆下c属性的描述： 若$M \triangleright N \land M \triangleright P$，则存在Z满足 $N \triangleright Z \land P \triangleright Z$。&lt;/p&gt;
&lt;p&gt;这里只需要使 Z = M* ，根据&lt;strong&gt;Lemma3&lt;/strong&gt;，结论显然。至此，结合前文的铺垫，Church-Rosser定理便得到了证明。&lt;/p&gt;
&lt;p&gt;对于beta-reduction，只需要调整构造，将对应的规则5都删去即可。&lt;/p&gt;
&lt;h2 id=&quot;叹为观止&quot;&gt;&lt;a href=&quot;#叹为观止&quot; class=&quot;headerlink&quot; title=&quot;叹为观止&quot;&gt;&lt;/a&gt;叹为观止&lt;/h2&gt;&lt;p&gt;如此神奇的证明，我虽然能理解它是有道理的，但是完全无法想象出这样奇妙的证明是怎么构造出来的，尤其是其中parallel one-step和maximal reduct的构造。&lt;br&gt;相比与糟糕的应用，糟糕的工具，糟糕的OS（尤其是IOS），糟糕的服务，糟糕的设备……数学是如此的美好~~&lt;/p&gt;
&lt;h2 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mathstat.dal.ca/~selinger/papers/lambdanotes.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lecture Notes on the Lambda Calculus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;闲扯&quot;&gt;&lt;a href=&quot;#闲扯&quot; class=&quot;headerlink&quot; title=&quot;闲扯&quot;&gt;&lt;/a&gt;闲扯&lt;/h2&gt;&lt;p&gt;最近写的尽是些有的没的，完全没有干货。怎么说，最近考虑在思考人生，价值观在改变，简而言之就是又退化到科学&amp;gt;&amp;gt;技术的中二阶段。一方面看到现阶段所谓“技术产物”的各种各样的问题，另一方面由于自身智力，能力，精力的限制，没有办法对其进行改进和提升，只能采取粗暴的、眼不见为净的鸵鸟政策。其实我知道自己是躲不掉的（当然我说的是找工作），但是还是想在不得不面对之前关心些别的，或者说补救些别的，能补多少是多少吧。年轻的时候有大把时间，却不想念书，现在老了，想念书了，却没有多少时间了（有时间也架不住嗜睡）。&lt;/p&gt;
&lt;p&gt;Anyway, 我接下来准备翻译大段的关于无类型lambda-calculus中Church-Rosser定理的证明，为什么要做这么无聊的事情？因为我觉得有趣…为什么不先完善下之前对STLC的证明？1.不求甚解是我的一贯毛（feng）病（ge）；2.这个定理在它的证明中会有一丢丢的作用，Normalization证明的补充会在之后进行。&lt;/p&gt;
    
    </summary>
    
      <category term="PLT" scheme="http://farseer.cn/categories/PLT/"/>
    
    
      <category term="logic" scheme="http://farseer.cn/tags/logic/"/>
    
      <category term="lambda-calculus" scheme="http://farseer.cn/tags/lambda-calculus/"/>
    
  </entry>
  
  <entry>
    <title>Proof of weak normalization property in STLC</title>
    <link href="http://farseer.cn/2015/04/24/proof-of-normalization-property-in-stlc/"/>
    <id>http://farseer.cn/2015/04/24/proof-of-normalization-property-in-stlc/</id>
    <published>2015-04-23T16:00:00.000Z</published>
    <updated>2016-02-17T02:41:16.359Z</updated>
    
    <content type="html">&lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;p&gt;十多天前我在software fundation的练习中过了一遍有关STLC的weak normalization性质的&lt;a href=&quot;https://github.com/blindFS/Software-Foundations-Solutions/blob/master/Norm.v&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;证明&lt;/a&gt;。&lt;br&gt;当时有些任务心态，想着把上面留的坑填完就完事了，好多大段的引理证明不仅没仔细看，也没有细想引理的用处。&lt;/p&gt;
&lt;p&gt;前几天无意中翻到了王垠的&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/04/26/reason-and-proof/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一篇老文&lt;/a&gt;，于是试图回忆这个定理的证明过程，却发现脑中是空白的，无奈翻出之前的形式化证明从头屡一屡。&lt;/p&gt;
&lt;p&gt;由于我的表述能力的限制，以及我对此证明本质的粗浅认识，这将很难成为一篇好的科普文。另外此文只涉及到关于此性质的核心证明(very informal)，其中可能涉及到许多前文已经证明过的引理，如果想了解完整的证明，请参照software fundation或相关文献。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;h3 id=&quot;什么是weak-normalization&quot;&gt;&lt;a href=&quot;#什么是weak-normalization&quot; class=&quot;headerlink&quot; title=&quot;什么是weak normalization ?&quot;&gt;&lt;/a&gt;什么是weak normalization ?&lt;/h3&gt;&lt;p&gt;简单来说，在STLC中的良构(指的是well-typed)表达式，在$\beta-reduction$的操作语义下，能够停机(halts)。&lt;br&gt;此处停机指的是无法继续reduction，那么根据STLC的progress特性，即：任何非value的良构表达式都能够继续执行reduction，可以得到normalization特性的另一个描述。&lt;/p&gt;
&lt;p&gt;任何STLC中的well-typed-term，可以经过有限步骤的reduction操作，得到一个value。此处略去关于value的解释若干…&lt;/p&gt;
&lt;p&gt;举个简单的例子，$(\lambda x. (x x))(\lambda x. (x x))$ 这个表达式在不带类型的lambda calculus中是良构的，它执行一步reduction之后得到它本身，于是它不会停机。然而在STLC中，我们无法给它加上合适的类型，于是在STLC中，我们找不到对应的良构的表达式。至于为什么无法加上合适类型，此处省略STLC的类型推导规则若干…&lt;/p&gt;
&lt;p&gt;如果使用Coq来描述，就是这样:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Definition halts  (t:tm) : Prop :=  exists t&amp;apos;, t ==&amp;gt;* t&amp;apos; /\  value t&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Theorem normalization : forall t T, has_type empty t T -&amp;gt; halts t.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;关于良构表达式的一个加强性质&quot;&gt;&lt;a href=&quot;#关于良构表达式的一个加强性质&quot; class=&quot;headerlink&quot; title=&quot;关于良构表达式的一个加强性质&quot;&gt;&lt;/a&gt;关于良构表达式的一个加强性质&lt;/h3&gt;&lt;p&gt;我们现在只关心最简单的STLC，不包含任何不必要的语法，如if，pair… 这些扩充的语法并不会影响证明的本质。&lt;br&gt;看过上文提到的形式化证明的同志应该知道，Coq中对此定理证明的最关键步骤就是构造一个比has_type更强的有关表达式和类型的关系R。&lt;/p&gt;
&lt;p&gt;要证明一个表达式t和一个类型T之间具有关系R，我们需要如下条件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;t是closed，即没有自由变量, 这很自然，应为具有自由变量的表达式是不完整的，我们并不关心&lt;/li&gt;
&lt;li&gt;根据原有的类型推导系统，我们可以得出t具有类型T, 这正是之前我们关于良构的定义(has_type)，后面我们将证明，仅通过良构的假设，我们就能得到对应的R关系的证明&lt;/li&gt;
&lt;li&gt;t halts&lt;/li&gt;
&lt;li&gt;R关系不会被函数作用操作所破坏&lt;ol&gt;
&lt;li&gt;如果T是STLC语言中定义的基本类型，则没有任何多余的约束&lt;/li&gt;
&lt;li&gt;如果T是一种函数类型，不妨设为 &lt;code&gt;T1 -&amp;gt; T2&lt;/code&gt; 则t作用在任何与T1满足关系R的表达式t’上之后所得到的表达式t t’将与T2具有关系R&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Coq中，这种关系在通过inductive definition声明的时候会遇到问题(strict positivity requirement)，但是可以通过一个递归函数来处理，这是很有意思的一种方式，但是跟证明本身没有太大的联系。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Fixpoint R (T:ty) (t:tm) &amp;#123;struct T&amp;#125; : Prop :=&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  has_type empty t T /\ halts t /\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (match T with&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       | TBool  =&amp;gt; True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       | TArrow T1 T2 =&amp;gt; (forall s, R T1 s -&amp;gt; R T2 (tapp t s))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;前三个条件可以综合理解为t在有限步骤的归约之后可以得到一个具有类型T的value&lt;/p&gt;
&lt;h3 id=&quot;Context-amp-Env&quot;&gt;&lt;a href=&quot;#Context-amp-Env&quot; class=&quot;headerlink&quot; title=&quot;Context &amp;amp; Env&quot;&gt;&lt;/a&gt;Context &amp;amp; Env&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;context 是一组id(变量)与类型的映射, [(id, type)]，用于类型推导&lt;/li&gt;
&lt;li&gt;env 则是一组id与value的映射，[(id, term)], 用于归约操作，将表达式中的变量替换为value，替换操作从左往右进行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个env e和一个context c满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每一组对应位置的id相同&lt;/li&gt;
&lt;li&gt;在每一组对应位置上，e中的term v和c中的type T具有关系R&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就说e是c的一个实例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;msubst env t操作，通过从左往右的顺序(有重复id时以最左边的value替换)，依次以env中的value替换表达式t中对应的自由变量&lt;/li&gt;
&lt;li&gt;mextend empty context操作，通过从右往左的顺序(重复id时，最左边的类型将其它覆盖)扩增&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Fixpoint msubst (ss:env) (t:tm) &amp;#123;struct ss&amp;#125; : tm :=&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;match ss with&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| nil =&amp;gt; t&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| ((x,s)::ss&amp;apos;) =&amp;gt; msubst ss&amp;apos; ([x:=s]t)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Proof&quot;&gt;&lt;a href=&quot;#Proof&quot; class=&quot;headerlink&quot; title=&quot;Proof&quot;&gt;&lt;/a&gt;Proof&lt;/h2&gt;&lt;p&gt;有了以上的概念，下面我们通过top-down的方式来寻找Norm性质的证明。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要证明Norm，我们需要证明对于任意具有类型T的闭合表达式t终止&lt;/li&gt;
&lt;li&gt;因为如果t和T具有关系R，则t终止(R蕴含的性质之一)，于是我们可以通过证明“任意具有类型T的闭合表达式t满足t和T具有关系R”来证明原命题&lt;/li&gt;
&lt;li&gt;于是我们需要一个引理，它以良构(has_type)作为前提，以关系R作为结论&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Lemma-msubst-R&quot;&gt;&lt;a href=&quot;#Lemma-msubst-R&quot; class=&quot;headerlink&quot; title=&quot;Lemma msubst_R&quot;&gt;&lt;/a&gt;Lemma msubst_R&lt;/h3&gt;&lt;p&gt;如果根据某context c(此时不要求t为closed)我们可以得出t具有类型T，并且env e为c的一个实例，则(msubst e t)和T具有关系R。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lemma msubst_R : forall c e t T, has_type (mextend empty c) t T -&amp;gt; instantiation c e -&amp;gt; R T (msubst e t).&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要证明上述引理，我们对第一个条件作归纳，要得到 &lt;code&gt;has_type (mextend empty c) t T&lt;/code&gt;, 根据has_type的归纳定义有如下3种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;t是一个变量，设为x，x在c中有定义，且c给x定义的最新的类型为T&lt;ol&gt;
&lt;li&gt;根据e是c的一个实例，那么x在e中必然也有定义，考虑x在e中最靠左的出现时对应的value v，根据替换的顺序，有 &lt;code&gt;msubst e t = v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;那么剩下来只需证明 &lt;code&gt;R T v&lt;/code&gt;，由于c给x定义的最新的类型T取决于x在c中最靠左的出现(根据mextend覆盖的顺序)&lt;/li&gt;
&lt;li&gt;e是c的实例，于是x在e中最左出现的位置与x在c中最左出现的位置是相同的(根据实例的性质1)，于是v与T是位置对应的，于是有 &lt;code&gt;R T v&lt;/code&gt; (根据实例的性质2)，于是第一种情况成立&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;t是一个lambda函数，设为$\lambda x:T1. t’$, 根据c和x具有T1，得出t’具有类型T2，&lt;code&gt;T = T1 -&amp;gt; T2&lt;/code&gt;&lt;ol&gt;
&lt;li&gt;令e’为e中去掉所有关于x的项后得到的env，则 t’’ = $\lambda x:T1. (msubst\ e’\ t’)$与T具有关系R (待证明)&lt;/li&gt;
&lt;li&gt;推论1 :: t’’ 是closed&lt;ol&gt;
&lt;li&gt;因为所有t’中的自由变量都在c中出现，否则无法得出类型T2，进而所有自由变量在e中出现&lt;/li&gt;
&lt;li&gt;e是c的实例，e中的value都是closed，否则无法对其进行类型推导，没有类型就得不到R关系，与实例的性质2矛盾&lt;/li&gt;
&lt;li&gt;于是将t’中的所有自由变量替换为closed value之后得到的还是closed-term&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;推论2 :: t’’具有类型T&lt;ol&gt;
&lt;li&gt;由于所有替换操作都是在对应的类型假设下进行的，于是替换操作不会更改整个表达式的类型，具体证明细节自行脑补…&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;要证明1，根据R所需的4个条件，我们只剩3和4&lt;ol&gt;
&lt;li&gt;3是不言自明的，所有的lambda函数都视作value，value都是终止的&lt;/li&gt;
&lt;li&gt;条件4是说，对于任意满足&lt;code&gt;R T1 s&lt;/code&gt;的s，&lt;code&gt;R T2 (t&amp;#39;&amp;#39; s)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;证明最后一个条件&lt;ol&gt;
&lt;li&gt;根据R的1-3有，s经过有限步的归约后得到一个具有类型T1的value v，显然&lt;code&gt;R T1 v&lt;/code&gt;成立&lt;/li&gt;
&lt;li&gt;令&lt;code&gt;t1 = (msubst e&amp;#39; [x := v]t&amp;#39;)&lt;/code&gt;，即t’中先将x替换成v，再进行e’(不含x)中的替换，通过归纳假设(对类型推导进行的归纳，于是可以在T2上应用msubst_R)，容易证明&lt;code&gt;R T2 t1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;由于s归约得到v，则容易得到(t’’ s)归约得到(t’’ v)，进而归约得到t1&lt;/li&gt;
&lt;li&gt;根据R的条件4，直觉上可以感觉到归约操作的前后R的性质保持不变，假设这个性质满足(稍后通过step_preserves_R’/multistep_preserves_R’加以说明)。那么根据&lt;code&gt;R T2 t1&lt;/code&gt;可以得到&lt;code&gt;R T2 (t&amp;#39;&amp;#39; s)&lt;/code&gt;，这样第二种情况的证明就完成了&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;t是一个函数调用，t = t1 t2, t1具有类型 T1 -&amp;gt; T2, t2具有类型T1，&lt;ol&gt;
&lt;li&gt;推论1 :: &lt;code&gt;msubst e t = (msubst e t1) (msubst e t2)&lt;/code&gt;，根据替换操作的语义和自由变量的定义很容易脑补&lt;/li&gt;
&lt;li&gt;根据两个归纳假设容易得到&lt;code&gt;R (T1 -&amp;gt; T2) (msubst e t1)&lt;/code&gt;, &lt;code&gt;R T1 (msubst e t2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据R的条件4，有&lt;code&gt;R T2 (msubst e t1) (msubst e t2)&lt;/code&gt;，即&lt;code&gt;R T2 (msubst e t)&lt;/code&gt;，亦即结论，于是第三种情况成立&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此，要得到引理msubst_R，唯一需要继续证明的就是：归约前后R关系的一致性，即下一条引理。&lt;/p&gt;
&lt;h3 id=&quot;Lemma-preserves-R’&quot;&gt;&lt;a href=&quot;#Lemma-preserves-R’&quot; class=&quot;headerlink&quot; title=&quot;Lemma preserves_R’&quot;&gt;&lt;/a&gt;Lemma preserves_R’&lt;/h3&gt;&lt;p&gt;如果t具有类型T，且t单步归约到t’，t’与T具有关系R，则t与T具有关系R&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lemma step_preserves_R&amp;#39; : forall T t t&amp;#39;, has_type empty t T -&amp;gt; (t ==&amp;gt; t&amp;#39;) -&amp;gt; R T t&amp;#39; -&amp;gt; R T t.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对T作归纳，得到如下几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;T是基本类型，R的条件4不作附加约束，于是只需证明t终止，应为t’与T具有关系R，于是t’终止，从而t也终止(步骤+1)&lt;/li&gt;
&lt;li&gt;T是函数类型，&lt;code&gt;T = T1 -&amp;gt; T2&lt;/code&gt;，终止属性同样得到满足，只需对条件4加以证明，即对于任意的s满足&lt;code&gt;R T1 s&lt;/code&gt;， 有&lt;code&gt;R T2 (t s)&lt;/code&gt;&lt;ol&gt;
&lt;li&gt;根据&lt;code&gt;R T t&amp;#39;&lt;/code&gt;的条件4得到对于任意s满足&lt;code&gt;R T1 s&lt;/code&gt;，有&lt;code&gt;R T2 (t&amp;#39; s)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;又(t s)单步归约至(t’ s), 通过归纳假设(在类型T2上)容易得到，&lt;code&gt;R T1 s&lt;/code&gt; -&amp;gt; &lt;code&gt;R T2 (t&amp;#39; s)&lt;/code&gt; -&amp;gt; &lt;code&gt;R T2 (t s)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;得到了单步的属性之后，很容易结合preservation属性(归约后的类型不变)脑补出下面的多步引理：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lemma multistep_preserves_R&amp;#39; : forall T t t&amp;#39;, has_type empty t T -&amp;gt; (t ==&amp;gt;* t&amp;#39;) -&amp;gt; R T t&amp;#39; -&amp;gt; R T t.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据这个引理，便可以证明msubst_R (见证明步骤2.5.4)&lt;/p&gt;
&lt;h3 id=&quot;Finally&quot;&gt;&lt;a href=&quot;#Finally&quot; class=&quot;headerlink&quot; title=&quot;Finally&quot;&gt;&lt;/a&gt;Finally&lt;/h3&gt;&lt;p&gt;有了msubst_R之后，通过取c和e为空list，便能得出“任意具有类型T的闭合表达式t满足&lt;code&gt;R T t&lt;/code&gt;”这个结论，&lt;br&gt;从而，STLC的Norm属性得到了最终的证明。&lt;/p&gt;
&lt;p&gt;证明的思路是围绕对类型作归纳展开的，整个思路是将初始的类型T一层层地剥开，直到基础类型。&lt;/p&gt;
&lt;p&gt;事实上STLC更强的性质，即strong normalization，说的是任何良构表达式必定停机，它的证明留到以后有时间再读吧…&lt;/p&gt;
&lt;p&gt;写困了，就这样吧…&lt;/p&gt;
&lt;h2 id=&quot;Referrence&quot;&gt;&lt;a href=&quot;#Referrence&quot; class=&quot;headerlink&quot; title=&quot;Referrence&quot;&gt;&lt;/a&gt;Referrence&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.seas.upenn.edu/~bcpierce/sf/current/Norm.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.seas.upenn.edu/~bcpierce/sf/current/Norm.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tait, William W. “Intensional interpretations of functionals of finite type I.” The Journal of Symbolic Logic 32.02 (1967): 198-212.&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;p&gt;十多天前我在software fundation的练习中过了一遍有关STLC的weak normalization性质的&lt;a href=&quot;https://github.com/blindFS/Software-Foundations-Solutions/blob/master/Norm.v&quot;&gt;证明&lt;/a&gt;。&lt;br&gt;当时有些任务心态，想着把上面留的坑填完就完事了，好多大段的引理证明不仅没仔细看，也没有细想引理的用处。&lt;/p&gt;
&lt;p&gt;前几天无意中翻到了王垠的&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/04/26/reason-and-proof/&quot;&gt;一篇老文&lt;/a&gt;，于是试图回忆这个定理的证明过程，却发现脑中是空白的，无奈翻出之前的形式化证明从头屡一屡。&lt;/p&gt;
&lt;p&gt;由于我的表述能力的限制，以及我对此证明本质的粗浅认识，这将很难成为一篇好的科普文。另外此文只涉及到关于此性质的核心证明(very informal)，其中可能涉及到许多前文已经证明过的引理，如果想了解完整的证明，请参照software fundation或相关文献。&lt;/p&gt;
    
    </summary>
    
      <category term="PLT" scheme="http://farseer.cn/categories/PLT/"/>
    
    
      <category term="Coq" scheme="http://farseer.cn/tags/Coq/"/>
    
      <category term="logic" scheme="http://farseer.cn/tags/logic/"/>
    
      <category term="lambda-calculus" scheme="http://farseer.cn/tags/lambda-calculus/"/>
    
  </entry>
  
  <entry>
    <title>About FLP Proof</title>
    <link href="http://farseer.cn/2015/03/23/about-flp-proof/"/>
    <id>http://farseer.cn/2015/03/23/about-flp-proof/</id>
    <published>2015-03-22T16:00:00.000Z</published>
    <updated>2016-02-17T03:16:43.995Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Consensus-Problem&quot;&gt;&lt;a href=&quot;#Consensus-Problem&quot; class=&quot;headerlink&quot; title=&quot;Consensus Problem&quot;&gt;&lt;/a&gt;Consensus Problem&lt;/h2&gt;&lt;p&gt;在分布式系统中，一致性问题的解决是众多分布式算法得以工作的前提条件。这里所说的解决依赖于对系统模型的假设，事实上即便是在工业界得到广泛使用的著名的Paxos算法，也不能完全地解决一致性问题。&lt;/p&gt;
&lt;h3 id=&quot;Importance&quot;&gt;&lt;a href=&quot;#Importance&quot; class=&quot;headerlink&quot; title=&quot;Importance&quot;&gt;&lt;/a&gt;Importance&lt;/h3&gt;&lt;p&gt;一致性问题是具有普遍意义的。举例来说，一个leader选举算法的safty属性要求算法结束时，所有节点公认某个一致的节点作为其leader；再比如，在一个分布式数据库系统中，某个数据具有多个拷贝，当数据发生变化时，所有这些拷贝都需要做出一致的调整(ACID中的C)。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Simplified-Version&quot;&gt;&lt;a href=&quot;#Simplified-Version&quot; class=&quot;headerlink&quot; title=&quot;Simplified Version&quot;&gt;&lt;/a&gt;Simplified Version&lt;/h3&gt;&lt;p&gt;通常，研究一致性问题采用一个简化模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能存在节点fail&lt;/li&gt;
&lt;li&gt;节点间两两均可通信，通信的信道是可靠的&lt;/li&gt;
&lt;li&gt;系统中的N个节点各自有一个1bit的初始状态 (0/1)&lt;/li&gt;
&lt;li&gt;各个节点之间以消息的方式来改变彼此的状态&lt;ul&gt;
&lt;li&gt;通信可以有同步模型和异步模型之分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个节点根据当前状态和接收到的消息唯一确定下一个状态&lt;/li&gt;
&lt;li&gt;最终，每个正常工作的节点具有相同的状态 (0/1)&lt;ul&gt;
&lt;li&gt;总是全0或者总是全1的平凡解没有意义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很显然如果这个简单版本的一致性问题无法得到解决，那么一般意义上的一致性问题亦然。&lt;/p&gt;
&lt;h2 id=&quot;Solution-for-Synchronous-System&quot;&gt;&lt;a href=&quot;#Solution-for-Synchronous-System&quot; class=&quot;headerlink&quot; title=&quot;Solution for Synchronous System&quot;&gt;&lt;/a&gt;Solution for Synchronous System&lt;/h2&gt;&lt;p&gt;同步模型的假设下，一致性问题有较好的解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步模型，每个消息的时延具有上限，以这个上限为间隔来划分轮数&lt;/li&gt;
&lt;li&gt;假设系统最多有f个节点fail&lt;/li&gt;
&lt;li&gt;每一轮中，每个节点将自己“已见过的状态值”广播给所有节点&lt;/li&gt;
&lt;li&gt;每个节点在接收到消息后将其中的状态值合并入“已见过的状态值”集合&lt;/li&gt;
&lt;li&gt;如此重复f+1轮，最终每个正常节点的状态值集合相同，从而很容易选取一个一致的状态值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Proof&quot;&gt;&lt;a href=&quot;#Proof&quot; class=&quot;headerlink&quot; title=&quot;Proof&quot;&gt;&lt;/a&gt;Proof&lt;/h3&gt;&lt;p&gt;用反证法推出矛盾，假设某两个节点在f+1轮之后存活确认，但状态值集合不同，不妨设$ v \in P_i, v \notin P_j $，那么初始状态值为v的节点$P_v$没有活过第一轮，否则在这一轮中，$P_j$会收到来自它的消息，矛盾。然而最终v出现在了$P_i$中，因此v的火种在每一轮都有存活节点保留了下来，然而如果某个节点在第i轮收到了包含v的消息，那么它必然活不过第i+1轮，否则在第i+1轮中，它会给$P_j$发送一个带v的消息，这与$v \notin P_j$矛盾。综上所述，每一轮中都至少有一个带v的节点挂掉，因此fail节点的总数大于f，矛盾。&lt;/p&gt;
&lt;h2 id=&quot;FLP-Proof&quot;&gt;&lt;a href=&quot;#FLP-Proof&quot; class=&quot;headerlink&quot; title=&quot;FLP Proof&quot;&gt;&lt;/a&gt;FLP Proof&lt;/h2&gt;&lt;p&gt;终于要谈到重点了，这个证明由 Michael J. Fischer, Nancy Lynch, Mike Paterson 三位科学家给出，发表于1985年的Journal of the ACM.&lt;/p&gt;
&lt;p&gt;这个证明说的是，在完全异步的，有单一节点fail的分布式系统中，不存在完全正确的一致性算法。这里有两个重要的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全异步 : 消息的延迟可以是任意长，并且对消息之间的相对速度不做任何假设&lt;/li&gt;
&lt;li&gt;完全正确 : 假设每个消息延迟上限是单位1的情况下，存在一个有限的N，算法在N个单位的时限内确定停机，停机时所有存活节点的状态相同 (0/1)&lt;ul&gt;
&lt;li&gt;需要注意的是这里假设的上限与同步模型中的上限是不同的概念，这里的N应该理解为有因果关系的一组消息的数量，而不是简单的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么根据这些定义，显然在没有节点fail的系统中，完全正确的一致性算法是容易实现的。&lt;/p&gt;
&lt;h3 id=&quot;More-Definitions-amp-Assumptions&quot;&gt;&lt;a href=&quot;#More-Definitions-amp-Assumptions&quot; class=&quot;headerlink&quot; title=&quot;More Definitions &amp;amp; Assumptions&quot;&gt;&lt;/a&gt;More Definitions &amp;amp; Assumptions&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个节点的终止状态寄存器只能被修改一次(0/1)，但是中间状态可以有无穷多&lt;/li&gt;
&lt;li&gt;message buffer : 包含了系统中所有被发送但是未传达的消息&lt;/li&gt;
&lt;li&gt;send(P, m) : 将目标节点为P，消息内容为m的消息（内容表示为二者的笛卡尔积）放到buffer&lt;/li&gt;
&lt;li&gt;receive(P) : 尝试从buffer获取目标节点为p的消息，可能返回buffer中存在的消息或者空&lt;/li&gt;
&lt;li&gt;configuration : 全局状态的描述，包括所有节点的当前状态和message buffer中的全部内容&lt;/li&gt;
&lt;li&gt;step : 导致configuration发生变化的源于某个节点P的原子操作，包括如下步骤&lt;ol&gt;
&lt;li&gt;receive(P)&lt;/li&gt;
&lt;li&gt;根据p的当前状态和第1步返回的值，修改P的状态&lt;/li&gt;
&lt;li&gt;根据1，2的结果向某些节点发送有限数量的消息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;event : 节点P和receive(P)返回值的二元组， $e = (P, m)$，和其作用的配置一起，完全确定了一个step操作&lt;/li&gt;
&lt;li&gt;schedule : 一个有限或者无限长的可以依次发生的events序列$\delta$&lt;ul&gt;
&lt;li&gt;run : 与之对应的steps序列&lt;/li&gt;
&lt;li&gt;$\delta(C)$ : 从configuration C出发，作用了这个调度之后的configuration.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;bivalent : 一个配置C，如果有一个全0的最终配置可达，且有一个全1的最终配置可达，则称其为二阶的，可以理解为配置的&lt;strong&gt;不确定&lt;/strong&gt;性&lt;/li&gt;
&lt;li&gt;1-valent/0-valent : 只有全1/0的最终配置可达&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Lemma-1&quot;&gt;&lt;a href=&quot;#Lemma-1&quot; class=&quot;headerlink&quot; title=&quot;Lemma 1&quot;&gt;&lt;/a&gt;Lemma 1&lt;/h3&gt;&lt;p&gt;如果两个调度$\delta_1, \delta_2$均能作用于配置C，且$\delta_1(C) = C_1, \delta_2(C) = C_2$, 两个调度中发生操作的节点的集合的交为空，那么有$\delta_1(C_2) = \delta_2(C_1) = C_3$。&lt;/p&gt;
&lt;p&gt;如图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/FLP_lemma1.png&quot; alt=&quot;lemma1&quot;&gt;&lt;/p&gt;
&lt;p&gt;证明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调度1可以作用于C2，调度2可以作用于C1是因为：&lt;ol&gt;
&lt;li&gt;调度1的执行并不会修改调度2中发生操作的节点的状态，也不会取下调度2中取下的消息(目标节点不同)&lt;/li&gt;
&lt;li&gt;同理…&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;两条执行路径的最终配置相同是因为：&lt;ol&gt;
&lt;li&gt;每个event完全确定了一个step的操作&lt;/li&gt;
&lt;li&gt;对于每个发生操作的节点来说，它上面发生的event的次序相同，因此最终配置相同&lt;/li&gt;
&lt;li&gt;对于每个没有发生操作的节点，其状态没有发生变化，均与C保持一致&lt;/li&gt;
&lt;li&gt;从message buffer上取下的消息集合相同&lt;/li&gt;
&lt;li&gt;往message buffer上发送的消息集合相同，根据1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Lemma-2&quot;&gt;&lt;a href=&quot;#Lemma-2&quot; class=&quot;headerlink&quot; title=&quot;Lemma 2&quot;&gt;&lt;/a&gt;Lemma 2&lt;/h3&gt;&lt;p&gt;存在一个bivalent的初始配置。&lt;/p&gt;
&lt;p&gt;证明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;反证法，假设所有初始配置不是1-valent就是0-valent，且其中既有1-valent，也有0-valent，否则为平凡解，失去意义&lt;/li&gt;
&lt;li&gt;将初始配置中所有节点的初始状态编码为一个二进制数，以&lt;a href=&quot;http://en.wikipedia.org/wiki/Gray_code&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;格雷码&lt;/a&gt;的形式将所有可能的二进制数(i.e.初始配置)排序，相邻的两个数仅有1bit的区别(i.e.只有一个节点的初始状态不同)。&lt;/li&gt;
&lt;li&gt;那么排序后必然有一个1-valent的配置与0-valent的配置相邻，设它们的区别在于节点P&lt;/li&gt;
&lt;li&gt;考虑到它们在节点P fail的情况下，会进入相同的终止配置，而其中一者为全1，一者全0，矛盾&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Lemma-3&quot;&gt;&lt;a href=&quot;#Lemma-3&quot; class=&quot;headerlink&quot; title=&quot;Lemma 3&quot;&gt;&lt;/a&gt;Lemma 3&lt;/h3&gt;&lt;p&gt;从一个bivalent的配置C出发，对于其所有可达配置，如果从C到达该配置的最后一个event是一个可以作用在C上的event e，则称该配置属于集合$S_D$，该集合中存在一个bivalent的配置。&lt;/p&gt;
&lt;p&gt;这个定理说的是：从一个不确定的配置C触发，不论作用什么样的event，也无法立即进入一个确定的配置，换句话说，任给一个有限的N，可以找到一个长度大于N的event序列，它作用在C上之后得到的配置依然是一个不确定的配置，从而证明了&lt;strong&gt;完全正确&lt;/strong&gt;的一致性算法是不存在的。&lt;/p&gt;
&lt;p&gt;为了证明Lemma 3, 我们需要用反证法证明如下事实：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;假设从C触发可达的配置中所有没有发生事件e的配置的集合为$S_C$，则e可以作用在其中的任意配置，且有 $S_D = \{e(C’) | C’ \in S_C\}$&lt;ul&gt;
&lt;li&gt;根据消息延时可以任意长的特性，容易证明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;假设$S_D$中不包含bivalent配置，则其中既有1-valent又有0-valent的配置&lt;ul&gt;
&lt;li&gt;因为C是bivalent的，所以对于$i = 0, 1; \exists E_i$，Ei为从C可达的i-valent的配置&lt;/li&gt;
&lt;li&gt;如果Ei恰好在$S_D$中，则满足&lt;/li&gt;
&lt;li&gt;否则，$E_i \in S_C, e(E_i) \in S_D$，其中$e(E_i)$必然也是i-valent的(从一个确定的配置出发的所有可达的配置都是同样确定的)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$\exists C_0, C_1 \in S_C, e(C_0) = D_0, e(C_1) = D_1$ 其中Di是i-valent，而且Ci之间可以通过单一的事件e’转变。&lt;ul&gt;
&lt;li&gt;不失一般性，假设e(C)是0-valent，由于C可以到达D中一个1-valent的配置，设其对应的$S_C$中的配置为C’&lt;/li&gt;
&lt;li&gt;考虑从C到C’的调度，其起始配置与D中一个0-valent的配置对应，其终止配置与D中一个1-valent的配置对应&lt;/li&gt;
&lt;li&gt;那么这个调度中必然至少存在一个event，其执行前后发生了跳变，取这个event作为e’，前后配置作为Ci即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来考虑e和e’所作用的节点P, P’是否相同，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同，根据Lemma 1，有下图，得出矛盾 (D0 –&amp;gt; D1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/FLP_lemma3_1.png&quot; alt=&quot;lemma1&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相同，取一个从$C_0$可达的终止配置A，$\delta(C_0) = A$，节点P在调度$\delta$中fail，则根据Lemma 1，有下图，可以看到终止配置A可以到达i-valent(i = 0, 1)的配置，这与终止配置的一致性要求矛盾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/FLP_lemma3_2.png&quot; alt=&quot;lemma1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Conclusion&quot;&gt;&lt;a href=&quot;#Conclusion&quot; class=&quot;headerlink&quot; title=&quot;Conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;FLP的证明并不意味着一致性算法的研究失去了意义，也不意味着一致性在实际应用中不存在，只是说明了在特定的约束条件下，某种理想效果的不可能。事实上如果我们放宽liveness要求，便可以获得如Paxos这样的算法的支持。&lt;/p&gt;
&lt;p&gt;PS: 之所以做这种毫无技术含量的翻译，一方面是出于笔记整理的需求，另外我看到许多对这个证明的解读都或多或少有无法自圆其说的地方（我并不是说我的解读就是天衣无缝，但至少我信了），更重要的是，我实在也没啥有技术含量的东西能分享的…&lt;/p&gt;
&lt;h2 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Consensus_(computer_science\&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Consensus_(computer_science)&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Paxos_(computer_science\&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Paxos_(computer_science)&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Michael J. Fischer, Nancy Lynch, Mike Paterson, “Impossiblity of Distributed Consensus with One Faulty Process”.&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Consensus-Problem&quot;&gt;&lt;a href=&quot;#Consensus-Problem&quot; class=&quot;headerlink&quot; title=&quot;Consensus Problem&quot;&gt;&lt;/a&gt;Consensus Problem&lt;/h2&gt;&lt;p&gt;在分布式系统中，一致性问题的解决是众多分布式算法得以工作的前提条件。这里所说的解决依赖于对系统模型的假设，事实上即便是在工业界得到广泛使用的著名的Paxos算法，也不能完全地解决一致性问题。&lt;/p&gt;
&lt;h3 id=&quot;Importance&quot;&gt;&lt;a href=&quot;#Importance&quot; class=&quot;headerlink&quot; title=&quot;Importance&quot;&gt;&lt;/a&gt;Importance&lt;/h3&gt;&lt;p&gt;一致性问题是具有普遍意义的。举例来说，一个leader选举算法的safty属性要求算法结束时，所有节点公认某个一致的节点作为其leader；再比如，在一个分布式数据库系统中，某个数据具有多个拷贝，当数据发生变化时，所有这些拷贝都需要做出一致的调整(ACID中的C)。&lt;/p&gt;
    
    </summary>
    
      <category term="TCS" scheme="http://farseer.cn/categories/TCS/"/>
    
    
      <category term="distributed" scheme="http://farseer.cn/tags/distributed/"/>
    
      <category term="paper" scheme="http://farseer.cn/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>Auto-fu.zsh customization</title>
    <link href="http://farseer.cn/2015/02/18/auto-fuzsh-customization/"/>
    <id>http://farseer.cn/2015/02/18/auto-fuzsh-customization/</id>
    <published>2015-02-17T16:00:00.000Z</published>
    <updated>2016-02-17T02:41:38.333Z</updated>
    
    <content type="html">&lt;h2 id=&quot;大概是这么一回事&quot;&gt;&lt;a href=&quot;#大概是这么一回事&quot; class=&quot;headerlink&quot; title=&quot;大概是这么一回事&quot;&gt;&lt;/a&gt;大概是这么一回事&lt;/h2&gt;&lt;p&gt;放假闲的慌，于是开始折腾些有的没的，忘记是怎么看到&lt;a href=&quot;https://github.com/hchbaw/auto-fu.zsh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个repo&lt;/a&gt;的了…觉得很好玩的样子，就打算试试看。但是折腾的过程中发现，要让这个插件跟我原有的配置共洽，稍稍有点费劲，于是在此记录下我的无聊行径。&lt;/p&gt;
&lt;h2 id=&quot;选择合适的branch&quot;&gt;&lt;a href=&quot;#选择合适的branch&quot; class=&quot;headerlink&quot; title=&quot;选择合适的branch&quot;&gt;&lt;/a&gt;选择合适的branch&lt;/h2&gt;&lt;p&gt;一开始发现它和zsh-syntax-highlighting闹矛盾，翻了下github的issue，发现有两个branch解决了这个问题，分别是pu和thb，没搞懂名字怎么来的…&lt;/p&gt;
&lt;p&gt;pu比thb多了自动纠正，其实我对自动纠正挺反感的，无奈的是thb有些其它的bug，比如在按下tab补全路径的时候会多一个&lt;code&gt;/&lt;/code&gt;，总之就是我选择了pu这个分支。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;初始化配置&quot;&gt;&lt;a href=&quot;#初始化配置&quot; class=&quot;headerlink&quot; title=&quot;初始化配置&quot;&gt;&lt;/a&gt;初始化配置&lt;/h2&gt;&lt;p&gt;这个在文档里就有，不过github上的readme的格式比较糟糕。&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 需要oldlist&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;zstyle&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;:completion:*&#39;&lt;/span&gt; completer _oldlist _complete&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 跳过rm的第一个参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;zstyle&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;:auto-fu:var&#39;&lt;/span&gt; autoable-function/skiplbuffers \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;rm -[![:blank:]]#&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使能auto-fu&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt;-line-&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;/span&gt; () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    auto-fu-init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt; -N &lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt;-line-init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;auto-fu的skip规则，比较复杂，具体参见文档，我还没有仔细探究。&lt;br&gt;这里最关键的步骤就是zle-line-init这个widget，每行初始化的时候都会调用auto-fu-init，i.e. 使能auto-fu。这样配置之后就能正常工作了。&lt;/p&gt;
&lt;h2 id=&quot;外观&quot;&gt;&lt;a href=&quot;#外观&quot; class=&quot;headerlink&quot; title=&quot;外观&quot;&gt;&lt;/a&gt;外观&lt;/h2&gt;&lt;p&gt;为了保持外观的统一，我做了如下调整。&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 原有的消息格式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;zstyle&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;:completion:*:descriptions&#39;&lt;/span&gt; format $&lt;span class=&quot;string&quot;&gt;&#39; \e[30;42m %d \e[0m\e[32m\e[0m&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;zstyle&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;:completion:*:messages&#39;&lt;/span&gt; format $&lt;span class=&quot;string&quot;&gt;&#39; \e[30;45m %d \e[0m\e[35m\e[0m&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;zstyle&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;:completion:*:warnings&#39;&lt;/span&gt; format $&lt;span class=&quot;string&quot;&gt;&#39; \e[30;41m No Match Found \e[0m\e[31m\e[0m&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 去掉多余的提示信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;zstyle&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;:auto-fu:var&#39;&lt;/span&gt; postdisplay &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# prompt中的vimod字段&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt;-keymap-select &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# afu所需&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    afu-track-keymap &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$@&lt;/span&gt;&quot;&lt;/span&gt; afu-adjust-main-keymap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; [[ &lt;span class=&quot;variable&quot;&gt;$KEYMAP&lt;/span&gt; =~ &lt;span class=&quot;string&quot;&gt;&quot;vicmd&quot;&lt;/span&gt; ]]; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vimod=&lt;span class=&quot;variable&quot;&gt;$vimodcmd&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vimod=&lt;span class=&quot;variable&quot;&gt;$vimodins&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt; reset-prompt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt; -R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt; -N &lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt;-keymap-select&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我在prompt中添加了&lt;code&gt;$vimod&lt;/code&gt;提示，具体&lt;a href=&quot;https://github.com/blindFS/zsh-funcs/blob/master/powerline.zsh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内容&lt;/a&gt;见链接。这个函数在每次keymap发生变化时调用，注意这时的 keymap 的值可能是auto-fu提供的 &lt;em&gt;afu-viins&lt;/em&gt; 和 &lt;em&gt;afu-vicmd&lt;/em&gt; ，所以判断的时候采取 &lt;code&gt;=~&lt;/code&gt;。&lt;br&gt;这样之后还有个问题，就是自动纠错时会产生不必要的消息，导致如下情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/auto-fu.png&quot; alt=&quot;afu&quot;&gt;&lt;/p&gt;
&lt;p&gt;解决办法：这里没有提供选项，只能通过修改源码了，去掉&lt;code&gt;_message ...&lt;/code&gt;这句话就OK。补全的消息本身就带有correction提示，就不需要重复的提示了。&lt;/p&gt;
&lt;h2 id=&quot;添加toggle&quot;&gt;&lt;a href=&quot;#添加toggle&quot; class=&quot;headerlink&quot; title=&quot;添加toggle&quot;&gt;&lt;/a&gt;添加toggle&lt;/h2&gt;&lt;p&gt;这个插件虽然在功能性上有一定的作用，但是我想大多数人会认为比较鸡肋，尤其是补全消息很多的情况下会发生卡顿，就得不偿失了，我觉得我需要开关它的机制。&lt;/p&gt;
&lt;p&gt;自带的widget名为&lt;code&gt;auto-fu-toggle&lt;/code&gt;只能开关正在处理的这行，而真正是否使能该插件的因素在于之前提到的zle-line-init，没有想到更好的解决方案的情况下，我添加了如下widget：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;toggle-auto-&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;fu&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (( $+&lt;span class=&quot;built_in&quot;&gt;disable&lt;/span&gt;_auto_fu )); &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt;-line-&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;/span&gt; () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            auto-fu-init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt; -N &lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt;-line-init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;unset&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;disable&lt;/span&gt;_auto_fu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        auto-fu-init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt; -D &lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt;-line-init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        auto-fu-deactivate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;disable&lt;/span&gt;_auto_fu=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt; -N toggle-auto-fu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;bindkey&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;^O&#39;&lt;/span&gt; toggle-auto-fu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;bindkey&lt;/span&gt; -M afu &lt;span class=&quot;string&quot;&gt;&#39;^O&#39;&lt;/span&gt; toggle-auto-fu&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意这里需要bind两次，因为在使能和非使能的情况下，keymap所属的组是不同的。这个toggle函数能在当前行以及之后的所有行产生作用，正是我想要的效果。另外，由于keymap发生变化，之前的widget需要重新复制一份，另外切换至afu-vicmd的默认快捷键略繁琐，改成ESC。&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;bindkey&lt;/span&gt; -M afu &lt;span class=&quot;string&quot;&gt;&#39;^T&#39;&lt;/span&gt; fzf-file-widget&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;bindkey&lt;/span&gt; -M afu &lt;span class=&quot;string&quot;&gt;&#39;^L&#39;&lt;/span&gt; fzf-cd-widget&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;bindkey&lt;/span&gt; -M afu &lt;span class=&quot;string&quot;&gt;&#39;^H&#39;&lt;/span&gt; fzf-history-widget&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;bindkey&lt;/span&gt; -M afu &lt;span class=&quot;string&quot;&gt;&#39;\e&#39;&lt;/span&gt; afu+vi-cmd-mode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;bindkey&lt;/span&gt; -M afu-vicmd &lt;span class=&quot;string&quot;&gt;&#39;k&#39;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;history&lt;/span&gt;-substring-search-up&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;bindkey&lt;/span&gt; -M afu-vicmd &lt;span class=&quot;string&quot;&gt;&#39;j&#39;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;history&lt;/span&gt;-substring-search-down&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;bindkey&lt;/span&gt; -M afu-vicmd &lt;span class=&quot;string&quot;&gt;&#39;cc&#39;&lt;/span&gt; vi-change-whole-line&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;顺便一提，fzf和history-substring-search确实能提高不少的效率，谁用谁知道。&lt;/p&gt;
&lt;p&gt;我在折腾的过程中，无意搜到这个很有意思的玩意：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;autoload&lt;/span&gt; -U tetris&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;zle&lt;/span&gt; -N tetris&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;bindkey&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;^T&#39;&lt;/span&gt; tetris&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有意思的地方是，如果直接执行tetris，会输出&lt;code&gt;Use M-x tetris RET to play tetris.&lt;/code&gt;的提示;-)。&lt;/p&gt;
&lt;p&gt;zsh的功能十分复杂，我也就是带着不求甚解的心态折腾着玩罢了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大概是这么一回事&quot;&gt;&lt;a href=&quot;#大概是这么一回事&quot; class=&quot;headerlink&quot; title=&quot;大概是这么一回事&quot;&gt;&lt;/a&gt;大概是这么一回事&lt;/h2&gt;&lt;p&gt;放假闲的慌，于是开始折腾些有的没的，忘记是怎么看到&lt;a href=&quot;https://github.com/hchbaw/auto-fu.zsh&quot;&gt;这个repo&lt;/a&gt;的了…觉得很好玩的样子，就打算试试看。但是折腾的过程中发现，要让这个插件跟我原有的配置共洽，稍稍有点费劲，于是在此记录下我的无聊行径。&lt;/p&gt;
&lt;h2 id=&quot;选择合适的branch&quot;&gt;&lt;a href=&quot;#选择合适的branch&quot; class=&quot;headerlink&quot; title=&quot;选择合适的branch&quot;&gt;&lt;/a&gt;选择合适的branch&lt;/h2&gt;&lt;p&gt;一开始发现它和zsh-syntax-highlighting闹矛盾，翻了下github的issue，发现有两个branch解决了这个问题，分别是pu和thb，没搞懂名字怎么来的…&lt;/p&gt;
&lt;p&gt;pu比thb多了自动纠正，其实我对自动纠正挺反感的，无奈的是thb有些其它的bug，比如在按下tab补全路径的时候会多一个&lt;code&gt;/&lt;/code&gt;，总之就是我选择了pu这个分支。&lt;/p&gt;
    
    </summary>
    
      <category term="tweak" scheme="http://farseer.cn/categories/tweak/"/>
    
    
      <category term="zsh" scheme="http://farseer.cn/tags/zsh/"/>
    
      <category term="shell" scheme="http://farseer.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Isomorphisms between Monument Valley &amp; masterpieces of M.C.Escher</title>
    <link href="http://farseer.cn/2015/02/07/isomorphism-between-monument-valley--masterpieces-of-mcescher/"/>
    <id>http://farseer.cn/2015/02/07/isomorphism-between-monument-valley--masterpieces-of-mcescher/</id>
    <published>2015-02-06T16:00:00.000Z</published>
    <updated>2016-02-17T03:16:43.879Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;博客写了1.5年左右的时间了，内容尽是些无足轻重的雕虫小技，与其说是博客，不如唤作笔记来的贴切。每当码字的时候，潜意识中总是明白光标下的东西不会被人关注，因此不论是标点、措辞、内容的逻辑性……都全然不顾，敲下的东西更像是当前的我和日后翻阅时的我之间的对话。它们的糟糕程度正好就反映了我的懒散程度。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;每当我看到他人的博文中那种清新的排版，分明的层次，清晰的逻辑，文邹邹的字句时，总是由衷的佩服。我想这就是2B青年所模仿不来的文艺气质吧!&lt;/p&gt;
&lt;p&gt;我想我需要在文字中间多注入一些情感，我知道也许这样做会有一种刻意模仿的痕迹，矫揉造作似的违和感，但至少我想做一次这样的尝试。&lt;/p&gt;
&lt;p&gt;前段时间我正好阅读了GEB的中文译本，确实受到了震撼，也许是我读书不多的缘故吧。我希望在能这里留下一些我的感想，但是又不知从何谈起，毕竟GEB包罗万象，我对它的理解犹如沧海一粟。虽然这本书的重点是哥德尔(G)、数理逻辑、人工智能，但到处穿插着埃舍尔(E)的版画，同时每章的序都被冠以曲谱的名字，文字中也多次提到巴赫(B)的赋格曲，整本书散发着浓郁的艺术气息。我一向不通音律，书中除了对哥德尔定理的介绍和对心智的探讨之外，给我印象最深的自然是埃舍尔构建的奇妙空间了。&lt;/p&gt;
&lt;p&gt;也就是前不久，我在室友的推荐下接触到了Monument Valley这款游戏，同样是艺术感很强的作品，熟悉的空间，熟悉的图案……下面我将细数我从纪念碑谷中看到的埃舍尔的身影，并借此表达我对两者的喜爱之情。&lt;/p&gt;
&lt;h2 id=&quot;Totems&quot;&gt;&lt;a href=&quot;#Totems&quot; class=&quot;headerlink&quot; title=&quot;Totems&quot;&gt;&lt;/a&gt;Totems&lt;/h2&gt;&lt;p&gt;先从散落在纪念碑谷中的零星的符号开始说起。&lt;/p&gt;
&lt;h3 id=&quot;Crow-amp-Swan&quot;&gt;&lt;a href=&quot;#Crow-amp-Swan&quot; class=&quot;headerlink&quot; title=&quot;Crow &amp;amp; Swan&quot;&gt;&lt;/a&gt;Crow &amp;amp; Swan&lt;/h3&gt;&lt;p&gt;游戏从第4关开始，会出现徘徊的黑乌鸦人，另外主角艾达会在最终章变身成白色乌鸦人。在我看来，乌鸦人在游戏中的语义为迷失，循环。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/crows.jpg&quot; alt=&quot;crows&quot;&gt;&lt;/p&gt;
&lt;p&gt;黑与白、鸟类、循环，让我联想起这幅 Swans(1956)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/swans.jpg&quot; alt=&quot;swans&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是一幅很有意思的作品，给我的第一感觉是&lt;a href=&quot;http://en.wikipedia.org/wiki/Möbius_strip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;莫比乌斯带&lt;/a&gt;，但是第二眼便否定了这个感觉，更像是一个镂空的环带，中间部分被胶水粘在了一起，黑和白，确实是两面。但是再转念一想，如果将中间黑白镶嵌的部分看做是一个面，只是被染上了颜色，然后将这个图的左右部分分开，那么每个部分确实分别是一个莫比乌斯带！另外这个作品蕴含了&lt;a href=&quot;http://www.wikiart.org/en/m-c-escher/mosaic-ii&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;镶嵌画&lt;/a&gt;的理念，这无疑是埃舍尔最擅长的手法之一。&lt;/p&gt;
&lt;h3 id=&quot;Polyhedron-Combo&quot;&gt;&lt;a href=&quot;#Polyhedron-Combo&quot; class=&quot;headerlink&quot; title=&quot;Polyhedron Combo&quot;&gt;&lt;/a&gt;Polyhedron Combo&lt;/h3&gt;&lt;p&gt;有人说，艾达之前偷走了许多几何图形，而这个游戏剧情的主线是艾达归还失物，寻求救赎的过程。不论怎样，每一关的最后，艾达都会从自己的帽子中掏出一个规则的几何图形。下图是资料篇Forgotten Shores的图形集合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/mv_stars.png&quot; alt=&quot;mvstar&quot;&gt;&lt;/p&gt;
&lt;p&gt;与之对应的是埃舍尔的作品 Stars(1948)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/stars.jpg&quot; alt=&quot;star&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于这个作品，信息量很大，对于它的解读也非常之多，我们且关注画面中出现的图形。这些图形都有个共性：一个或多个正多面体的组合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正中的空心图形，是由&lt;a href=&quot;http://mathworld.wolfram.com/Octahedron3-Compound.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3个正八面体组合&lt;/a&gt;而来，对应的实心图形在它的右下角。&lt;/li&gt;
&lt;li&gt;七点钟位置的空心图形，是由&lt;a href=&quot;http://mathworld.wolfram.com/Cube2-Compound.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2个正方体组合&lt;/a&gt;而来，对应的实心图形在五点钟位置。&lt;/li&gt;
&lt;li&gt;一点钟位置的空心图形，是由&lt;a href=&quot;http://mathworld.wolfram.com/Tetrahedron2-Compound.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2个正四面体组合&lt;/a&gt;而来，对应的实心图形在左下角。&lt;/li&gt;
&lt;li&gt;十一点的实心图形，是由一个正方体和一个正八面体组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面描述到的第二种图形始终给我一种强烈的违和感，我总觉得它的美感要逊色于其它图形，但是从对称性上来说，它的确是中心对称的，这点上甚至强过正四面体，那么我意识中的美感欠缺到底来自何处呢？&lt;/p&gt;
&lt;p&gt;与此相关的一个有趣的词条叫做&lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_polyhedron_compound&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Uniform polyhedron compound&lt;/a&gt;，不过里面的图形的约束条件要强很多：”The symmetry group of the compound acts transitively on the compound’s vertices.”，跟踪链接后发现此处的”transitively”指的是对于任意的两个顶点A、B，存在一个图形顶点的置换，在其作用下，A被置换为B。那么一个简单的推论就是：每个点的度必须相同。&lt;/p&gt;
&lt;h3 id=&quot;Impossible-Objects&quot;&gt;&lt;a href=&quot;#Impossible-Objects&quot; class=&quot;headerlink&quot; title=&quot;Impossible Objects&quot;&gt;&lt;/a&gt;Impossible Objects&lt;/h3&gt;&lt;p&gt;“Those who stole our sacred geometry have forgotten their true selves.&lt;br&gt; Cursed to walk these monuments are they.”&lt;/p&gt;
&lt;p&gt;上面这句话源自纪念碑谷中的NPC。从这句话来说，上面提到的那种对游戏剧情的解读或许是说的通的。而这句话出现的地方，正是下文中将要提到的彭罗思三角形出现的地方。&lt;/p&gt;
&lt;p&gt;那么造成这种&lt;a href=&quot;http://en.wikipedia.org/wiki/Impossible_object&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;不可能出现的图形&lt;/a&gt;的原因是什么？我想本质上，这与之后我们会看到的各种错觉现象一样，来自三维物体在二维投影中的信息缺失。我们没有办法从二维的图像中还原三维物体的全部空间信息，换句话说，为了还原物体，我们需要对我们所见到的信息用想象进行补全。而想象会很容易地被光影、参照物等因素引导，进而产生矛盾。&lt;/p&gt;
&lt;h4 id=&quot;Penrose-Triangle&quot;&gt;&lt;a href=&quot;#Penrose-Triangle&quot; class=&quot;headerlink&quot; title=&quot;Penrose Triangle&quot;&gt;&lt;/a&gt;Penrose Triangle&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/mv_triangle.png&quot; alt=&quot;pt&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个图形就是著名的&lt;a href=&quot;http://en.wikipedia.org/wiki/Penrose_triangle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;彭罗思三角形&lt;/a&gt;。&lt;br&gt;GEB的英文原著的封面正是此图形，另外theverge.com的logo也是由此而来。&lt;br&gt;维基中提到这是一个”3-loop Möbius strip”，注意观察三个乌鸦人的行走路线便能理解这句话的意思了。&lt;/p&gt;
&lt;p&gt;这个图形的传扬者彭罗思&lt;a href=&quot;http://en.wikipedia.org/wiki/Lionel_Penrose&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;父&lt;/a&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Roger_Penrose&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;子&lt;/a&gt;，也是十分了得的人物。那么这和埃舍尔又有什么关系呢？&lt;/p&gt;
&lt;p&gt;答案在维基词条中一目了然，让我们来欣赏下埃舍尔的作品 Ascending and Descending(1960)中的&lt;a href=&quot;http://en.wikipedia.org/wiki/Penrose_stairs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;彭罗思阶梯&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/ascending-descending.jpg&quot; alt=&quot;a&amp;amp;d&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实看到这个三角形时，我第一个联想到的是 Relativity(1953)，现在看起来还有一些神似，但确实不是同构的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/relativity.jpg&quot; alt=&quot;rela&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了这些联系之外，&lt;a href=&quot;http://en.wikipedia.org/wiki/Penrose_tiling&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;彭罗思平铺&lt;/a&gt; 是不是又与镶嵌画惊人的类似呢？&lt;/p&gt;
&lt;h4 id=&quot;Impossible-Cube&quot;&gt;&lt;a href=&quot;#Impossible-Cube&quot; class=&quot;headerlink&quot; title=&quot;Impossible Cube&quot;&gt;&lt;/a&gt;Impossible Cube&lt;/h4&gt;&lt;p&gt;纪念碑谷中出现的正方体，它与埃舍尔发明的&lt;a href=&quot;http://en.wikipedia.org/wiki/Impossible_cube&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;不可能立方体&lt;/a&gt;是什么关系呢？乍一看两者并无关联。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/mv_cube.jpg&quot; alt=&quot;mc&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/impossible_cube.png&quot; alt=&quot;ic&quot;&gt;&lt;/p&gt;
&lt;p&gt;参考维基词条，下图中的图形通过转动之后，可以得到不可能立方体。而游戏中的立方体，恰好是有缺口的。我多次尝试转动，却也没有发现合适的角度，而截图中却展示出了另一种不可能性。我认为这是为了游戏性所做出的调整，这不妨碍我们把它们联系在一起。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/impossible_cube2.png&quot; alt=&quot;ic2&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Illusory-amp-Impossible&quot;&gt;&lt;a href=&quot;#Illusory-amp-Impossible&quot; class=&quot;headerlink&quot; title=&quot;Illusory &amp;amp; Impossible&quot;&gt;&lt;/a&gt;Illusory &amp;amp; Impossible&lt;/h2&gt;&lt;p&gt;视觉错觉是这两者共同的主题，具体的表现形式如下。&lt;/p&gt;
&lt;h3 id=&quot;Height-amp-Depth&quot;&gt;&lt;a href=&quot;#Height-amp-Depth&quot; class=&quot;headerlink&quot; title=&quot;Height &amp;amp; Depth&quot;&gt;&lt;/a&gt;Height &amp;amp; Depth&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/mv_waterfall.jpg&quot; alt=&quot;mvwf&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过物体高度和深度的相互转化来造成错觉，是纪念碑谷的核心玩法，贯穿始终，它的魅力通过上面提到过的 Ascending and Descending 就能领会， Waterfall(1961)所表达的是同样的理念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/waterfall.jpg&quot; alt=&quot;wf&quot;&gt;&lt;/p&gt;
&lt;p&gt;然而这幅杰作还有其它的亮点。&lt;/p&gt;
&lt;p&gt;注意水渠和立柱，如果根据高度将其分为三层，那么每层中的组合都可看做一个彭罗思三角形！&lt;/p&gt;
&lt;p&gt;另，注意图中两个柱子上的图形。第一个图形恰似Stars中的图形一般，是由&lt;a href=&quot;http://mathworld.wolfram.com/Cube3-Compound.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3个正方体组成&lt;/a&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/3cubes.png&quot; alt=&quot;3c&quot;&gt;&lt;/p&gt;
&lt;p&gt;而另一个则被命名为&lt;a href=&quot;http://mathworld.wolfram.com/EschersSolid.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Escher’s Solid&lt;/a&gt;，自然是埃舍尔原创了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/es_solid.png&quot; alt=&quot;es&quot;&gt;&lt;/p&gt;
&lt;p&gt;它具有以下性质:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以用8个相同的小八面体粘合而成&lt;/li&gt;
&lt;li&gt;可以用3个相同的大八面体组合而成&lt;/li&gt;
&lt;li&gt;用它可以既无重复又无遗漏地填满整个空间!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我对这两幅瀑布做如下解读：水流从深度低的地方流向深度高的地方，正是这样的深度差转化为高度差，从而推动水轮机永动。&lt;/p&gt;
&lt;p&gt;那么有没有高度换深度的呢？我们来看下面这一组图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/chasm.png&quot; alt=&quot;ch&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/belvedere.jpg&quot; alt=&quot;bel&quot;&gt;&lt;/p&gt;
&lt;p&gt;这幅作品名叫 Belvedere(1958)，中文名瞭望塔。相信很容易看出这两幅图的同构性：两个本该相互垂直的斜线段被一群平行的垂线给……我认为这就是一种高度换深度(当然反过来理解为深度换高度也未尝不可)，画面提供了不同高度的垂线段，导致线段两端出现深度差，造成了图形的扭曲感。&lt;/p&gt;
&lt;p&gt;有趣的是Belvedere中底部坐在长椅上的男子，手里拿的正是impossible cube！&lt;/p&gt;
&lt;h3 id=&quot;Concave-amp-Convex&quot;&gt;&lt;a href=&quot;#Concave-amp-Convex&quot; class=&quot;headerlink&quot; title=&quot;Concave &amp;amp; Convex&quot;&gt;&lt;/a&gt;Concave &amp;amp; Convex&lt;/h3&gt;&lt;p&gt;凹凸的模糊性自然不会被两者放过。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/mv_cc.png&quot; alt=&quot;mvcc&quot;&gt;&lt;/p&gt;
&lt;p&gt;Convex and Concave(1955)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/article/Escher/convex\&amp;amp;concave.jpg&quot; alt=&quot;c&amp;amp;c&quot;&gt;&lt;/p&gt;
&lt;p&gt;有趣的是游戏中居然出现了Escher’s Solid！&lt;/p&gt;
&lt;h2 id=&quot;Postscript&quot;&gt;&lt;a href=&quot;#Postscript&quot; class=&quot;headerlink&quot; title=&quot;Postscript&quot;&gt;&lt;/a&gt;Postscript&lt;/h2&gt;&lt;p&gt;两者的同构之处也许远多于我的描述，这款游戏我玩了两次，包括Original和Forgotten Shores，遗憾的是红丝带特别关(限时购买)我再无法体验了。我相信我还会再玩第三遍，第四遍(如果它不出新的资料篇的话)……如果我有新的发现，会添加到这里。&lt;/p&gt;
&lt;p&gt;埃舍尔的作品确实像GEB作者侯世达所说的那样是一块瑰宝。其中不乏极具思想性的作品，如：画手、画廊、拿着反光球的手。这些都没有在本文中出现，仅仅是因为我还没有在MV这款游戏中找到它们的身影。顺便提一下，MV中的音乐也很不错，虽然跟赋格是两码事。&lt;/p&gt;
&lt;h2 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Impossible_cube&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Impossible_cube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Penrose_triangle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Penrose_triangle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Impossible_object&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Impossible_object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/M._C._Escher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;M._C._Escher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Stars_(M._C._Escher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stars_(M._C._Escher)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Lionel_Penrose&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lionel_Penrose&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Roger_Penrose&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Roger_Penrose&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Penrose_tiling&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Penrose_tiling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_polyhedron_compound&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Uniform_polyhedron_compound&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mathworld.wolfram.com/topics/PolyhedronCompounds.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PolyhedronCompounds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.guokr.com/article/19538/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.guokr.com/article/19538/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;博客写了1.5年左右的时间了，内容尽是些无足轻重的雕虫小技，与其说是博客，不如唤作笔记来的贴切。每当码字的时候，潜意识中总是明白光标下的东西不会被人关注，因此不论是标点、措辞、内容的逻辑性……都全然不顾，敲下的东西更像是当前的我和日后翻阅时的我之间的对话。它们的糟糕程度正好就反映了我的懒散程度。&lt;/p&gt;
    
    </summary>
    
      <category term="fun" scheme="http://farseer.cn/categories/fun/"/>
    
    
      <category term="game" scheme="http://farseer.cn/tags/game/"/>
    
      <category term="art" scheme="http://farseer.cn/tags/art/"/>
    
  </entry>
  
</feed>
